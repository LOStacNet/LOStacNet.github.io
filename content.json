{"meta":{"title":"LO_StacNet的火柴盒","subtitle":"","description":"LO_StacNet的个人博客","author":"LO_StacNet","url":"https://lostacnet.top","root":"/"},"pages":[{"title":"About","date":"2023-02-19T07:34:05.646Z","updated":"2023-02-19T07:34:05.646Z","comments":false,"path":"about/index.html","permalink":"https://lostacnet.top/about/","excerpt":"","text":"Hello World!这是学习代码最开始的一句，也可以是学习的代码的最终。"},{"title":"Categories","date":"2023-02-18T16:20:28.686Z","updated":"2023-02-18T16:20:28.686Z","comments":false,"path":"categories/index.html","permalink":"https://lostacnet.top/categories/","excerpt":"","text":""},{"title":"Links","date":"2023-02-19T07:32:46.372Z","updated":"2023-02-19T07:32:46.372Z","comments":true,"path":"links/index.html","permalink":"https://lostacnet.top/links/","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-18T16:21:37.660Z","updated":"2023-02-18T16:21:37.660Z","comments":false,"path":"repository/index.html","permalink":"https://lostacnet.top/repository/","excerpt":"","text":""},{"title":"Tags","date":"2023-02-18T16:22:13.563Z","updated":"2023-02-18T16:22:13.563Z","comments":false,"path":"tags/index.html","permalink":"https://lostacnet.top/tags/","excerpt":"","text":""}],"posts":[{"title":"ESP-IDF学习笔记-IIC与FT6236触摸屏","slug":"ESP-IDF学习笔记-IIC与FT6236触摸屏","date":"2024-04-29T17:32:28.000Z","updated":"2024-08-13T07:27:41.210Z","comments":true,"path":"post/43032/","link":"","permalink":"https://lostacnet.top/post/43032/","excerpt":"ESP-IDF学习笔记-IIC与FT6236触摸屏FT6236是一个电容屏驱动芯片，支持单点+手势或者双点触控，基于I2C协议。本篇将在ESP32C3下基于IDF开发其驱动。同时学习IIC驱动的使用。","text":"ESP-IDF学习笔记-IIC与FT6236触摸屏FT6236是一个电容屏驱动芯片，支持单点+手势或者双点触控，基于I2C协议。本篇将在ESP32C3下基于IDF开发其驱动。同时学习IIC驱动的使用。 官方文档datasheet I2C驱动程序 IDF的IIC驱动ESP32-C3拥有一个IIC控制器，IDF为其提供了完整的驱动。 版本变更在最新版的IDF中，IIC驱动分为新驱动和老驱动，他们在对用户开放的API上有所不同。老驱动引用头文件driver/i2c.h，新驱动则是i2c_master.h，i2c_slave.h。本文使用老驱动。 配置驱动程序建立IIC通信的第一步是配置驱动程序，使用i2c_config_t结构体以及i2c_param_config() 函数进行设置。 i2c_config_t: 123456789101112131415161718192021typedef struct{ i2c_mode_t mode; /*!&lt; I2C mode */ int sda_io_num; /*!&lt; GPIO number for I2C sda signal */ int scl_io_num; /*!&lt; GPIO number for I2C scl signal */ bool sda_pullup_en; /*!&lt; Internal GPIO pull mode for I2C sda signal*/ bool scl_pullup_en; /*!&lt; Internal GPIO pull mode for I2C scl signal*/ union { struct { uint32_t clk_speed; /*!&lt; I2C clock frequency for master mode, (no higher than 1MHz for now) */ } master; /*!&lt; I2C master config */#if SOC_I2C_SUPPORT_SLAVE struct { uint8_t addr_10bit_en; /*!&lt; I2C 10bit address mode enable for slave mode */ uint16_t slave_addr; /*!&lt; I2C address for slave mode */ uint32_t maximum_speed; /*!&lt; I2C expected clock speed from SCL. */ } slave; /*!&lt; I2C slave config */#endif // SOC_I2C_SUPPORT_SLAVE }; uint32_t clk_flags; /*!&lt; Bitwise of ``I2C_SCLK_SRC_FLAG_**FOR_DFS**`` for clk source choice*/} i2c_config_t; 上述结构中，我们需要关注以下几个成员： mode:选择I2C的模式，可选参数为：I2C_MODE_SLAVE,I2C_MODE_MASTER。 sda\\scl_io_num:信号线引脚 sda\\scl_pullup_en:内部上拉使能 master.clk_speed:时钟频率 从模式本次暂不涉及。clk_flags用以选择时钟源，一般默认0即可。 设置完成后调用函数进行设置： 1esp_err_t i2c_param_config(i2c_port_t i2c_num, const i2c_config_t *i2c_conf) i2c_num标识了使用芯片的哪一个I2C控制器。该函数还设置了I2C标准的一些默认参数(高低电平时间，起始信号时序等)，想要修改这些参数可以在用户自定义配置进行查看。 安装驱动程序配置完成后，调用函数安装驱动： 1esp_err_t i2c_driver_install(i2c_port_t i2c_num, i2c_mode_t mode, size_t slv_rx_buf_len, size_t slv_tx_buf_len,int intr_alloc_flags) i2c_num为上面使用的I2C控制器代号，mod为模式选择。 buf_len参数为从模式下用以缓存数据，主模式不用管。intr_alloc_flags设置中断分配的标志，这里为0即可。 主机模式下的通信这里我们只考虑主机通信这一常用模式。 I2C的驱动使用了一个命令容器的机制，用户首先创建一个命令容器，然后将要进行的各种I2C动作(包括开始时序、写地址、写数据、读数据等)依次填入命令容器，最后执行命令容器，将所有操纵传递给控制器执行，具体过程如下图所示： 主机写入数据 主机读取数据 命令容器的创建 1i2c_cmd_handle_t handle = i2c_cmd_link_create(); 该命令会动态的分配一段内存创建命令容器。如果不想使用动态内存分配，可以使用静态创建方式： 123uint8_t buffer[I2C_TRANS_BUF_MINIMUM_SIZE] = { 0 };i2c_cmd_handle_t handle = i2c_cmd_link_create_static(buffer, sizeof(buffer)); 发送开始时序 1err = i2c_master_start(handle); 写单个字节——发送地址 1234//进行写操作err = i2c_master_write_byte(handle, device_address &lt;&lt; 1 | I2C_MASTER_WRITE, ACK_EN);//进行读操作err = i2c_master_write_byte(handle, device_address &lt;&lt; 1 | I2C_MASTER_READ, ACK_EN); 读写数据 123456//写操作err = i2c_master_write(handle, write_buffer, write_size, ACK_EN);//读操作err = i2c_master_read(handle, read_buffer, read_size, I2C_MASTER_LAST_NACK);//读单个字节err = i2c_master_read_byte(handle, &amp;read_buffer, I2C_MASTER_LAST_NACK); i2c_ack_type_t规定了如何进行ACK相应，有三类：I2C_MASTER_ACK为每个直接响应ACK，I2C_MASTER_NACK为每个字节响应NACK，I2C_MASTER_LAST_NACK最后一个字节响应NACK。 结束时序 1i2c_master_stop(handle); 执行命令 1err = i2c_master_cmd_begin(i2c_num, handle, ticks_to_wait); 释放命令容器内存 1234//释放动态i2c_cmd_link_delete(handle);//释放静态内存i2c_cmd_link_delete_static(handle); 删除驱动1i2c_driver_delete(I2C_MASTER_NUM); 释放资源。该函数无法保证线程安全。 其他读写函数驱动中提供了一些预制的命令容器读写函数,可以满足一些常见的读写需求，函数如下： 12345678910esp_err_t i2c_master_write_to_device(i2c_port_t i2c_num, uint8_t device_address, const uint8_t* write_buffer, size_t write_size, TickType_t ticks_to_wait);esp_err_t i2c_master_read_from_device(i2c_port_t i2c_num, uint8_t device_address, uint8_t* read_buffer, size_t read_size, TickType_t ticks_to_wait);esp_err_t i2c_master_write_read_device(i2c_port_t i2c_num, uint8_t device_address, const uint8_t* write_buffer, size_t write_size, uint8_t* read_buffer, size_t read_size, TickType_t ticks_to_wait); 其中i2c_master_read_from_device的时序满足的是EEPROM的随机读时序(写完寄存器地址后直接发送Start信号)。 FT6236引脚定义FT6236触摸屏一共有6个引脚，除去3.3V供电和GND以外，还有以下几个： SDA:IIC的数据线，需要上拉到VCC。 SCL:IIC的时钟线，需要上拉到VCC。 INT:中断信号线，指示是否有触摸点，低电平有效，有触摸点时可以根据设置发出低脉冲或持续拉低。需要上拉到VCC。 RST:复位信号线。低电平有效，需要持续低电平300ms以上，需要上拉到VCC。 注意各个信号线的上拉，这很重要。 设备结构体设置一个数据结构体作为一个设备的实例。 1234567891011121314typedef struct { int8_t int_pin; int8_t rst_pin; struct { uint8_t sda_pin; uint8_t scl_pin; uint8_t addr; i2c_port_t i2c_num; }i2c;//存储bsp相关数据 touch_panel_dir_t direction; uint16_t width; uint16_t height;} ft6236_dev_t; 数据读写函数FT6236的读写时序如下： 写寄存器 开始-地址-寄存器地址-数据-结束 读寄存器 开始-地址-寄存器地址-结束 开始-地址-读数据-结束 使用IDF的IIC部分相关代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static uint8_t ft6236_interface_init(ft6236_dev_t *dev){//iic初始化，gpio初始化 esp_err_t err=ESP_OK; i2c_config_t config={ .mode=I2C_MODE_MASTER, .sda_io_num=dev-&gt;i2c.sda_pin, .scl_io_num=dev-&gt;i2c.scl_pin, .scl_pullup_en=GPIO_PULLUP_ENABLE, .sda_pullup_en=GPIO_PULLUP_ENABLE, .master.clk_speed=400000, .clk_flags=0 }; err |= i2c_param_config(dev-&gt;i2c.i2c_num,&amp;config); err |= i2c_driver_install(dev-&gt;i2c.i2c_num,config.mode,0,0,0); //int_pin must be pulled up if(dev-&gt;int_pin != -1) { gpio_set_direction(dev-&gt;int_pin, GPIO_MODE_INPUT); gpio_set_pull_mode(dev-&gt;int_pin, GPIO_PULLUP_ONLY); } //rst_pin if(dev-&gt;rst_pin != -1) { gpio_set_direction(dev-&gt;rst_pin, GPIO_MODE_OUTPUT); gpio_set_level(dev-&gt;rst_pin, 0); vTaskDelay(400 / portTICK_PERIOD_MS);//at last 300ms gpio_set_level(dev-&gt;rst_pin, 1); } return err;}static void ft6236_interface_deinit(ft6236_dev_t *dev){ i2c_driver_delete(dev-&gt;i2c.i2c_num); if(dev-&gt;int_pin != -1) gpio_reset_pin(dev-&gt;int_pin); if(dev-&gt;rst_pin != -1) gpio_reset_pin(dev-&gt;rst_pin);}static uint8_t ft6236_write_one_reg(ft6236_dev_t *dev,uint8_t start_addr,uint8_t write_size,uint8_t *data_buf){//按照时序写寄存器 esp_err_t err=ESP_OK; i2c_port_t i2c_num=dev-&gt;i2c.i2c_num; uint8_t _data[2]={start_addr,data}; i2c_cmd_handle_t handle=i2c_cmd_link_create(); if(handle==NULL) return 1; i2c_master_start(handle); i2c_master_write_byte(handle, (dev-&gt;i2c.addr &lt;&lt; 1) | I2C_MASTER_WRITE, true); i2c_master_write(handle, _data, 2, true); i2c_master_stop(handle); err = i2c_master_cmd_begin(i2c_num, handle, 1000*portTICK_PERIOD_MS); i2c_cmd_link_delete(handle); return err==ESP_OK ? 0:1;}static uint8_t ft6236_read_reg(ft6236_dev_t *dev,uint8_t start_addr,uint8_t read_num,uint8_t *data_buf){//按照时序读寄存器 esp_err_t err=ESP_OK; i2c_port_t i2c_num=dev-&gt;i2c.i2c_num; i2c_cmd_handle_t handle=i2c_cmd_link_create(); if(handle==NULL) return 1; //First, set the reg address err|=i2c_master_start(handle); err|=i2c_master_write_byte(handle, (dev-&gt;i2c.addr &lt;&lt; 1) | I2C_MASTER_WRITE, true); err|=i2c_master_write_byte(handle, start_addr, true); err|=i2c_master_stop(handle); err|=i2c_master_cmd_begin(i2c_num, handle, 1000/portTICK_PERIOD_MS); i2c_cmd_link_delete(handle); if(err!=ESP_OK) return 1;//return if error //then read data handle=i2c_cmd_link_create(); if(handle==NULL) return 1; err|=i2c_master_start(handle); err|=i2c_master_write_byte(handle, (dev-&gt;i2c.addr &lt;&lt; 1) | I2C_MASTER_READ, true); err|=i2c_master_read(handle, data_buf, read_num,I2C_MASTER_LAST_NACK); err|=i2c_master_stop(handle); err|=i2c_master_cmd_begin(i2c_num, handle, 1000/portTICK_PERIOD_MS); i2c_cmd_link_delete(handle); return err==ESP_OK ? 0:1;} 上面的函数是整个驱动的底层，进行移植时需要重新编写移植这些代码。 芯片寄存器查看芯片的datasheet，可以看到芯片的寄存器 这里注意几个比较重要的寄存器: P1_xxx: 触摸点数据寄存器。 Event Flag说明了触摸点的数据：00b-按下，01b-松开，10b-Contact，11b-No event。 Touch ID说明是第几个触摸点,当点不可用时，值为0x0F。 WEIGHT存储了触摸点的按压力度。 GEST_ID 存储了触摸手势的判断： 0x10——Move Up 0x14——Move Right 0x18——Move Down 0x1C——Move Left 0x48——Zoom In 0x49——Zoom Out 0x00——No Gesture TD_STATUS 存储了触摸点数量，有效值为1-2。 TD_GROUP 触摸检测阈值设置，越小越灵敏。 G_MODE 中断引脚模式。 polling mode：当有触摸数据时，引脚一直为低。 trigger mode：有触摸数据时，引脚会有一个有效电平低的脉冲。 ESP-IDF触摸屏的驱动框架ESP组件库中有一个触摸屏驱动库，但是很不幸，该库中没有FT6236的驱动，因此需要根据其驱动框架编写FT6236的驱动。 用户数据结构驱动库需要定义一些外部的数据结构，用来给用户读取和设置驱动。 触摸板方向设置 该设置用于改变驱动输出坐标的原点位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef enum { /* @---&gt; X | Y */ TOUCH_DIR_LRTB, /**&lt; From left to right then from top to bottom, this consider as the original direction of the touch panel*/ /* Y | @---&gt; X */ TOUCH_DIR_LRBT, /**&lt; From left to right then from bottom to top */ /* X &lt;---@ | Y */ TOUCH_DIR_RLTB, /**&lt; From right to left then from top to bottom */ /* Y | X &lt;---@ */ TOUCH_DIR_RLBT, /**&lt; From right to left then from bottom to top */ /* @---&gt; Y | X */ TOUCH_DIR_TBLR, /**&lt; From top to bottom then from left to right */ /* X | @---&gt; Y */ TOUCH_DIR_BTLR, /**&lt; From bottom to top then from left to right */ /* Y &lt;---@ | X */ TOUCH_DIR_TBRL, /**&lt; From top to bottom then from right to left */ /* X | Y &lt;---@ */ TOUCH_DIR_BTRL, /**&lt; From bottom to top then from right to left */ TOUCH_DIR_MAX} touch_panel_dir_t; 触摸事件 该数据结构表示了触摸点的触摸事件，是按下还是松开。 123456typedef enum { TOUCH_EVT_PRESS = 0x0, /*!&lt; Press event */ TOUCH_EVT_RELEASE = 0x1, /*!&lt; Release event */ TOUCH_EVT_CONTACT = 0x2, /*!&lt; Contact event */ TOUCH_EVT_NONE = 0x3, /*!&lt; no event */} touch_panel_event_t; 触摸手势 有些触摸屏可以检测触摸手势，而FT6236能够检测6种手势。驱动提供了一个数据结构用来描述。 123456789typedef enum { TOUCH_GES_NONE = 0x00, /*!&lt; No Gesture */ TOUCH_GES_MOVE_UP = 0x10, /*!&lt; Move up */ TOUCH_GES_MOVE_RIGHT = 0x14, /*!&lt; Move right */ TOUCH_GES_MOVE_DOWN = 0x18, /*!&lt; Move down */ TOUCH_GES_MOVE_LEFT = 0x1C, /*!&lt; Move left */ TOUCH_GES_ZOOM_IN = 0x48, /*!&lt; Zoom in */ TOUCH_GES_ZOOM_OUT = 0x49, /*!&lt; Zoom out */} touch_panel_gesture; 触摸屏配置结构体 用来传入配置参数的结构体。 12345678910111213typedef struct { struct { uint8_t addr; /*!&lt; dev's address */ i2c_port_t i2c_num; /*!&lt; i2c port to use */ uint8_t i2c_scl; /*!&lt; i2c scl pin */ uint8_t i2c_sda; /*!&lt; i2c sda pin */ }i2c; /*!&lt; i2c bsp config */ int8_t pin_num_int; /*!&lt; Interrupt pin of touch panel. NOTE: You can set to -1 for no connection with hardware. If PENIRQ is connected, set this to pin number. */ int8_t pin_num_rst; /*!&lt; rst pin */ touch_panel_dir_t direction; /*!&lt; Rotate direction */ uint16_t width; /*!&lt; touch panel width */ uint16_t height; /*!&lt; touch panel height */} touch_panel_config_t; 触摸点信息 用于驱动向用户传递触摸点信息。 12345678typedef struct { uint8_t point_num; /*!&lt; Touch point number */ touch_panel_gesture gesture; /*!&lt; Gesture of touch */ touch_panel_event_t event[TOUCH_MAX_POINT_NUMBER]; /*!&lt; Event of touch */ uint8_t weight[TOUCH_MAX_POINT_NUMBER]; /*!&lt; weight of touch */ uint16_t curx[TOUCH_MAX_POINT_NUMBER]; /*!&lt; Current x coordinate */ uint16_t cury[TOUCH_MAX_POINT_NUMBER]; /*!&lt; Current y coordinate */} touch_panel_points_t; 内部数据结构驱动内部使用一个结构体用来代指一个设备，该结构体已经在上面给出。 用户函数驱动需要实现以下函数： 初始化与反初始化函数 初始化内部的设备结构体，同时初始化相关外设以及相关的寄存器。 1234567891011121314151617181920212223242526272829303132333435uint8_t ft6236_init(touch_panel_config_t *config){ uint8_t ret=0; uint8_t cipher=0;//must be 0x64 uint8_t firmid=0;//Firmware Version uint8_t data=0; g_dev.i2c.addr=config-&gt;i2c.addr; g_dev.i2c.i2c_num=config-&gt;i2c.i2c_num; g_dev.i2c.scl_pin=config-&gt;i2c.i2c_scl; g_dev.i2c.sda_pin=config-&gt;i2c.i2c_sda; g_dev.int_pin=config-&gt;pin_num_int; g_dev.rst_pin=config-&gt;pin_num_rst; g_dev.width=config-&gt;width; g_dev.height=config-&gt;height; ft6236_set_direction(config-&gt;direction); //bsp initialize and test ret += ft6236_interface_init(&amp;g_dev); ret += ft6236_read_reg(&amp;g_dev,FT6236_REG_FIRMID,1,&amp;firmid); ret += ft6236_read_reg(&amp;g_dev,FT6236_REG_CIPHER,1,&amp;cipher); if(ret!=0 ||cipher!=0x64)//chip id changes with chips { ESP_LOGI(TAG,\"Initialize interface fail.cipher=%x firmware version=%x.\",cipher,firmid); return 1; } ESP_LOGI(TAG,\"cipher=%x firmware version=%x.\",cipher,firmid); //set the interrupt mod to polling(continuous low level) data=0; ret += ft6236_write_one_reg(&amp;g_dev, FT6236_REG_G_MODE, data); //set the touch detect threshold(lower is sensitive) data=22; ret += ft6236_write_one_reg(&amp;g_dev, FT6236_REG_TH_GROUP, data); return ret;} 1234void ft6236_deinit(void){ ft6236_interface_deinit(&amp;g_dev);} 坐标方向设置函数 用于改变屏幕方向。 12345678uint8_t ft6236_set_direction(touch_panel_dir_t dir) { if (TOUCH_DIR_MAX &lt; dir) { dir &gt;&gt;= 5; } g_dev.direction = dir; return 0;} 查询与数据获取 通过int引脚或者读取寄存器来判断是否有触摸点。 1234567891011121314151617181920/** * confirm if there is touch event * @return 1:touched 0:nothing */uint8_t ft6236_is_press(void){/** * @note There are two ways to determine weather the touch panel is pressed * 1. Read the IRQ line of touch controller * 2. Read number of points touched in the register */ if (-1 != g_dev.int_pin) { return !gpio_get_level((gpio_num_t)g_dev.int_pin); } uint8_t num; ft6236_read_reg(&amp;g_dev,FT6236_REG_TD_STATUS,1,&amp;num); if((num&amp;0x07) ==0) return 0; return 1;} 数据点信息读取： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647uint8_t ft6236_get_points(touch_panel_points_t *info){ uint8_t data_buf[14]; uint8_t point_index=0; ft6236_read_reg(&amp;g_dev,FT6236_REG_GEST_ID,14,data_buf); info-&gt;point_num =data_buf[1] &amp;0x07;//get TD_STATUS if (info-&gt;point_num &gt; 0 &amp;&amp; info-&gt;point_num &lt;= TOUCH_MAX_POINT_NUMBER) { info-&gt;gesture=data_buf[0];//get the gesture ID if(data_buf[4]&gt;&gt;4!=0x0F)//Touch ID is valid { info-&gt;event[point_index] = data_buf[2] &gt;&gt; 6; info-&gt;curx[point_index] = (((uint16_t)(data_buf[2]&amp;0x0F) &lt;&lt; 8) | data_buf[3]); info-&gt;cury[point_index] = (((uint16_t)(data_buf[4]&amp;0x0F) &lt;&lt; 8) | data_buf[5]); info-&gt;weight[point_index] = data_buf[6]; ft6236_apply_rotate(&amp;info-&gt;curx[point_index],&amp;info-&gt;cury[point_index]); point_index++; } if(data_buf[10]&gt;&gt;4!=0x0F)//Touch ID is valid { info-&gt;event[point_index] = data_buf[8] &gt;&gt; 6; info-&gt;curx[point_index] = (((uint16_t)(data_buf[8]&amp;0x0F) &lt;&lt; 8) | data_buf[9]); info-&gt;cury[point_index] = (((uint16_t)(data_buf[10]&amp;0x0F) &lt;&lt; 8) | data_buf[11]); info-&gt;weight[point_index] = data_buf[12]; ft6236_apply_rotate(&amp;info-&gt;curx[point_index],&amp;info-&gt;cury[point_index]); point_index++; } if(point_index==1){//clean the unused info info-&gt;curx[1] = 0; info-&gt;cury[1] = 0; }// ESP_LOGI(TAG,\"Touch ID--1:%x,2:%x\",data_buf[4],data_buf[10]); return info-&gt;point_num; } else { info-&gt;curx[0] = 0; info-&gt;cury[0] = 0; info-&gt;curx[1] = 0; info-&gt;cury[1] = 0; } return 0;} 内部函数内部函数是驱动中需要使用的一些功能，除了上面的interface_init和reg读取，还有不同触摸屏方向下坐标的换算。 12345678910111213141516171819202122232425262728293031323334353637383940414243static void ft6236_apply_rotate(uint16_t *x, uint16_t *y){ uint16_t _x = *x; uint16_t _y = *y; switch (g_dev.direction) { case TOUCH_DIR_LRTB: *x = _x; *y = _y; break; case TOUCH_DIR_LRBT: *x = _x; *y = g_dev.height - _y; break; case TOUCH_DIR_RLTB: *x = g_dev.width - _x; *y = _y; break; case TOUCH_DIR_RLBT: *x = g_dev.width - _x; *y = g_dev.height - _y; break; case TOUCH_DIR_TBLR: *x = _y; *y = _x; break; case TOUCH_DIR_BTLR: *x = _y; *y = g_dev.width - _x; break; case TOUCH_DIR_TBRL: *x = g_dev.height - _y; *y = _x; break; case TOUCH_DIR_BTRL: *x = g_dev.height - _y; *y = g_dev.width - _x; break; default: break; }}","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ZYNQ学习笔记-IIC驱动的开发","slug":"ZYNQ学习笔记-IIC驱动的开发","date":"2024-04-16T11:33:12.000Z","updated":"2024-08-10T13:08:20.980Z","comments":true,"path":"post/41633/","link":"","permalink":"https://lostacnet.top/post/41633/","excerpt":"ZYNQ学习笔记-IIC驱动的开发linux中有着一个IIC子系统，为IIC设备驱动提供了抽象IIC接口。IIC与硬件相关的底层驱动由芯片厂商进行适配，普通用户只需要关注上层的抽象层即可完成驱动开发。","text":"ZYNQ学习笔记-IIC驱动的开发linux中有着一个IIC子系统，为IIC设备驱动提供了抽象IIC接口。IIC与硬件相关的底层驱动由芯片厂商进行适配，普通用户只需要关注上层的抽象层即可完成驱动开发。 Linux中IIC设备的重要概念关于IIC子系统，有几个重要的概念需要掌握。首先看一下IIC子系统的框图： I2C核心：提供抽象层代码的核心。 I2C总线驱动：提供I2C通信能力。 I2C设备驱动：提供设备的注册和设备驱动的注册。 对于用户来说，需要弄明白以下几个数据结构(均定义在include/linux/i2c.h 中)： i2c_adapter结构体:对应I2C外设的抽象层，每个代表一个外设。 i2c_algorithm结构体:对应I2C的传输方法，包含在i2c_adapter中，传输具体数据时调用的函数方法。 上面两者的具体实现方法由芯片公司提供的I2C总线驱动实现，普通用户无需知道细节。对普通用户来说，需要重点关注以下几个数据结构; i2c_client结构体: 12345678910111213struct i2c_client { unsigned short flags; // 标志 unsigned short addr; // 芯片地址， 7 位，存在低 7 位 char name[I2C_NAME_SIZE]; // 设备名字 struct i2c_adapter *adapter; // 对应的 I2C 适配器 struct device dev; // 内置 device 结构体 int irq; // 中断 struct list_head detected; #if IS_ENABLED(CONFIG_I2C_SLAVE) i2c_slave_cb_t slave_cb; /* callback for slave mode */ #endif} 一个I2C总线下的从设备对应一个i2c_client结构体变量。当驱动每匹配上一个设备时(通过设备树的compatible与of表匹配或者无设备树的i2c_device_id的name与I2C设备名字是否相同)，系统就会分配一个client。 i2c_driver结构体: 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct i2c_driver { unsigned int class; /* Notifies the driver that a new bus has appeared. You should avoid * using this, it will be removed in a near future. */ int (*attach_adapter)(struct i2c_adapter *) __deprecated; /* Standard driver model interfaces */ int (*probe)(struct i2c_client *, const struct i2c_device_id *); int (*remove)(struct i2c_client *); /* New driver model interface to aid the seamless removal of the * current probe()'s, more commonly unused than used second parameter. */ int (*probe_new)(struct i2c_client *); /* driver model interfaces that don't relate to enumeration */ void (*shutdown)(struct i2c_client *); /* Alert callback, for example for the SMBus alert protocol. * The format and meaning of the data value depends on the protocol. * For the SMBus alert protocol, there is a single bit of data passed * as the alert response's low bit (\"event flag\"). * For the SMBus Host Notify protocol, the data corresponds to the * 16-bit payload data reported by the slave device acting as master. */ void (*alert)(struct i2c_client *, enum i2c_alert_protocol protocol, unsigned int data); /* a ioctl like command that can be used to perform specific functions * with the device. */ int (*command)(struct i2c_client *client, unsigned int cmd, void *arg); struct device_driver driver; const struct i2c_device_id *id_table; /* Device detection callback for automatic device creation */ int (*detect)(struct i2c_client *, struct i2c_board_info *); const unsigned short *address_list; struct list_head clients; bool disable_i2c_core_irq_mapping;}; 这个结构体中，需要注意几个成员： 123/* Standard driver model interfaces */int (*probe)(struct i2c_client *, const struct i2c_device_id *);int (*remove)(struct i2c_client *); probe函数在设备匹配成功后会执行，每次匹配得到一个i2c_client。 remove函数在注销设备时使用，要注销的设备通过i2c_client传入。 12struct device_driver driver;const struct i2c_device_id *id_table; 两个成员设计IIC设备的匹配。传统匹配使用i2c_device_id表进行，使用设备树则用device_driver中的of_match_table 成员变量匹配compatible。 IIC驱动的单位是driver，IIC驱动加载时需要调用函数： 1int i2c_register_driver(struct module *owner,struct i2c_driver *driver) owner一般为THIS_MODULE。 与该函数对应有个宏帮助传递owner参数： 12#define i2c_add_driver(driver) \\ i2c_register_driver(THIS_MODULE, driver) 卸载驱动时需要调用注销： 1void i2c_del_driver(struct i2c_driver *driver) IIC驱动的单位是driver，这句话理解为，一个driver对应多个client，即一个驱动可以驱动多个同类型设备(基于匹配表)。每匹配到一个client，都需要在probe把字符设备创建过程跑一遍，在remove把注销过程跑一遍。 一般的驱动注册结构对于一般用户，需要注册i2c_driver，一般的注册结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* i2c 驱动的 probe 函数 */static int xxx_probe(struct i2c_client *client, const struct i2c_device_id *id){ /* 函数具体程序 */ return 0;}/* i2c 驱动的 remove 函数 */static int xxx_remove(struct i2c_client *client){/* 函数具体程序 */ return 0;}/* 传统匹配方式 ID 列表 */static const struct i2c_device_id xxx_id[] = { {\"xxx\", 0}, {}};/* 设备树匹配列表 */static const struct of_device_id xxx_of_match[] = { { .compatible = \"xxx\" }, { /* Sentinel */ }};/* i2c 驱动结构体 */static struct i2c_driver xxx_driver = { .probe = xxx_probe, .remove = xxx_remove, .driver = { .owner = THIS_MODULE, .name = \"xxx\", .of_match_table = xxx_of_match, }, .id_table = xxx_id,};/* 驱动入口函数 */static int __init xxx_init(void){ int ret = 0; ret = i2c_add_driver(&amp;xxx_driver); return ret;}/* 驱动出口函数 */static void __exit xxx_exit(void){ i2c_del_driver(&amp;xxx_driver);}module_init(xxx_init);module_exit(xxx_exit); 同时Linux也提供了一个宏来简化驱动注册： 1module_i2c_driver(xxx_driver); 宏展开后是： 12345678910static int __init xxx_driver_init(void){return i2c_add_driver(&amp;xxx_driver);}module_init(xxx_driver_init);static void __exit xxx_driver_exit(void){i2c_del_driver(&amp;xxx_driver);}module_exit(xxx_driver_exit); 可见方便了使用。 设备匹配方式 无设备树时匹配方式 老式匹配方式，这里不再多说。需要使用一个i2c_board_info 结构体来描述一个设备。 设备树添加方式 示例： 12345678&amp;i2c0 { clock-frequency = &lt;100000&gt;; rtc@51 { compatible = \"nxp,pcf8563\"; reg = &lt;0x51&gt;; };}; 对以上，驱动中的of_match表如下： 12345/* 匹配列表 */static const struct of_device_id pcf8563_of_match[] = {{ .compatible = \"zynq-pcf8563\" }, { /* Sentinel */ }}; 实际数据传输函数匹配到设备后需要利用IIC传输实际的数据，这里就涉及到一个函数： 123int i2c_transfer(struct i2c_adapter *adap,struct i2c_msg *msgs,int num) 该函数最终会调用I2C 适配器中 i2c_algorithm 里面的 master_xfer 函数 ，即IIC总线驱动中硬件相关传输函数。 该函数参数如下： adap： 所使用的 I2C 适配器， i2c_client.i2c_adapter。msgs： I2C 要发送的一个或多个消息。num： 消息数量，也就是 msgs 的数量。返回值： 负值，失败，其他非负值，发送的 msgs 数量。 i2c_msg定义在include/uapi/linux/i2c.h : 123456789101112131415struct i2c_msg { __u16 addr; /* 从机地址 */ __u16 flags; /* 标志 */ #define I2C_M_RD 0x0001 /* read data, from slave to master *//* I2C_M_RD is guaranteed to be 0x0001! */ #define I2C_M_TEN 0x0010 /* this is a ten bit chip address */ #define I2C_M_RECV_LEN 0x0400 /* length will be first received byte */ #define I2C_M_NO_RD_ACK 0x0800 /* if I2C_FUNC_PROTOCOL_MANGLING */ #define I2C_M_IGNORE_NAK 0x1000 /* if I2C_FUNC_PROTOCOL_MANGLING */ #define I2C_M_REV_DIR_ADDR 0x2000 /* if I2C_FUNC_PROTOCOL_MANGLING */ #define I2C_M_NOSTART 0x4000 /* if I2C_FUNC_NOSTART */ #define I2C_M_STOP 0x8000 /* if I2C_FUNC_PROTOCOL_MANGLING */ __u16 len; /* 消息（数据）长度 */ __u8 *buf; /* 消息（数据）地址 */}; 传输前一般都会先构建好msg。 使用该函数读取I2C设备寄存器的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 /* 设备结构体 */struct xxx_dev { ...... void *private_data; /* 私有数据，一般会设置为 i2c_client */};/** * @description : 读取 I2C 设备多个寄存器数据 * @param – dev : I2C 设备 * @param – reg : 要读取的寄存器首地址 * @param – val : 读取到的数据 * @param – len : 要读取的数据长度 * @return : 操作结果 */static int xxx_read_regs(struct xxx_dev *dev, u8 reg, void *val, int len){ int ret; struct i2c_msg msg[2]; struct i2c_client *client = (struct i2c_client *)dev-&gt;private_data; /* msg[0]，第一条写消息，发送要读取的寄存器首地址 */ msg[0].addr = client-&gt;addr; /* I2C 器件地址 */ msg[0].flags = 0; /* 标记为发送数据 */ msg[0].buf = &amp;reg; /* 读取的首地址 */ msg[0].len = 1; /* reg 长度 */ /* msg[1]，第二条读消息，读取寄存器数据 */ msg[1].addr = client-&gt;addr; /* I2C 器件地址 */ msg[1].flags = I2C_M_RD; /* 标记为读取数据 */ msg[1].buf = val; /* 读取数据缓冲区 */ msg[1].len = len; /* 要读取的数据长度 */ ret = i2c_transfer(client-&gt;adapter, msg, 2); if(ret == 2) { ret = 0; } else { ret = -EREMOTEIO; } return ret;} /* * @description : 向 I2C 设备多个寄存器写入数据 * @param – dev : 要写入的设备结构体 * @param – reg : 要写入的寄存器首地址 * @param – val : 要写入的数据缓冲区 * @param – len : 要写入的数据长度 * @return : 操作结果 */static s32 xxx_write_regs(struct xxx_dev *dev, u8 reg, u8 *buf, u8 len){ u8 b[256]; struct i2c_msg msg; struct i2c_client *client = (struct i2c_client *)dev-&gt;private_data; b[0] = reg; /* 寄存器首地址 */ memcpy(&amp;b[1],buf,len); /* 将要发送的数据拷贝到数组 b 里面 */ msg.addr = client-&gt;addr; /* I2C 器件地址 */ msg.flags = 0; /* 标记为写数据 */ msg.buf = b; /* 要发送的数据缓冲区 */ msg.len = len + 1; /* 要发送的数据长度 */ return i2c_transfer(client-&gt;adapter, &amp;msg, 1);} 除此之外还有两个API函数用来收发数据，最后都会调用i2c_transfer。 123int i2c_master_send(const struct i2c_client *client, const char *buf, int count) 123int i2c_master_recv(const struct i2c_client *client, char *buf, int count) count： 要接收的数据字节数，要小于 64KB，因为 i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据。 实战-MPU6050驱动的编写首先，在设备树中添加MPU6050节点： 12345678&amp;i2c0{ clock-frequency=&lt;100000&gt;; mpu6050@68{ compatible = \"atk,mpu6050\"; reg=&lt;0x68&gt;; };}; 驱动中编写如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262#include \"mpu6050.h\"#include &lt;linux/module.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/fs.h&gt;#define MPU6050_CNT 1#define MPU6050_NAME \"mpu6050\"struct mpu6050_dev { dev_t devid; /* 设备号 */ struct cdev cdev; /* cdev */ struct class *class; /* 类 */ struct device *device; /* 设备 */ int major; /* 主设备号 */ void *private_data; /* 私有数据用于存储client*/ signed int gyro_x_adc; /* 陀螺仪X轴原始值 */ signed int gyro_y_adc; /* 陀螺仪Y轴原始值 */ signed int gyro_z_adc; /* 陀螺仪Z轴原始值 */ signed int accel_x_adc; /* 加速度计X轴原始值 */ signed int accel_y_adc; /* 加速度计Y轴原始值 */ signed int accel_z_adc; /* 加速度计Z轴原始值 */ signed int temp_adc; /* 温度原始值 */};static struct mpu6050_dev mpu6050dev;static int mpu6050_release(struct inode *inode, struct file *filp){ return 0;}static int mpu6050_open(struct inode *inode, struct file *filp){ filp-&gt;private_data = &amp;mpu6050dev; /* 设置私有数据 */ return 0;}static s32 mpu6050_write_regs(struct mpu6050_dev *dev, u8 reg, u8 *buf, u8 len){ u8 b[256]; struct i2c_msg msg; struct i2c_client *client = (struct i2c_client *)dev-&gt;private_data; b[0] = reg; /* 寄存器首地址 */ memcpy(&amp;b[1],buf,len); /* 将要写入的数据拷贝到数组b里面 */ msg.addr = client-&gt;addr; /* mpu6050地址 */ msg.flags = 0; /* 标记为写数据 */ msg.buf = b; /* 要写入的数据缓冲区 */ msg.len = len + 1; /* 要写入的数据长度 */ return i2c_transfer(client-&gt;adapter, &amp;msg, 1);}static void mpu6050_write_onereg(struct mpu6050_dev *dev, u8 reg, u8 data){ u8 buf = 0; buf = data; mpu6050_write_regs(dev, reg, &amp;buf, 1);}static int mpu6050_read_regs(struct mpu6050_dev *dev, u8 reg, void *val, int len){ int ret; struct i2c_msg msg[2]; struct i2c_client *client = (struct i2c_client *)dev-&gt;private_data; /* msg[0]为发送要读取的首地址 */ msg[0].addr = client-&gt;addr; /* */ msg[0].flags = 0; /* 标记为发送数据 */ msg[0].buf = &amp;reg; /* 读取的首地址 */ msg[0].len = 1; /* reg长度*/ /* msg[1]读取数据 */ msg[1].addr = client-&gt;addr; /* */ msg[1].flags = I2C_M_RD; /* 标记为读取数据*/ msg[1].buf = val; /* 读取数据缓冲区 */ msg[1].len = len; /* 要读取的数据长度*/ ret = i2c_transfer(client-&gt;adapter, msg, 2); if(ret == 2) { ret = 0; } else { printk(\"i2c rd failed=%d reg=%06x len=%d\\n\",ret, reg, len); ret = -EREMOTEIO; } return ret;}static unsigned char mpu6050_read_onereg(struct mpu6050_dev *dev, u8 reg){ u8 data = 0; mpu6050_read_regs(dev, reg, &amp;data, 1); return data;}void mpu6050_readdata(struct mpu6050_dev *dev){ unsigned char data[14]; mpu6050_read_regs(dev, MPU6050_RA_ACCEL_XOUT_H, data, 14); dev-&gt;accel_x_adc = (signed short)((data[0] &lt;&lt; 8) | data[1]); dev-&gt;accel_y_adc = (signed short)((data[2] &lt;&lt; 8) | data[3]); dev-&gt;accel_z_adc = (signed short)((data[4] &lt;&lt; 8) | data[5]); dev-&gt;temp_adc = (signed short)((data[6] &lt;&lt; 8) | data[7]); dev-&gt;gyro_x_adc = (signed short)((data[8] &lt;&lt; 8) | data[9]); dev-&gt;gyro_y_adc = (signed short)((data[10] &lt;&lt; 8) | data[11]); dev-&gt;gyro_z_adc = (signed short)((data[12] &lt;&lt; 8) | data[13]);}static ssize_t mpu6050_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off){signed int data[7];long err = 0;struct mpu6050_dev *dev = (struct mpu6050_dev *)filp-&gt;private_data;mpu6050_readdata(dev);data[0] = dev-&gt;gyro_x_adc;data[1] = dev-&gt;gyro_y_adc;data[2] = dev-&gt;gyro_z_adc;data[3] = dev-&gt;accel_x_adc;data[4] = dev-&gt;accel_y_adc;data[5] = dev-&gt;accel_z_adc;data[6] = dev-&gt;temp_adc;//printk(\"mpu6050 Read Data:x_adc:%d\\r\\n\",data[0]);err = copy_to_user(buf, data, sizeof(data));return 0;}/* mpu6050操作函数 */static const struct file_operations mpu6050_ops = { .owner = THIS_MODULE, .open = mpu6050_open, .read = mpu6050_read, .release = mpu6050_release,};/** * mpu6050初始化函数 */void mpu6050_reginit(void){ u8 value = 0; mpu6050_write_onereg(&amp;mpu6050dev, MPU6050_RA_PWR_MGMT_1, 0x80);//复位设备 mdelay(50); mpu6050_write_onereg(&amp;mpu6050dev, MPU6050_RA_PWR_MGMT_1, 0x01);//退出休眠模式,选择X轴PLL作为时钟 mdelay(50); value = mpu6050_read_onereg(&amp;mpu6050dev, MPU6050_RA_WHO_AM_I); printk(\"mpu6050 ID = %#X\\r\\n\", value); mpu6050_write_onereg(&amp;mpu6050dev, MPU6050_RA_SMPLRT_DIV, 0x00); /* 输出速率是内部采样率 */ //设置量程为最小，提高精度 mpu6050_write_onereg(&amp;mpu6050dev, MPU6050_RA_GYRO_CONFIG, 0x00); /* 陀螺仪±250dps量程 */ mpu6050_write_onereg(&amp;mpu6050dev, MPU6050_RA_ACCEL_CONFIG, 0x00); /* 加速度计±2G量程 */// mpu6050_write_onereg(&amp;mpu6050dev, MPU6050_RA_GYRO_CONFIG, 0x18); /* 陀螺仪±2000dps量程 */// mpu6050_write_onereg(&amp;mpu6050dev, MPU6050_RA_ACCEL_CONFIG, 0x18); /* 加速度计±16G量程 */ mpu6050_write_onereg(&amp;mpu6050dev, MPU6050_RA_CONFIG, 0x04); /* 陀螺仪低通滤波BW=20Hz */ mpu6050_write_onereg(&amp;mpu6050dev, MPU6050_RA_PWR_MGMT_2, 0x00); /* 打开加速度计和陀螺仪所有轴 */ mpu6050_write_onereg(&amp;mpu6050dev, MPU6050_RA_FIFO_EN, 0x00); /* 关闭FIFO */}static int mpu6050_probe(struct i2c_client *client, const struct i2c_device_id *id){ int ret = 0; /* 1、构建设备号 */ if (mpu6050dev.major) { mpu6050dev.devid = MKDEV(mpu6050dev.major, 0); ret=register_chrdev_region(mpu6050dev.devid, MPU6050_CNT, MPU6050_NAME); } else { ret=alloc_chrdev_region(&amp;mpu6050dev.devid, 0, MPU6050_CNT, MPU6050_NAME); mpu6050dev.major = MAJOR(mpu6050dev.devid); } if(ret) return ret; /* 2、注册cdev设备 */ cdev_init(&amp;mpu6050dev.cdev, &amp;mpu6050_ops); ret=cdev_add(&amp;mpu6050dev.cdev, mpu6050dev.devid, MPU6050_CNT); if(ret) goto out1; /* 3、创建类 */ mpu6050dev.class = class_create(THIS_MODULE, MPU6050_NAME); if (IS_ERR(mpu6050dev.class)) { ret=PTR_ERR(mpu6050dev.class); goto out2; } /* 4、创建设备 */ mpu6050dev.device = device_create(mpu6050dev.class, &amp;client-&gt;dev, mpu6050dev.devid, NULL, MPU6050_NAME); if (IS_ERR(mpu6050dev.device)) { ret = PTR_ERR(mpu6050dev.device); goto out3; } mpu6050dev.private_data = client; /* 设置私有数据 */ mpu6050_reginit(); return 0;//分级进行反注册设备out3: class_destroy(mpu6050dev.class);out2: cdev_del(&amp;mpu6050dev.cdev);out1: unregister_chrdev_region(mpu6050dev.devid,MPU6050_CNT); return ret;}static int mpu6050_remove(struct i2c_client *client){ /* 删除设备 */ cdev_del(&amp;mpu6050dev.cdev); unregister_chrdev_region(mpu6050dev.devid, MPU6050_CNT); /* 注销掉类和设备 */ device_destroy(mpu6050dev.class, mpu6050dev.devid); class_destroy(mpu6050dev.class); return 0;}/* 传统匹配方式ID列表 */static const struct i2c_device_id mpu6050_id[] = { {\"atk,mpu6050\", 0}, {}};/* 设备树匹配列表 */static const struct of_device_id mpu6050_of_match[] = { { .compatible = \"atk,mpu6050\" }, { /* Sentinel */ }};static struct i2c_driver mpu6050_driver = { .probe = mpu6050_probe,//匹配到设备时调用 .remove = mpu6050_remove, .driver = { .owner = THIS_MODULE, .name = \"mpu6050\", .of_match_table = mpu6050_of_match,//设备匹配表 }, .id_table = mpu6050_id,};module_i2c_driver(mpu6050_driver);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"LO\"); 编写测试APP： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include \"stdio.h\"#include \"unistd.h\"#include \"fcntl.h\"int main(int argc, char *argv[]){ int i=10; int fd; signed int buffer[7]; signed int gyro_x_adc, gyro_y_adc, gyro_z_adc; signed int accel_x_adc, accel_y_adc, accel_z_adc; signed int temp_adc; float gyro_x_act, gyro_y_act, gyro_z_act; float accel_x_act, accel_y_act, accel_z_act; float temp_act; int ret = 0; char* filename = \"/dev/mpu6050\"; fd = open(filename, O_RDWR); if(fd &lt; 0) { printf(\"can't open file %s\\r\\n\", filename); return -1; } printf(\"Start Read.\\r\\n\"); while (i--) { ret = read(fd, buffer, sizeof(buffer)); if(ret == 0) { gyro_x_adc = buffer[0]; gyro_y_adc = buffer[1]; gyro_z_adc = buffer[2]; accel_x_adc = buffer[3]; accel_y_adc = buffer[4]; accel_z_adc = buffer[5]; temp_adc = buffer[6]; gyro_x_act = (float)(gyro_x_adc) / 16.4; gyro_y_act = (float)(gyro_y_adc) / 16.4; gyro_z_act = (float)(gyro_z_adc) / 16.4; accel_x_act = (float)(accel_x_adc) / 2048; accel_y_act = (float)(accel_y_adc) / 2048; accel_z_act = (float)(accel_z_adc) / 2048; temp_act = ((float)(temp_adc)/ 340 ) + 36.53; printf(\"\\r\\nADC value:\\r\\n\"); printf(\"gx = %d, gy = %d, gz = %d\\r\\n\", gyro_x_adc, gyro_y_adc, gyro_z_adc); printf(\"ax = %d, ay = %d, az = %d\\r\\n\", accel_x_adc, accel_y_adc, accel_z_adc); printf(\"temp = %d\\r\\n\", temp_adc); printf(\"TRUE value:\"); printf(\"act gx = %.2f°/S, act gy = %.2f°/S, act gz = %.2f°/S\\r\\n\", gyro_x_act, gyro_y_act, gyro_z_act); printf(\"act ax = %.2fg, act ay = %.2fg, act az = %.2fg\\r\\n\", accel_x_act, accel_y_act, accel_z_act); printf(\"act temp = %.2f°C\\r\\n\", temp_act); } usleep(1000000); } close(fd); return 0;}","categories":[{"name":"ZYNQ学习笔记","slug":"ZYNQ学习笔记","permalink":"https://lostacnet.top/categories/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://lostacnet.top/tags/ZYNQ/"},{"name":"Linux","slug":"Linux","permalink":"https://lostacnet.top/tags/Linux/"},{"name":"IIC","slug":"IIC","permalink":"https://lostacnet.top/tags/IIC/"}]},{"title":"ZYNQ学习笔记-MISC设备驱动开发","slug":"ZYNQ学习笔记-MISC设备驱动开发","date":"2024-04-16T08:55:15.000Z","updated":"2024-04-16T11:31:11.037Z","comments":true,"path":"post/41655/","link":"","permalink":"https://lostacnet.top/post/41655/","excerpt":"ZYNQ学习笔记-MISC设备驱动开发MISC杂项设备，是Linux中用于归类ADC、蜂鸣器等不好分类的设备。其特点为共用一个主设备号10，不同设备使用不同设备号，同时会自动创建cdev和创建节点，大大简化字符设备的编写。","text":"ZYNQ学习笔记-MISC设备驱动开发MISC杂项设备，是Linux中用于归类ADC、蜂鸣器等不好分类的设备。其特点为共用一个主设备号10，不同设备使用不同设备号，同时会自动创建cdev和创建节点，大大简化字符设备的编写。 MISC设备简介MISC设备由一个miscdevice结构体描述，该结构体在include/linux/miscdevice.h 中定义： 1234567891011struct miscdevice { int minor; // 次设备号 const char *name; // 设备名字 const struct file_operations *fops; // 设备操作函数集合 struct list_head list; struct device *parent; struct device *this_device; const struct attribute_group **groups; const char *nodename; umode_t mode;}; 这里我们需要关注minor,name,fops变量。minor为从设备号，需要用户自己指定，在miscdevice.h中定义了一些预定的设备号，但是一般我们只需要关注一个值： 1#define MISC_DYNAMIC_MINOR 255 将minor设置为这个值，系统将会将动态分配设备号。 name就是模块名字，注册设备后将会在dev/下生成该名字的文件。 MISC与传统字符驱动的不同普通字符设备进行注册需要进行以下步骤： 12345alloc_chrdev_region(); /* 申请设备号 */cdev_init(); /* 初始化 cdev */cdev_add(); /* 添加 cdev */class_create(); /* 创建类 */device_create(); /* 创建设备 */ 在MISC设备中，直接调用一个函数即可： 1int misc_register(struct miscdevice * misc) 同样的，对于注销，字符设备需要执行以下步骤： 1234cdev_del(); /* 删除 cdev */unregister_chrdev_region(); /* 注销设备号 */device_destroy(); /* 删除设备 */class_destroy(); /* 删除类 */ 在MISC中，只需要一个函数： 1int misc_deregister(struct miscdevice *misc) 可见MISC设备大大简化了字符设备的创建过程，同时还节约了设备号，不用手动创建节点。 一个例子以PIR红外传感器驱动为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;linux/init.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/ioport.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/delay.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/time.h&gt;#include &lt;asm/uaccess.h&gt;/* 驱动名称 */#define DEVICE_NAME \"ccd_pir\"/* gpio 寄存器虚拟地址 */static void __iomem *gpio_add_minor_pir;//static void __iomem *gpio_add_minor_led;/* gpio 寄存器物理基地址 */#define GPIO_BASE_PIR 0x41210000//#define GPIO_BASE_LED 0x41200000unsigned int GPIO_TRI_Offset = 0x4;unsigned int GPIO_DATA_Offset = 0x0;static volatile long pir[1] = {0};void PIR(void);int label_pir, state_pir;/*打开函数，当打开驱动设备节点时，执行此函数,相当于初始化设备文件*/static int pir_open(struct inode *inode,struct file *filp){ gpio_add_minor_pir = (unsigned int)ioremap(GPIO_BASE_PIR, 32); //gpio_add_minor_led = (unsigned int)ioremap(GPIO_BASE_LED, 32); return 0;}/* write 函数实现, 对应到 Linux 系统调用函数的 write 函数 */static ssize_t pir_write(struct file *file_p, const char __user *buf, size_t len, loff_t *loff_t_p){ return 0;}/* release 函数实现, 对应到 Linux 系统调用函数的 close 函数 */static int pir_release(struct inode *inode_p, struct file *file_p){ iounmap((unsigned int *)gpio_add_minor_pir); //iounmap((unsigned int *)gpio_add_minor_led); return 0;}/* 控 制 函 数 ， 相 当 于 给 ult 发 送 控 制 命 令*/static int pir_ioctl(struct file *file, unsigned int cmd, unsigned long arg){/* if(arg == 0) { int state = 0; if(ioread32(gpio_add_minor_pir)) { mdelay(2); if(ioread32(gpio_add_minor_pir)) state =1; } if(state) { iowrite32(4, gpio_add_minor_led); mdelay(1000); iowrite32(0, gpio_add_minor_led); } } else iowrite32(2, gpio_add_minor_led);*/ return 0;}/* 读函数*/static int pir_read(struct file *filp, char __user *buff, size_t count, loff_t *offp){ pir[0] = 0; PIR(); pir[0] = state_pir; printk(KERN_DEBUG\"state_pir: %d\\n\", state_pir); unsigned long err; err = copy_to_user(buff, (const void *)pir, min(sizeof(pir), count)); return err ? -EFAULT : min(sizeof(pir), count);}/*struct file_operations 结构体 , 指 向 对 应 的 驱 动 操 作 函 数*/struct file_operations pir_fops={ .owner = THIS_MODULE, .open = pir_open, .unlocked_ioctl = pir_ioctl, .read = pir_read, .write = pir_write, .release = pir_release,};/*注册模块*/static struct miscdevice misc = {.minor = MISC_DYNAMIC_MINOR,.name = DEVICE_NAME,.fops = &amp;pir_fops,};/*led 驱 动 加 载函数*/static int __init pir_init(void){int ret;ret = misc_register(&amp;misc);//注册设备， 混合设备驱动类，此时不需要手动分配主从设备号printk (DEVICE_NAME\"\\tinitialized\\n\");return ret;}/*led 驱 动 卸 载 函 数*/static void __exit pir_exit(void){misc_deregister(&amp;misc);//卸载设备}void PIR(void){ //label_pir = 0; state_pir = 0; if(ioread32(gpio_add_minor_pir)) { mdelay(2); if(ioread32(gpio_add_minor_pir)) state_pir = 1; }}module_init(pir_init);module_exit(pir_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"ccd\");","categories":[{"name":"ZYNQ学习笔记","slug":"ZYNQ学习笔记","permalink":"https://lostacnet.top/categories/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://lostacnet.top/tags/ZYNQ/"},{"name":"Linux","slug":"Linux","permalink":"https://lostacnet.top/tags/Linux/"}]},{"title":"ZYNQ学习笔记-Win下基于WSL的嵌入式Linux开发环境搭建","slug":"ZYNQ学习笔记-Win下基于WSL的嵌入式Linux开发环境搭建","date":"2024-04-06T14:46:37.000Z","updated":"2024-04-07T10:18:48.487Z","comments":true,"path":"post/4646/","link":"","permalink":"https://lostacnet.top/post/4646/","excerpt":"ZYNQ学习笔记-Win下基于WSL的嵌入式Linux开发环境搭建由于常规在虚拟机上编写嵌入式Linux驱动非常麻烦，而且还没有代码提示，这里给出一种在Win下利用WSL搭建的开发环境。","text":"ZYNQ学习笔记-Win下基于WSL的嵌入式Linux开发环境搭建由于常规在虚拟机上编写嵌入式Linux驱动非常麻烦，而且还没有代码提示，这里给出一种在Win下利用WSL搭建的开发环境。 安装依赖安装WSL2首先需要开启WSL功能，并且需要是WSL2，网上教程很多，这里不再多说。 安装交叉编译链然后需要安装Linux交叉编译器，使用如下命令安装： 1sudo apt install gcc-arm-linux-gnueabihf 安装完成后使用如下命令检验： 1arm-linux-gnueabihf-gcc -v 编译linux内核源码驱动编写需要引用内核中的源码，这里需要下载xilinx-linux内核源码。对于petalinux来说，在build/tmp/work-shared/plnx-zynq7/kernel-source下，复制文件夹到便于使用的位置。 或者直接到github复制，注意版本需要与实际使用的一致： 1git clone --depth 1 git@github.com:Xilinx/linux-xlnx.git 下载完成后，使用ZYNQ的配置编译源码。这里使用的是Xilinx 官方的 ZYNQ ZC702 EVK 开发板的配置，由于我们只需要一些BSP无关的生成文件，因此这里直接用就行。 12make ARCH=arm xilinx_zynq_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12 ARCH指定架构，CROSS_COMPILE指定编译器，-j12指定编译使用12核心。 编译测试这里编译一个LED驱动进行测试。 源码准备新建一个文件夹，创建并编写一个简单的字符程序myled.c，这里不多说了。 然后编写测试app。 源码在最后附录。 Makefile文件这里需要使用make moudule功能，在上面的文件夹中创建一个Makefile文件，填写以下内容： 12345678KDIR := /home/lo/kernel-source #内核源码目录obj-m := led.oall: make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -C $(KDIR) M=`pwd` modulesclean: make -C $(KDIR) M=`pwd` clean 编写完成后直接make进行编译，得到.ko文件。 使用make clean清除编译产生的文件。 app编译即可： 1arm-linux-gnueabihf-gcc ledapp.c -o ledapp 复制文件使用scp命令将两个文件复制到开发板中，并进行测试。 1scp led.ko ledapp root@192.168.2.138:/home/root/test 加载： 1insmod led.ko 由于驱动中有自动创建节点的代码，因此不需要mknod。 进行测试: 12./ledapp /dev/gpioled0 1 //点亮 LED 灯./ledapp /dev/gpioled0 0 //关闭 LED 灯 卸载驱动： 1rmmod led.ko 使用CLion首先注意一点，Clion使用CMake进行工程构建，而linux内核源码使用Make，不能直接使用，因此这里只能查看代码不能编译。 Clion连接WSL打开Clion，点击远程开发中的WSL。 点击连接到主机，选择使用的WSL实例(仅支持WSL2)。根据设置安装好对应WSl上的Clion版本，进行安装，Clion会自动进行，安装完成后选择项目目录打开。 此时应该会提示项目未设置。 创建CMake创建CMakeLists.txt文件，并编写内容： 12345678910111213141516171819cmake_minimum_required(VERSION 3.26)# Clion自动生成project(cliondev C)# Clion自动生成set(CMAKE_C_STANDARD 99)# Clion自动生成，修改为C99set(CMAKE_C_COMPILER \"arm-linux-gnueabihf-gcc\")set(KERNEL_DIR \"/home/lo/kernel-source\") #设置内核目录include_directories(\"${KERNEL_DIR}/include\")include_directories(\"${KERNEL_DIR}/include/uapi\")include_directories(\"${KERNEL_DIR}/include/generated\")include_directories(\"${KERNEL_DIR}/arch/arm/include\")include_directories(\"${KERNEL_DIR}/arch/arm/include/uapi\")include_directories(\"${KERNEL_DIR}/arch/arm/include/generated\")include_directories(\"${KERNEL_DIR}/arch/arm/include/generated/uapi\")add_definitions(-D__KERNEL__)#add_compile_options(\"-includeautoconf.h\")add_executable(cliondev led.c)# Clion自动生成 根据实际修改上面的内核目录。 之后重新加载目录，即可发现代码提示，可以愉快的开始编写了。 编译Clion不能直接编译驱动，使用之前的Makefile脚本进行编译。 打开左下角终端，可以直接打开wsl的终端，在目录下输入make指令即可。 当然也可以使用CLion的脚本运行，在右上角配置中添加make脚本，直接运行即可(还可以将scp命令也添加到脚本中，实现编译后自动复制到开发板)。 使用Vscode主要注意需要在设置文件中添加上面Cmake中写的头文件和定义，这里不多说了。 附录led.c: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#include &lt;linux/types.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/ide.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;asm/mach/map.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_address.h&gt;#include &lt;linux/of_gpio.h&gt;#define GPIOLED_CNT 1#define GPIOLED_NAME \"gpioled0\"/* dtsled 设备结构体 */struct gpioled_dev { dev_t devid; /* 设备号 */ struct cdev cdev; /* cdev */ struct class *class; /* 类 */ struct device *device; /* 设备 */ int major; /* 主设备号 */ int minor; /* 次设备号 */ struct device_node *nd; /* 设备节点 */ int led_gpio; /* LED 所使用的 GPIO 编号 */};static struct gpioled_dev gpioled; /* led 设备 */static int led_open(struct inode *inode, struct file *filp){ filp-&gt;private_data = &amp;gpioled; /* 设置私有数据 */ return 0;}static ssize_t led_read(struct file *filp, char __user *buf,size_t cnt, loff_t *offt){ return 0;}static ssize_t led_write(struct file *filp, const char __user *buf,size_t cnt, loff_t *offt){ int ret; char kern_buf[1]; struct gpioled_dev* pgpioled=(struct gpioled_dev*)filp-&gt;private_data; ret = copy_from_user(kern_buf, buf, cnt); // 得到应用层传递过来的数据 if(0 &gt; ret) { printk(KERN_ERR \"kernel write failed!\\r\\n\"); return -EFAULT; } if (0 == kern_buf[0]) gpio_set_value(pgpioled-&gt;led_gpio, 0); // 如果传递过来的数据是 0 则关闭 led else if (1 == kern_buf[0]) gpio_set_value(pgpioled-&gt;led_gpio, 1); // 如果传递过来的数据是 1 则点亮 led return 0;}static int led_release(struct inode *inode, struct file *filp){return 0;}/* 设备操作函数 */static struct file_operations gpioled_fops = {.owner = THIS_MODULE,.open = led_open,.read = led_read,.write = led_write,.release = led_release,};static int __init led_init(void){ const char *str; int ret; /* 1.获取 led 设备节点 */ gpioled.nd = of_find_node_by_path(\"/leds/led0\"); if(NULL == gpioled.nd) { printk(KERN_ERR \"gpioled: Failed to get /led node\\n\"); return -EINVAL; } /* 2.读取 status 属性 */ ret = of_property_read_string(gpioled.nd, \"status\", &amp;str); if(!ret) { if (strcmp(str, \"okay\")) return -EINVAL; } /* 2、获取 label 属性值并进行匹配 */ ret = of_property_read_string(gpioled.nd, \"label\", &amp;str); if(0 &gt; ret) { printk(KERN_ERR \"gpioled: Failed to get compatible property\\n\"); return ret; } if (strcmp(str, \"ps_led\")) { printk(KERN_ERR \"gpioled: Compatible match failed\\n\"); return -EINVAL; } printk(KERN_INFO \"gpioled: device matching successful!\\r\\n\"); /* 4.获取设备树中的 led-gpio 属性，得到 LED 所使用的 GPIO 编号 */ gpioled.led_gpio = of_get_named_gpio(gpioled.nd, \"led-gpio\", 0); if(!gpio_is_valid(gpioled.led_gpio)) { printk(KERN_ERR \"gpioled: Failed to get led-gpio\\n\"); return -EINVAL; } printk(KERN_INFO \"gpioled: led-gpio num = %d\\r\\n\", gpioled.led_gpio); /* 5.向 gpio 子系统申请使用 GPIO */ ret = gpio_request(gpioled.led_gpio, \"LED-GPIO\"); if (ret) { printk(KERN_ERR \"gpioled: Failed to request led-gpio\\n\"); return ret; } /* 6.将 led gpio 管脚设置为输出模式 */ gpio_direction_output(gpioled.led_gpio, 0); /* 7.初始化 LED 的默认状态 */ ret = of_property_read_string(gpioled.nd, \"default-state\", &amp;str); if(!ret) { if (!strcmp(str, \"on\")) gpio_set_value(gpioled.led_gpio, 1); else gpio_set_value(gpioled.led_gpio, 0); } else gpio_set_value(gpioled.led_gpio, 0); /* 8.注册字符设备驱动 */ /* 创建设备号 */ if (gpioled.major) { gpioled.devid = MKDEV(gpioled.major, 0); ret = register_chrdev_region(gpioled.devid, GPIOLED_CNT, GPIOLED_NAME); if (ret) goto out1; } else { ret = alloc_chrdev_region(&amp;gpioled.devid, 0, GPIOLED_CNT, GPIOLED_NAME); if (ret) goto out1; gpioled.major = MAJOR(gpioled.devid); gpioled.minor = MINOR(gpioled.devid); } printk(\"gpioled: major=%d,minor=%d\\r\\n\",gpioled.major, gpioled.minor); /* 初始化 cdev */ gpioled.cdev.owner = THIS_MODULE; cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops); /* 添加一个 cdev */ ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_CNT); if (ret) goto out2; /* 创建类 */ gpioled.class = class_create(THIS_MODULE, GPIOLED_NAME); if (IS_ERR(gpioled.class)) { ret = PTR_ERR(gpioled.class); goto out3; } /* 创建设备 */ gpioled.device = device_create(gpioled.class, NULL, gpioled.devid, NULL, GPIOLED_NAME); if (IS_ERR(gpioled.device)) { ret = PTR_ERR(gpioled.device); goto out4; } return 0;out4: class_destroy(gpioled.class);out3: cdev_del(&amp;gpioled.cdev);out2: unregister_chrdev_region(gpioled.devid, GPIOLED_CNT);out1: gpio_free(gpioled.led_gpio);return ret;}static void __exit led_exit(void){ /* 注销设备 */ device_destroy(gpioled.class, gpioled.devid); /* 注销类 */ class_destroy(gpioled.class); /* 删除 cdev */ cdev_del(&amp;gpioled.cdev); /* 注销设备号 */ unregister_chrdev_region(gpioled.devid, GPIOLED_CNT); /* 释放 GPIO */ gpio_free(gpioled.led_gpio);}/* 驱动模块入口和出口函数注册 */module_init(led_init);module_exit(led_exit);MODULE_AUTHOR(\"LO\");MODULE_DESCRIPTION(\"LO ZYNQ GPIO LED Driver\");MODULE_LICENSE(\"GPL\"); ledapp.c: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/** @description : main 主程序* @param - argc : argv 数组元素个数* @param - argv : 具体参数* @return : 0 成功;其他 失败*/int main(int argc, char *argv[]){int fd, ret;unsigned char buf[1];if(3 != argc) {printf(\"Usage:\\n\"\"\\t./ledApp /dev/led 1 @ close LED\\n\"\"\\t./ledApp /dev/led 0 @ open LED\\n\");return -1;}/* 打开设备 */fd = open(argv[1], O_RDWR);if(0 &gt; fd) {printf(\"file %s open failed!\\r\\n\", argv[1]);return -1;}/* 将字符串转换为 int 型数据 */buf[0] = atoi(argv[2]);/* 向驱动写入数据 */ret = write(fd, buf, sizeof(buf));if(0 &gt; ret){printf(\"LED Control Failed!\\r\\n\");close(fd);return -1;}/* 关闭设备 */close(fd);return 0;} 本次使用的设备树： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/include/ \"system-conf.dtsi\"#include &lt;dt-bindings/gpio/gpio.h&gt;#include \"dt-bindings/gpio/gpio.h\"#include \"dt-bindings/input/linux-event-codes.h\"/{ model = \"BX71 Development Board\"; leds { compatible = \"gpio-leds\"; led0 { label = \"ps_led\"; led-gpio = &lt;&amp;gpio0 0 GPIO_ACTIVE_HIGH&gt;; default-state = \"off\"; }; led1 { label = \"pl_led0\"; led-gpio = &lt;&amp;gpio0 54 GPIO_ACTIVE_HIGH&gt;; default-state = \"off\"; }; }; keys { compatible = \"gpio-keys\"; autorepeat; key0 { label = \"ps_key\"; gpios = &lt;&amp;gpio0 47 GPIO_ACTIVE_LOW&gt;; linux,code = &lt;KEY_UP&gt;; debounce-interval = &lt;15&gt;; }; key1 { label = \"pl_key\"; gpios = &lt;&amp;gpio0 55 GPIO_ACTIVE_LOW&gt;; linux,code = &lt;KEY_DOWN&gt;; debounce-interval = &lt;15&gt;; }; }; usb_phy0: phy0@e0002000 { compatible = \"ulpi-phy\"; #phy-cells = &lt;0&gt;; reg = &lt;0xe0002000 0x1000&gt;; view-port = &lt;0x0170&gt;; drv-vbus; };};&amp;usb0 { dr_mode = \"otg\"; usb-phy = &lt;&amp;usb_phy0&gt;;};&amp;gem0 { local-mac-address = [00 0a 35 00 11 55];};&amp;phy0 { reg = &lt;0x5&gt;;};","categories":[{"name":"ZYNQ学习笔记","slug":"ZYNQ学习笔记","permalink":"https://lostacnet.top/categories/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://lostacnet.top/tags/ZYNQ/"},{"name":"Linux","slug":"Linux","permalink":"https://lostacnet.top/tags/Linux/"},{"name":"WSL","slug":"WSL","permalink":"https://lostacnet.top/tags/WSL/"}]},{"title":"Latex环境的搭建","slug":"Latex环境的搭建","date":"2024-03-26T15:43:56.000Z","updated":"2024-08-10T13:07:44.629Z","comments":true,"path":"post/32643/","link":"","permalink":"https://lostacnet.top/post/32643/","excerpt":"Latex环境的搭建由于最近需要写简历，用到Latex，因此这里给出环境的搭建方法。","text":"Latex环境的搭建由于最近需要写简历，用到Latex，因此这里给出环境的搭建方法。 一些概念这里引用程序编译中的一些概念，描述Latex中涉及到的一些名词，不是很准确，以了解为主。 首先，我们将.tex文件视为程序源码，最终会被编译成.pdf文件。 在这个过程中，发行版(Tex Live、MacTex、W32Tex等)，就像gcc工具链在不同平台有不同名字(MGWing等)，有点像不同公司推出的各自的工具链，都包含了一系列编译器、格式支持、宏包、GUI界面等。 而引擎(XeTex、pdfTex、LuaTex)等，是具体的编译器，一些编译器会支持一些特别的语法特性。 原始的Tex语言晦涩难懂，而格式将Tex语言打包，组成其他易于使用的语句。有点像语法糖，或者有种汇编(Tex)与C(Latex、ConText、PlainTex)的感觉。 宏包(LaTeX中叫做packages，在ConTeXt中叫做modules)，不像格式一样封的那么全面，只是为了完成一些特定的功能，有些像库文件。 基于以上，想要搭建Latex环境，就要有这几样：引擎、编辑器、用到的库文件。对于这些。下一个发行版就全部解决了，当然也可以使用自己的。比如觉得自带的编辑器太难用，使用vscode代替之类。 这里使用Tex Live + Tex Studio组合。 安装Tex LiveCTex已经是时代的眼泪了，现在还是使用最新的Tex Live吧。包含了pdfTex、XeLaTex等，功能完备，但是其自带的前端不好使，这里就不安装前端。 首先下载安装包，下载地址。选择texlive2024.iso 下载完成后点击install-tl-windows.bat进行安装。 这里取消勾选安装前端，不安装自带的编辑器。 安装完成后，在命令行输入命令检查： tex -v, latex -v, xelatex -v, pdflatex - v 安装Texstudio有了编译器，现在到了选择合适的编辑器。下载地址 安装完成后打开。 在设置中设置-&gt;构建中，若写中文设置默认编译器为XeLaTeX，写英文就用PdfLaTex。 之后可以设置显示所有行号。 Latex基础&lt;待续&gt;","categories":[{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://lostacnet.top/tags/Latex/"}]},{"title":"ESP-IDF学习笔记-RMT的使用","slug":"ESP-IDF学习笔记-RMT的使用","date":"2024-03-22T17:04:30.000Z","updated":"2024-08-08T04:25:16.897Z","comments":true,"path":"post/32304/","link":"","permalink":"https://lostacnet.top/post/32304/","excerpt":"ESP-IDF学习笔记-RMT的使用作为物联网芯片，ESP32C3包含一个RMT外设，可以用来产生一些单线协议信号。可以实现NEC协议(红外遥控器使用)，或者驱动WS2812灯珠。这边以WS2812的协议为例，学习使用该外设。","text":"ESP-IDF学习笔记-RMT的使用作为物联网芯片，ESP32C3包含一个RMT外设，可以用来产生一些单线协议信号。可以实现NEC协议(红外遥控器使用)，或者驱动WS2812灯珠。这边以WS2812的协议为例，学习使用该外设。 官方文档 相关声明在driver/rmt_tx.h或者driver/rmt_rx.h下。 外设简介有一些通信协议使用了单线协议，利用高低电平的不同时间表示0和1，这样可以节省信道数量，但是这对于软件来说很不好实现。比如常用的红外协议NEC： 需要控制高电平时间和低电平时间来分别传输0和1，这对软件来说比较难控制，因此ESP32包含了一个专用外设RMT用来实现这类时序。 ESP32C3有一个RMT外设，包含多个通道，每个通道可单独设置为发送和接收。RMT使用RMT symbol配置高低电平的时间，在IDF中数据类型为rmt_symbol_word_t。 用15bit设定持续多长的RMT ticks，一个bit(L)设定是高电平还是低电平。翻译过来就是一个这样的信息：{(11,high,7,low),(5,high,5l,ow)}。 发送通道安装TX通道首先我们需要安装通道。一个通道由rmt_channel_handle_t句柄进行管理，使用rmt_tx_channel_config_t进行设置，使用rmt_new_tx_channel()进行创建。 rmt_tx_channel_config_t定义如下： 12345678910111213typedef struct { gpio_num_t gpio_num; rmt_clock_source_t clk_src; uint32_t resolution_hz; size_t mem_block_symbols; size_t trans_queue_depth; struct { uint32_t invert_out: 1; uint32_t with_dma: 1; uint32_t io_loop_back: 1; uint32_t io_od_mode: 1; } flags; } rmt_tx_channel_config_t; gpio_num:设置输出IO引脚。 clk_src:选择时钟源，一般选择RMT_CLK_SRC_DEFAULT即APB时钟。 resolution_hz:设置RMT tick的频率。 mem_block_symbols:必须为偶数。普通模式下设置该通道使用的RMT内存块数量，至少为 48(ESP32C3没有RMTDMA，因此不考虑DMA模式)-越大灯珠闪烁越小 trans_queue_depth:内部事务队列深度。队列越深，在待处理队列中可以准备的事务越多。 invert_out:设置输出是否反相(电平相反) with_dma:是否开启dma，C3没有，因此不用管。 io_loop_back:启用通道所分配的 GPIO 上的输入和输出功能，将发送通道和接收通道绑定到同一个 GPIO 上，从而实现回环功能。配合io_od_mode可以实现一些单线协议。 io_od_mode:配合io_loop_back，将io口设置为开漏模式，这样可以监控输入。 使用例： 1234567891011rmt_channel_handle_t led_chan = NULL;rmt_tx_channel_config_t tx_chan_config = { .clk_src = RMT_CLK_SRC_DEFAULT, // select source clock .gpio_num = 0, .mem_block_symbols = 64, // increase the block size can make the LED less flickering .resolution_hz = 10000000, .trans_queue_depth = 4, // set the number of transactions that can be pending in the background .flags.invert_out = false, .flags.with_dma = false, };ESP_ERROR_CHECK(rmt_new_tx_channel(&amp;tx_chan_config, &amp;led_chan)); 如果需要卸载，使用rmt_del_channel() 函数释放资源。 载波调制RMT发生器可以将信号调制到高频： 相关配置结构体为rmt_carrier_config_t 12345678typedef struct { uint32_t frequency_hz; /*载波频率 */ float duty_cycle; /*载波占空比 0~1 */ struct { uint32_t polarity_active_low: 1; /*极性选择，决定载波调制到高电平还是低电平，默认是高电平 */ uint32_t always_on: 1; /*设置空闲时是否发送载波 */ } flags; } rmt_carrier_config_t; 使用rmt_apply_carrier()应用到具体通道。 1234567rmt_carrier_config_t tx_carrier_cfg = { .duty_cycle = 0.33, // 载波占空比为 33% .frequency_hz = 38000, // 38 KHz .flags.polarity_active_low = false, // 载波应调制到高电平};// 将载波调制到 TX 通道ESP_ERROR_CHECK(rmt_apply_carrier(tx_chan, &amp;tx_carrier_cfg)); RMT编码器对于RMT外设来说，它只会将内存块中的RMT Symbol按顺序发出，并没有解析byte数据的能力，因此IDF在驱动层面添加了一个编码器事务机制，用于在传输中将数据编码为RMT Symbol。由于RMT 内存块无法一次性容纳所有数据，在单个事务中，会多次调用编码函数。同时编码器函数运行在中断中，因此建议将其放入IRAM空间运行。 编码器的具体编写方式可以参考官方文档，给出了NEC协议的编码器。 这里给出官方例程中的LED编码器实现: led_strip_encoder.h 12345678910111213141516171819202122232425262728293031323334353637/* * SPDX-FileCopyrightText: 2021-2022 Espressif Systems (Shanghai) CO LTD * * SPDX-License-Identifier: Apache-2.0 */#pragma once#include &lt;stdint.h&gt;#include \"driver/rmt_encoder.h\"#ifdef __cplusplusextern \"C\" {#endif/** * @brief Type of led strip encoder configuration */typedef struct { uint32_t resolution; /*!&lt; Encoder resolution, in Hz */} led_strip_encoder_config_t;/** * @brief Create RMT encoder for encoding LED strip pixels into RMT symbols * * @param[in] config Encoder configuration * @param[out] ret_encoder Returned encoder handle * @return * - ESP_ERR_INVALID_ARG for any invalid arguments * - ESP_ERR_NO_MEM out of memory when creating led strip encoder * - ESP_OK if creating encoder successfully */esp_err_t rmt_new_led_strip_encoder(const led_strip_encoder_config_t *config, rmt_encoder_handle_t *ret_encoder);#ifdef __cplusplus}#endif led_strip_encoder.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/* * SPDX-FileCopyrightText: 2021-2022 Espressif Systems (Shanghai) CO LTD * * SPDX-License-Identifier: Apache-2.0 */#include \"esp_check.h\"#include \"led_strip_encoder.h\"static const char *TAG = \"led_encoder\";typedef struct { rmt_encoder_t base; rmt_encoder_t *bytes_encoder; rmt_encoder_t *copy_encoder; int state; rmt_symbol_word_t reset_code;} rmt_led_strip_encoder_t;static size_t rmt_encode_led_strip(rmt_encoder_t *encoder, rmt_channel_handle_t channel, const void *primary_data, size_t data_size, rmt_encode_state_t *ret_state){ rmt_led_strip_encoder_t *led_encoder = __containerof(encoder, rmt_led_strip_encoder_t, base); rmt_encoder_handle_t bytes_encoder = led_encoder-&gt;bytes_encoder; rmt_encoder_handle_t copy_encoder = led_encoder-&gt;copy_encoder; rmt_encode_state_t session_state = RMT_ENCODING_RESET; rmt_encode_state_t state = RMT_ENCODING_RESET; size_t encoded_symbols = 0; switch (led_encoder-&gt;state) { case 0: // send RGB data encoded_symbols += bytes_encoder-&gt;encode(bytes_encoder, channel, primary_data, data_size, &amp;session_state); if (session_state &amp; RMT_ENCODING_COMPLETE) { led_encoder-&gt;state = 1; // switch to next state when current encoding session finished } if (session_state &amp; RMT_ENCODING_MEM_FULL) { state |= RMT_ENCODING_MEM_FULL; goto out; // yield if there's no free space for encoding artifacts } // fall-through case 1: // send reset code encoded_symbols += copy_encoder-&gt;encode(copy_encoder, channel, &amp;led_encoder-&gt;reset_code, sizeof(led_encoder-&gt;reset_code), &amp;session_state); if (session_state &amp; RMT_ENCODING_COMPLETE) { led_encoder-&gt;state = RMT_ENCODING_RESET; // back to the initial encoding session state |= RMT_ENCODING_COMPLETE; } if (session_state &amp; RMT_ENCODING_MEM_FULL) { state |= RMT_ENCODING_MEM_FULL; goto out; // yield if there's no free space for encoding artifacts } }out: *ret_state = state; return encoded_symbols;}static esp_err_t rmt_del_led_strip_encoder(rmt_encoder_t *encoder){ rmt_led_strip_encoder_t *led_encoder = __containerof(encoder, rmt_led_strip_encoder_t, base); rmt_del_encoder(led_encoder-&gt;bytes_encoder); rmt_del_encoder(led_encoder-&gt;copy_encoder); free(led_encoder); return ESP_OK;}static esp_err_t rmt_led_strip_encoder_reset(rmt_encoder_t *encoder){ rmt_led_strip_encoder_t *led_encoder = __containerof(encoder, rmt_led_strip_encoder_t, base); rmt_encoder_reset(led_encoder-&gt;bytes_encoder); rmt_encoder_reset(led_encoder-&gt;copy_encoder); led_encoder-&gt;state = RMT_ENCODING_RESET; return ESP_OK;}esp_err_t rmt_new_led_strip_encoder(const led_strip_encoder_config_t *config, rmt_encoder_handle_t *ret_encoder){ esp_err_t ret = ESP_OK; rmt_led_strip_encoder_t *led_encoder = NULL; ESP_GOTO_ON_FALSE(config &amp;&amp; ret_encoder, ESP_ERR_INVALID_ARG, err, TAG, \"invalid argument\"); led_encoder = calloc(1, sizeof(rmt_led_strip_encoder_t)); ESP_GOTO_ON_FALSE(led_encoder, ESP_ERR_NO_MEM, err, TAG, \"no mem for led strip encoder\"); led_encoder-&gt;base.encode = rmt_encode_led_strip; led_encoder-&gt;base.del = rmt_del_led_strip_encoder; led_encoder-&gt;base.reset = rmt_led_strip_encoder_reset; // different led strip might have its own timing requirements, following parameter is for WS2812 rmt_bytes_encoder_config_t bytes_encoder_config = { .bit0 = { .level0 = 1, .duration0 = 0.3 * config-&gt;resolution / 1000000, // T0H=0.3us .level1 = 0, .duration1 = 0.9 * config-&gt;resolution / 1000000, // T0L=0.9us }, .bit1 = { .level0 = 1, .duration0 = 0.9 * config-&gt;resolution / 1000000, // T1H=0.9us .level1 = 0, .duration1 = 0.3 * config-&gt;resolution / 1000000, // T1L=0.3us }, .flags.msb_first = 1 // WS2812 transfer bit order: G7...G0R7...R0B7...B0 }; ESP_GOTO_ON_ERROR(rmt_new_bytes_encoder(&amp;bytes_encoder_config, &amp;led_encoder-&gt;bytes_encoder), err, TAG, \"create bytes encoder failed\"); rmt_copy_encoder_config_t copy_encoder_config = {}; ESP_GOTO_ON_ERROR(rmt_new_copy_encoder(&amp;copy_encoder_config, &amp;led_encoder-&gt;copy_encoder), err, TAG, \"create copy encoder failed\"); uint32_t reset_ticks = config-&gt;resolution / 1000000 * 50 / 2; // reset code duration defaults to 50us led_encoder-&gt;reset_code = (rmt_symbol_word_t) { .level0 = 0, .duration0 = reset_ticks, .level1 = 0, .duration1 = reset_ticks, }; *ret_encoder = &amp;led_encoder-&gt;base; return ESP_OK;err: if (led_encoder) { if (led_encoder-&gt;bytes_encoder) { rmt_del_encoder(led_encoder-&gt;bytes_encoder); } if (led_encoder-&gt;copy_encoder) { rmt_del_encoder(led_encoder-&gt;copy_encoder); } free(led_encoder); } return ret;} 使用方法: 123456ESP_LOGI(TAG, \"Install led strip encoder\");rmt_encoder_handle_t led_encoder = NULL;led_strip_encoder_config_t encoder_config = { .resolution = RMT_LED_STRIP_RESOLUTION_HZ,};ESP_ERROR_CHECK(rmt_new_led_strip_encoder(&amp;encoder_config, &amp;led_encoder)); 启用通道在正式发送数据前，使用rmt_enable()启动外设。启用 TX 通道会启用特定中断，并使硬件准备发送事务。 相反，rmt_disable() 会禁用中断并清除队列中的中断，同时禁用发射器和接收器。 发送数据rmt_transmit()函数用于启动发送事务： 1esp_err_t rmt_transmit(rmt_channel_handle_t channel, rmt_encoder_t *encoder, const void *payload, size_t payload_bytes, const rmt_transmit_config_t *config); channel:发送通道的句柄 encoder:之前创建好的编码器 payload:要发送的数据。 payload_bytes:要发送的数据字节数。 config:发送设置 123456typedef struct { int loop_count; /*设置发送循环次数，设置-1为无限循环*/ struct { uint32_t eot_level : 1; /*设置发送结束后电平 */ } flags; } rmt_transmit_config_t; 使用该函数后会创建一个事务，并将其发送到作业队伍中，并在中断中调度。因此这个是非阻塞的发送，可以使用rmt_tx_wait_all_done()等待发送结束。 1ESP_ERROR_CHECK(rmt_tx_wait_all_done(led_chan, portMAX_DELAY)); 使用例子： 12345rmt_transmit_config_t tx_config = { .loop_count = 0, // no transfer loop };ESP_ERROR_CHECK(rmt_transmit(led_chan, led_encoder, led_strip_pixels, sizeof(led_strip_pixels), &amp;tx_config));ESP_ERROR_CHECK(rmt_tx_wait_all_done(led_chan, portMAX_DELAY)); 同步发送(待续) 接收通道(待续) IRAM安全默认情况下，禁用 cache 时，写入/擦除主 flash 等原因将导致 RMT 中断延迟，事件回调函数也将延迟执行。在实时应用程序中，应避免此类情况。此外，当 RMT 事务依赖 交替 中断连续编码或复制 RMT 符号时，上述中断延迟将导致不可预测的结果。 因此，可以启用 Kconfig 选项 CONFIG_RMT_ISR_IRAM_SAFE，该选项： 支持在禁用 cache 时启用所需中断 支持将 ISR 使用的所有函数存放在 IRAM 中 支持将驱动程序实例存放在 DRAM 中，以防其意外映射到 PSRAM 中 启用该选项可以保证 cache 禁用时的中断运行，但会相应增加 IRAM 占用。 另外一个 Kconfig 选项 CONFIG_RMT_RECV_FUNC_IN_IRAM 可以将 rmt_receive() 函数放进内部的 IRAM 中，从而当 flash cache 被关闭的时候，这个函数也能够被使用。 线程安全rmt_new_tx_channel()、rmt_new_rx_channel() 和 rmt_new_sync_manager() 线程安全，其他以 rmt_channel_handle_t 和 rmt_sync_manager_handle_t 作为第一个位置参数的函数均非线程安全，调用时应注意互斥锁保护。 rmt_receive()可以在中断中使用。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"},{"name":"RMT","slug":"RMT","permalink":"https://lostacnet.top/tags/RMT/"}]},{"title":"ZYNQ学习笔记-设备树","slug":"ZYNQ学习笔记-设备树","date":"2024-03-19T13:02:39.000Z","updated":"2024-03-19T16:37:41.538Z","comments":true,"path":"post/31902/","link":"","permalink":"https://lostacnet.top/post/31902/","excerpt":"ZYNQ学习笔记-设备树设备树是描述Linux开发板硬件的一种数据结构，是为了将硬件信息与驱动剥离而防止内核代码中出现大量板级外设描述代码。防止板级设备发送变动（比如LED引脚更换）就需要重新写驱动代码。使用设备树后，驱动代码可以通过函数获取运行驱动所需的信息(如寄存器地址)。","text":"ZYNQ学习笔记-设备树设备树是描述Linux开发板硬件的一种数据结构，是为了将硬件信息与驱动剥离而防止内核代码中出现大量板级外设描述代码。防止板级设备发送变动（比如LED引脚更换）就需要重新写驱动代码。使用设备树后，驱动代码可以通过函数获取运行驱动所需的信息(如寄存器地址)。 设备树文件 dts 设备树的源文件后缀就是.dts，每一款硬件平台都可以单独写一份dts文件。 dtsi 类似于c语言的头文件，可以在dts中include一个dtsi文件。 dtc 设备树的编译器。 dtb 设备树编译后的二进制数据。 设备树语法设备树的结构设备树顾名思义就是一颗树，每个设备就是一个节点，一棵树有一个根，根节点(root node)。除了根节点，每个节点都有一个父节点(parent node)，每个节点包含了一些键值对描述该节点。 一种设备树的示意结构： 12345678910111213141516/{ // 根节点 node1{ // node1 节点 property1=value1; // node1 节点的属性 property1 property2=value2; // node1 节点的属性 property2 ... }; node2{ // node2 节点 property3=value3; // node2 节点的属性 property3 ... node3{ // node2 的子节点 node3 property4=value4; // node3 节点的属性 property4 ... }; }; }; 比如node2可以是IIC1总线设备，然后node3可以是一个EEPROM。 设备树节点与属性设备树中一个节点可以这样表示： 1234[label:]node-name[@unit-address] {[properties definitions][child nodes]}; “[]”表示内容可选。 label用于在其他节点通过&amp;label格式引用。 node-name是节点名称。如uart1 unit-address是设备的地址，如果没有可以不要(如cpu@0)。 child nodes即子节点。 设备树的属性有多种类型： 字符串 1compatible=\"arm,cortex-a9\"; 字符串使用双引号括起来，例如上面的这个 compatible 属性的值是” arm,cortex-a9”字符串。 32位无符号整形 12clock-latency = &lt;1000&gt;;reg = &lt;0x00000000 0x00500000&gt;; 32 位无符号整形数据使用尖括号括起来，例如属性 clock-latency 的值是一个 32 位无符号整形数据 1000，而 reg 属性有两个数据，使用空格隔开，那么这个就可以认为是一个数组 。 二进制数据 1local-mac-address = [00 0a 35 00 1e 53]; 二进制数据使用方括号括起来 。 字符串数组 1compatible = \"n25q512a\",\"micron,m25p80\"; 属性值也可以使用字符串列表，字符串之间使用逗号分割。 混合值 1mixed-property = \"a string\", [0x01 0x23 0x45 0x67], &lt;0x12345678&gt;; 节点引用 1clocks = &lt;&amp;clkc3&gt;; 使用尖括号。 注释与宏定义注释的方法和 C 语言当中是一样的，可以使用” // ”进行单行注释，也可以使用” /* */ ” 进行多行注释 。 设备树中可以使用”#include” 包含 dtsi、 dts 以及 C 语言的头文件 ，用以使用宏定义。 标准属性节点内容由一堆属性组成，不同设备属性不同，但是有一些标准属性，很多驱动都会使用。 compatible属性 一般该字符串使用” &lt;制造商&gt;,&lt;型号&gt;” 这样的形式进行命名 ： 1compatible = \"xlnx,xuartps\", \"cdns,uart-r1p8\"; 例子当中的 xlnx 和 cdns 就表示制造商，而后面的 xuartps 和 uart-r1p8 就表示具体设备的型号。该设备首先使用第一个兼容值（ xlnx,xuartps）在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值（ cdns,uart-r1p8）查找，直到找到或者查找完整个 Linux 内核也没有找到对应的驱动。 驱动中有一个表格，其中储存了一些compatible值，一旦匹配上就可以使用这个驱动。 根节点的 compatible 属性可以知道我们所使用的处理器型号， Linux 内核会通过根节点的 compoatible 属性查看是否支持此该处理器， 因为内核在启动初期会进行校验，必须要支持才会启动 Linux 内核。 model属性 一个字符串描述信息， 它指定制造商的设备型号， model 属性一般定义在根节点下，一般就是对板子的描述信息，没啥实质性的作用， 内核在解析设备树的时候会把这个属性对应的字符串信息打印出来。 status属性 status 标识了设备的状态，使用 status 可以去禁止设备或者启用设备，看下设备树规范中的 status 可选值： key 描述 “okay” 表明设备是可操作的。 启动设备 “disable” 表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备插入以后。至于 disabled 的具体含义还要看设备的绑定文档。 “fail” 表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得可操作。 “fail-sss” 含义和“ fail”相同，后面的 sss 部分是检测到的错误内容。 如果没有添加，则属性的默认值为okey。 #address-cells和size-cells 这两个属性的值都是无符号 32 位整形， #address-cells 和#size-cells 这两个属性可以用在任何拥有子节点的设备节点中，用于描述子节点的地址信息。#address-cells，用来描述子节点”reg”属性的address字段占用字长；#size-cells，用来描述子节点”reg”属性的length字段占用字长； 一字为32bit。 reg属性 reg 属性的值一般是(address， length)对。 reg 属性一般用于描述设备地址空间资源信息，一般都是描述某个外设的寄存器地址范围信息、 flash 设备的分区信息等。 1reg = &lt;address1 length1 address2 length2 address3 length3……&gt; ranges属性 ranges 是地址转换表，其中的每个项目是一个子地址、父地址以及在子地址空间的大小的映射。 ranges 属性值可以为空或者按照(child-bus-address,parent-bus-address,length)格式编写的数字矩阵。 child-bus-address ： 子 总 线 地 址 空 间 的 物 理 地 址 ， 由 ranges 属 性 所 在 节 点 的#address-cells 属性确定此物理地址占用的字长。 parent-bus-address： 父总线地址空间的物理地址， 由 ranges 属性所在节点的父节点的#address-cells 属性确定此物理地址所占用的字长。length： 子地址空间的长度， 由 ranges 属性所在节点的#address-cells 属性确定此地址长度所占用的字长。 如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换 。 比如: 123456789101112131415soc { compatible = \"simple-bus\"; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; ranges = &lt;0x0 0xe0000000 0x00100000&gt;;serial { device_type = \"serial\"; compatible = \"ns16550\"; reg = &lt;0x4600 0x100&gt;; clock-frequency = &lt;0&gt;; interrupts = &lt;0xA 0x8&gt;; interrupt-parent = &lt;&amp;ipic&gt;; }; }; ranges 属性，值为&lt;0x0 0xe0000000 0x00100000&gt;，此属性值指定了一个 1024KB(0x00100000)的地址范围，子地址空间的物理起始地址为 0x0，父地址空间的物理起始地址为 0xe0000000。 serial 是串口设备节点， reg 属性定义了 serial 设备寄存器的起始地址为 0x4600，寄存器长度为 0x100。经过地址转换， serial 设备可以从 0xe0004600 开始进行读写操作，0xe0004600=0x4600+0xe0000000。 device-type属性 device_type 属性值为字符串， 表示节点的类型；此属性在设备树当中用的比较少，一般用于 cpu 节点或者 memory 节点。 节点追加或修改内容假设有一个i2c控制器，现状需要在其下添加一个OLED，如果直接在i2c的节点下追加会很不方便(假设过一段时间又要加一个)，此时可以通过以下格式在其他位置添加： 123&amp;i2c0 {/* 要追加或修改的内容 */}; 第 1 行， &amp;i2c0 表示要引用到 i2c0 这个 label 所对应的节点，也就是 zynq-7000.dtsi 文件中的“ i2c0: i2c@e0004000”。第 2 行，花括号内就是要向 i2c0 这个节点添加的内容，包括修改某些属性的值。 如果追加的属性值已经，会修改原属性值。 例子： 1234567&amp;i2c0 { 24c64@50{ compatible = \"atmel,24c64\";reg = &lt;0x50&gt;;pagesize = &lt;32&gt;; }}; 特殊的节点 aliases节点 123456789aliases {ethernet0 = &amp;gem0;i2c0 = &amp;i2c_2;i2c1 = &amp;i2c0;i2c2 = &amp;i2c1;serial0 = &amp;uart0;serial1 = &amp;uart1;spi0 = &amp;qspi;}; 用来取别名，这样在内核中就可以使用ethernet0来访问gem0节点。 chosen节点 1234chosen {bootargs = \"console=ttyPS0,115200 earlyprintk root=/dev/mmcblk0p2 rw rootwait\";stdout-path = \"serial0:115200n8\"; }; 属性 stdout-path = “ serial0:115200n8” ，表示标准输出设备使用串口 serial0，在 system-top.dts 文件当中， serial0 其实是一个别名，指向的就是 uart0；“ 115200”则表示串口的波特率为 115200，“ n”表示无校验位，“ 8”则表示有 8 位数据位 。 bootargs为传递给内核的变量。U-boot的传递的变量会添加在这后面。 memory节点 1234memory { device_type = \"memory\"; reg = &lt;0x0 0x20000000&gt;; }; 描述内存大小和起始位置。 Linux中的设备树Linux 内 核 启 动 的 时 候 会 解 析 设 备 树 中 各 个 节 点 的 信 息 ， 并 且 在 根 文 件 系 统 的/proc/device-tree 目录下根据节点名字创建不同文件夹 。 关于如何添加设备，在内核源码的/Documentation/devicetree/bindings 中有相应文档。比如如何添加一个IIC节点：Documentation/devicetree/bindings/i2c/i2c-cadence.txt （ 文 件 的 名 字 一 般 都 是 以i2c-xxx.txt 命名的， xxx 一般是制造商）。 驱动如何使用设备树Linux内核为驱动提供了一些函数用来获取设备的属性信息，比如拿到reg地址进行初始化。这一系列函数都有一个of_前缀，因此被称为OF函数。 使用时需要引用include/linux/of.h文件。 查找节点的OF函数一个节点在c中描述的结构体如下： 123456789101112131415161718192021struct device_node {const char *name; /* 节点名字 */const char *type; /* 设备类型 */phandle phandle;const char *full_name; /* 节点全名 */struct fwnode_handle fwnode;struct property *properties; /* 属性 */struct property *deadprops; /* removed 属性 */struct device_node *parent; /* 父节点 */struct device_node *child; /* 子节点 */struct device_node *sibling;struct kobject kobj;unsigned long _flags;void *data;#if defined(CONFIG_SPARC)const char *path_component_name;unsigned int unique_id;struct of_irq_controller *irq_trans;#endif}; of_find_node_by_name通过节点名 12struct device_node *of_find_node_by_name(struct device_node *from,const char *name); from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。name：要查找的节点名字。返回值： 找到的节点，如果为 NULL 表示查找失败。 of_find_node_by_type通过device_type 1struct device_node *of_find_node_by_type(struct device_node *from, const char *type) from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。type：要查找的节点对应的 type 字符串，也就是 device_type 属性值。返回值： 找到的节点，如果为 NULL 表示查找失败。 of_find_compatibe_node通过device_type和compatible 1struct device_node *of_find_compatible_node(struct device_node *from,const char *type,const char *compatible) from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。type：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示忽略掉 device_type 属性。compatible： 要查找的节点所对应的 compatible 属性列表。返回值： 找到的节点，如果为 NULL 表示查找失败 of_find_matching_node_and_match通过of_device_id匹配表找 1struct device_node *of_find_matching_node_and_match(struct device_node *from,const struct of_device_id *matches,const struct of_device_id **match) from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。matches： of_device_id 匹配表，也就是在此匹配表里面查找节点。match： 找到的匹配的 of_device_id。返回值： 找到的节点，如果为 NULL 表示查找失败 of_find_node_by_path通过节点路径 1inline struct device_node *of_find_node_by_path(const char *path) path：带有全路径的节点名，可以使用节点的别名（用 aliens 节点中定义的别名）。返回值： 找到的节点，如果为 NULL 表示查找失败 查找父子节点的OF函数 of_get_parent获取父节点 1struct device_node *of_get_parent(const struct device_node *node) node：要查找的父节点的节点。返回值： 找到的父节点。 of_get_next_child获取子节点 1struct device_node *of_get_next_child(const struct device_node *node,struct device_node *prev) node：父节点。prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。返回值： 找到的下一个子节点 提取属性的OF函数属性的描述结构体: 123456789struct property { char *name; /* 属性名字 */ int length; /* 属性长度 */ void *value; /* 属性值 */ struct property *next; /* 下一个属性 */ unsigned long _flags; unsigned int unique_id; struct bin_attribute attr; }; of_find_property获取指定属性 1property *of_find_property(const struct device_node *np,const char *name,int *lenp) np：设备节点。 name： 属性名字。lenp：属性值的字节数返回值： 找到的属性。 of_property_count_elems_of_size获取属性中元素的数量(数组大小) 12int of_property_count_elems_of_size(const struct device_node *np,const char *propname,int elem_size) np：设备节点。proname： 需要统计元素数量的属性名字。elem_size：元素长度。返回值： 得到的属性元素数量。 of_property_read_u32_index从属性中获取指定下标的数据值(u32数组情况) 12int of_property_read_u32_index(const struct device_node *np,const char *propname,u32 index,u32 *out_value) np：设备节点。proname： 要读取的属性名字。 index：要读取的值的下标。out_value：读取到的值返回值： 0 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。 of_property_read_u8_array读取属性中的u8类型数组数据 12345678910111213141516int of_property_read_u8_array(const struct device_node *np,const char *propname,u8 *out_values,size_t sz)int of_property_read_u16_array(const struct device_node *np,const char *propname,u16 *out_values,size_t sz)int of_property_read_u32_array(const struct device_node *np,const char *propname,u32 *out_values,size_t sz)int of_property_read_u64_array(const struct device_node *np,const char *propname,u64 *out_values,size_t sz) np：设备节点。proname： 要读取的属性名字。out_value：读取到的数组值，分别为 u8、 u16、 u32 和 u64。sz： 要读取的数组元素数量。返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。 of_property_read_u8读取一个属性值 123456789101112int of_property_read_u8(const struct device_node *np,const char *propname,u8 *out_value)int of_property_read_u16(const struct device_node *np,const char *propname,u16 *out_value)int of_property_read_u32(const struct device_node *np,const char *propname,u32 *out_value)int of_property_read_u64(const struct device_node *np,const char *propname,u64 *out_value) np：设备节点。proname： 要读取的属性名字。out_value：读取到的数组值。返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。 of_property_read_string读取属性中字符串值 123int of_property_read_string(struct device_node *np,const char *propname,const char **out_string) np：设备节点。proname： 要读取的属性名字。out_string：读取到的字符串值。返回值： 0，读取成功，负值，读取失败。 of_n_addr_cells获取#address-cells属性 1int of_n_addr_cells(struct device_node *np) of_n_size_cells函数获取#size-cells属性 1int of_n_size_cells(struct device_node *np) 其他OF函数 of_device_is_compatible 查看compatible中有没有包含指定字符串 12int of_device_is_compatible(const struct device_node *device,const char *compat) device：设备节点。compat：要查看的字符串。返回值： 0，节点的 compatible 属性中不包含 compat 指定的字符串；正数，节点的compatible 属性中包含 compat 指定的字符串。 of_get_address获取地址相关属性如“ reg”或者“ assigned-addresses”属性值 1234const __be32 *of_get_address(struct device_node *dev,int index,u64 *size,unsigned int *flags) dev：设备节点。index：要读取的地址标号。size：地址长度。flags：参数，比如 IORESOURCE_IO、 IORESOURCE_MEM 等返回值： 读取到的地址数据首地址，为 NULL 的话表示读取失败。 of_translate_address将从设备树读到地址转换为物理地址 12u64 of_translate_address(struct device_node *dev,const __be32 *in_addr) dev：设备节点。in_addr：要转换的地址。返回值： 得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。 of_address_to_resource 获取设备寄存器的内存空间 IIC、 SPI、 GPIO 等这些外设都有对应的寄存器，这些寄存器其实就是一组内存空间， Linux内核使用 resource 结构体来描述一段内存空间，“ resource”翻译出来就是“资源”，因此用 resource 结 构 体 描 述 的 都 是 设 备 资 源 信 息 ， resource 结 构 体 定 义 在 文 件include/linux/ioport.h 中，定义如下： 1234567struct resource {resource_size_t start;resource_size_t end;const char *name;unsigned long flags;struct resource *parent, *sibling, *child;}; 对于 32 位的 SOC 来说， resource_size_t 是 u32 类型的。其中 start 表示开始地址， end表示结束地址， name 是这个资源的名字， flags 是资源标志位，一般表示资源类型，可选的资源标志定义在文件 include/linux/ioport.h 中，如下所示： 1234567891011121314151617181920212223#define IORESOURCE_BITS 0x000000ff#define IORESOURCE_TYPE_BITS 0x00001f00#define IORESOURCE_IO 0x00000100#define IORESOURCE_MEM 0x00000200#define IORESOURCE_REG 0x00000300#define IORESOURCE_IRQ 0x00000400#define IORESOURCE_DMA 0x00000800#define IORESOURCE_BUS 0x00001000#define IORESOURCE_PREFETCH 0x00002000#define IORESOURCE_READONLY 0x00004000#define IORESOURCE_CACHEABLE 0x00008000#define IORESOURCE_RANGELENGTH 0x00010000#define IORESOURCE_SHADOWABLE 0x00020000#define IORESOURCE_SIZEALIGN 0x00040000#define IORESOURCE_STARTALIGN 0x00080000#define IORESOURCE_MEM_64 0x00100000#define IORESOURCE_WINDOW 0x00200000#define IORESOURCE_MUXED 0x00400000#define IORESOURCE_EXCLUSIVE 0x08000000#define IORESOURCE_DISABLED 0x10000000#define IORESOURCE_UNSET 0x20000000#define IORESOURCE_AUTO 0x40000000#define IORESOURCE_BUSY 0x80000000 of_address_to_resource 函数 将 reg 属性值，然后将其转换为 resource 结构体类型 。 123int of_address_to_resource(struct device_node *dev,int index,struct resource *r) dev：设备节点。index：地址资源标号。r：得到的 resource 类型的资源值。返回值： 0，成功；负值，失败。 of_iomap获取内存地址所对应的虚拟地址 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过index 参数指定要完成内存映射的是哪一段 。 12void __iomem *of_iomap(struct device_node *np,int index) np：设备节点。index： reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为 0。返回值： 经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。 Petalinux中的设备树Petalinux可以通过读取hdf文件自动生成设备树，在编译后，可以在components/plnx_workspace/device-tree/device-tree中找到： system-top.dts 123456789101112131415161718192021222324252627/* * CAUTION: This file is automatically generated by Xilinx. * Version: * Today is: Sat Mar 16 08:49:42 2024 *//dts-v1/;#include \"zynq-7000.dtsi\"#include \"pcw.dtsi\"/ { chosen { bootargs = \"earlycon\"; stdout-path = \"serial0:115200n8\"; }; aliases { ethernet0 = &amp;gem0; serial0 = &amp;uart1; spi0 = &amp;qspi; }; memory { device_type = \"memory\"; reg = &lt;0x0 0x20000000&gt;; };};#include \"system-user.dtsi\" 这份文件引用了一些其他的dtsi文件： zynq-7000.dtsi zynq-7000 系列处理器相同的硬件外设配置信息（ PS 端的） 。 pcw.dtsi 表示在 vivado 当中已经使能的 PS 外设 。 system-user.dtsi 用户的文件，可以在project-spec/meta-user/recipes-bsp/device-tree/files/中找到，可以放一些hdf读不到的信息，比如在IIC外设下的EEPROM。 一般如果我们想添加自己的外设，都会在system-user.dtsi中写追加设备树。","categories":[{"name":"ZYNQ学习笔记","slug":"ZYNQ学习笔记","permalink":"https://lostacnet.top/categories/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://lostacnet.top/tags/ZYNQ/"},{"name":"Linux","slug":"Linux","permalink":"https://lostacnet.top/tags/Linux/"}]},{"title":"ZYNQ学习笔记-字符设备驱动开发","slug":"ZYNQ学习笔记-字符设备驱动开发","date":"2024-03-18T12:45:36.000Z","updated":"2024-04-07T07:54:48.994Z","comments":true,"path":"post/31845/","link":"","permalink":"https://lostacnet.top/post/31845/","excerpt":"ZYNQ学习笔记-字符设备驱动开发字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的 LED、按键、 IIC、 SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。","text":"ZYNQ学习笔记-字符设备驱动开发字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的 LED、按键、 IIC、 SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。 描述驱动操作的数据结构在include/linux/fs.h 中定义了一个结构体，集合了内核驱动操作函数集合。 12345678910111213141516171819202122232425262728293031323334353637383940struct file_operations { struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); unsigned int (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long,unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f); #ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *); #endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t, u64); ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *, u64);} __randomize_layout; file_operation中常用的成员： ower拥有该结构体模块的指针，一般设置为THIS_MODULE。 llseek用于修改文件当前的读写位置。 read对应c库中的读取函数。 write对应c库中的写入函数。 poll轮训函数，由于查询设备是否可以进行非阻塞的读写。 unlocked_ioctl提供设备控制功能，对应应用中的ioctl函数。 compat_ioctl与上面函数功能一样，区别在于在 64 位系统上， 32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是unlocked_ioctl。 mmap用于将设备内存映射到用户空间中，用于直接操作缓存(比如LCD设备的显存)。 open对应c库中的open函数。 release对应c库中的close函数。 fsync由于处理待刷新的数据，用于将缓存数据刷新到磁盘。 fasync与上面功能相似，但是是异步操作。 编写驱动时，根据需要实现部分函数即可。 字符设备开发步骤驱动加载和卸载Linux驱动有两种方式运行，第一种就是将驱动编译进 Linux 内核中，这样当 Linux 内核启动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)，在 Linux 内核启动以后使用“insmod命令加载驱动模块，使用rmmod删除模块。 当执行加载和卸载命令时会分别执行两个函数，在驱动代码中使用以下方式注册者两个函数。 12module_init(xxx_init); //注册模块加载函数module_exit(xxx_exit); //注册模块卸载函数 123456789101112131415 /* 驱动入口函数 */static int __init xxx_init(void){ /* 入口函数具体内容 */ return 0;}/* 驱动出口函数 */static void __exit xxx_exit(void){ /* 出口函数具体内容 */}/* 将上面两个函数指定为驱动的入口和出口函数 */module_init(xxx_init);module_exit(xxx_exit); 其中__init和__exit修饰实际上是c语言的attribute关键字，用来将函数放在特点区域，使用完就从内存卸载。 驱动编译完成后是.ko后缀的文件，这时可以使用两个命令来加载驱动。首先是insmod： 1insmod drv.ko 这种只会单纯的加载驱动，不会去管依赖关系。如果drv.ko依赖first.ko，那么必须先加载first。如果想要解决依赖问题，需要使用modprobe命令，modprobe 命令主要智能在提供了模块的依赖性分析、错误检查、错误报告等功能，推荐使用 modprobe 命令来加载驱动。 modprobe 命令默认会去/lib/modules/目录中查找模块 ，一般自己制作的根文件系统中是不会有这个目录的，所以需要自己手动创建。 12rmmod drv.ko # 卸载驱动modprobe -r drv.ko # 卸载驱动 modprobe 命令可以卸载掉驱动模块所依赖的其他模块，前提是这些依赖模块已经没有被其他模块所使用，否则就不能使用 modprobe 来卸载驱动模块。所以对于模块的卸载，还是推荐使用 rmmod 命令。 字符设备的注册与注销在上面提到的加载和卸载函数中一般会运行设备的注册和注销函数。函数原型如下： 12static inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)static inline void unregister_chrdev(unsigned int major, const char *name) register_chrdev 函数用于注册字符设备 ： major： 主设备号， Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分，关于设备号后面会详细讲解。name：设备名字，指向一串字符串。fops： 结构体 file_operations 类型指针，指向设备的操作函数集合变量。 unregister_chrdev 函数用于注销字符设备，此函数有两个参数，这两个参数含义如下：major： 要注销的设备对应的主设备号。name： 要注销的设备对应的设备名。 设备的具体操作file_operations结构体中包含了设备的具体操作，每个驱动都需要定义一个，并在register_chrdev函数中进行注册。 一个基本的设备应该具备以下操作： 能够进行打开和关闭操作，这对应着结构体中的open和release函数。 能够进行读写操作，这对应着结构体中的read和write函数。 具体步骤是实现这些函数并赋值到file_operations结构体中。 设备的LICENSE和作者信息LICENSE是必须添加的，作者信息可以不添加。使用以下两个函数添加： 12MODULE_LICENSE() //添加模块 LICENSE 信息MODULE_AUTHOR() //添加模块作者信息 例子： 12MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"LO_StacNet\"); Linux设备号Linux每个驱动都有一个设备号，由主设备号和次设备号注组成(合并成一个dev_t数据类型，高位为主设备号，低位为次设备号)。dev_t定义在include/linux/types.h : 123 typedef __u32 __kernel_dev_t;... typedef __kernel_dev_t dev_t; __u32定义在include/uapi/asm-generic/int-ll64.h ： 1typedef unsigned int __u32; dev_t是一个32位数，高12位为主设备号，低20位为次设备号。 include/linux/kdev_t.h 中定义了关于设备号的操作函数： 12345#define MINORBITS 20 //次设备号位数#define MINORMASK ((1U &lt;&lt; MINORBITS) - 1) //次设备号掩码#define MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS)) //从dev_t中获取主设备号#define MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK)) //从dev_t中获取次设备号#define MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi)) //使用主设备号和次设备号组合成设备号 设备号可以有两种分配方式： 静态分配。由开发者自己设一个静态值，注意与已经使用的设备号区分。使用cat /proc/devices 查看已经使用的设备号。 动态分配。申请一个驱动号，卸载时释放。 动态分配使用以下函数： 1int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) 函数 alloc_chrdev_region 用于申请设备号，此函数有 4 个参数：dev：保存申请到的设备号。 baseminor： 次设备号起始地址， alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址并逐次递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。count： 要申请的设备号数量。name：设备名字。 1void unregister_chrdev_region(dev_t from, unsigned count) 销毁字符设备时要释放设备号。 from：要释放的设备号。count： 表示从 from 开始， 要释放的设备号数量。 应用操作函数通过c库的文件操作函数可以操作字符驱动，一般使用open、read、write、close函数。 1int open(const char *pathname, int flags) pathname：要打开的设备或者文件名。flags： 文件打开模式，以下三种模式必选其一: O_RDONLY-只读;O_WRONLY-只写;O_RDWR读写;还有其他模式，可以百度一下。 返回值：如果文件打开成功的话返回文件的文件描述符。 1ssize_t read(int fd, void *buf, size_t count) fd：要读取的文件描述符，读取文件之前要先用 open 函数打开文件， open 函数打开文件成功以后会得到文件描述符。buf： 数据读取到此 buf 中。count： 要读取的数据长度，也就是字节数。返回值： 读取成功的话返回读取到的字节数；如果返回 0 表示读取到了文件末尾；如果返回负值，表示读取失败。 1ssize_t write(int fd, const void *buf, size_t count); fd：要进行写操作的文件描述符，写文件之前要先用 open 函数打开文件， open 函数打开文件成功以后会得到文件描述符。buf： 要写入的数据。count： 要写入的数据长度，也就是字节数。返回值： 写入成功的话返回写入的字节数；如果返回 0 表示没有写入任何数据； 1int close(int fd); fd：要关闭的文件描述符。 返回值： 0 表示关闭成功，负值表示关闭失败。在 Ubuntu 中输入“ man 2 close”命令即可查看 close 函数的详细内容。 LED驱动的开发现在终于进行到了点灯环节。首先我们需要了解几个概念。 基本的驱动原理LED灯的基本驱动原理大家应该都很熟悉了，就是操作外设的寄存器。因此我们需要拿到寄存器地址。但是在Linux中不能直接操作地址，需要一些转换。 地址映射与虚拟地址Linux中有一个MMU(Memory Manage Unit 内存管理单元)，老版本linux要求处理器必须要有MMU单元，但是新版本Linux已经支持无MMU的处理器了。但是实际上仍然基于MMU运行。MMU主要完成以下功能： 将虚拟地址映射到物理地址。 内存保护，设置存储器的访问权限，设置虚拟存储空间的缓冲特性。 其中对我们使用影响最大的就是第一点，这也是所谓虚拟内存的来源。它可以把DDR(我使用的是512M)映射到32位处理器4G的内存地址中，至于多出来的空间怎么用的，比较复杂，这里就不说了(我也不知道)。 Linux内核启动时会初始化MMU，设置好内存映射，之后访问的都是虚拟地址。如果没有开启MMU，可以直接对物理寄存器地址进行读写，但如果开启了MMU，就必须获取对应虚拟地址才能进行操作。这里就涉及到两个函数了： ioremap函数 123456#define ioremap(cookie,size) __arm_ioremap((cookie), (size), MT_DEVICE)void __iomem * __arm_ioremap(phys_addr_t phys_addr, size_t size, unsigned int mtype){ return arch_ioremap_caller(phys_addr, size, mtype, __builtin_return_address(0));} ioremap 是个宏，有两个参数： cookie 和 size ，真正起作用的函数有三个参数。 phys_addr：要映射给的物理起始地址。size：要映射的内存空间大小。mtype： ioremap 的类型，可以选择 MT_DEVICE、 MT_DEVICE_NONSHARED、 MT_DEVICE_CACHED和 MT_DEVICE_WC， ioremap 函数选择 MT_DEVICE。返回值： __iomem 类型的指针，指向映射后的虚拟空间首地址。 假如要获取ZYNQ 的 APER_CLK_CTRL 寄存器对应的虚拟地址 : 123#define APER_CLK_CTRL 0xF800012Cstatic void __iomem *aper_clk_ctrl_addr;aper_clk_ctrl_addr = ioremap(APER_CLK_CTRL, 4); 宏定义 APER_CLK_CTRL 是寄存器物理地址， aper_clk_ctrl_addr 是该物理地址映射后的虚拟地址。对于 ZYNQ 来说一个寄存器是 4 字节(32 位)的，因此映射的内存长度为 4。映射完成以后直接对 aper_clk_ctrl_addr 进行读写操作即可。 iounmap函数 1void iounmap (volatile void __iomem *addr) 卸载驱动的时候需要使用 iounmap 函数释放掉 ioremap 函数所做的映射 。 要取消掉 APER_CLK_CTRL 寄存器的地址映射 ： 1iounmap(aper_clk_ctrl_addr); IO内存访问函数当外部寄存器或内存映射到内存空间时，称为 I/O 内存 。使用 ioremap 函数将寄存器的物理地址映射到虚拟地址以后，我们就可以直接通过指针访问这些地址，但是 Linux 内核不建议这么做，而是推荐操作函数来进行读写操作。 读操作函数 123u8 readb(const volatile void __iomem *addr)u16 readw(const volatile void __iomem *addr)u32 readl(const volatile void __iomem *addr) readb、 readw 和 readl 这三个函数分别对应 8bit、 16bit 和 32bit 读操作，参数 addr 就是要读取写内存地址，返回值就是读取到的数据。 写操作函数 123void writeb(u8 value, volatile void __iomem *addr)void writew(u16 value, volatile void __iomem *addr)void writel(u32 value, volatile void __iomem *addr) writeb、 writew 和 writel 这三个函数分别对应 8bit、 16bit 和 32bit 写操作，参数 value是要写入的数值， addr 是要写入的地址。 GPIO的寄存器终于到属性的寄存器操作环节了，这里主要来源是官方的数据手册，就不细说了。 LED驱动示例代码这里就直接使用正点原子的代码示例吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871 /***************************************************************2 Copyright © ALIENTEK Co., Ltd. 1998-2029. All rights reserved.3 文件名 : led.c4 作者 : 邓涛5 版本 : V1.06 描述 : ZYNQ LED 驱动文件。7 其他 : 无8 论坛 : www.openedv.com9 日志 : 初版 V1.0 2019/1/30 邓涛创建10 ***************************************************************/1112 #include &lt;linux/types.h&gt;13 #include &lt;linux/kernel.h&gt;14 #include &lt;linux/delay.h&gt;15 #include &lt;linux/ide.h&gt;16 #include &lt;linux/init.h&gt;17 #include &lt;linux/module.h&gt;18 #include &lt;linux/errno.h&gt;19 #include &lt;linux/gpio.h&gt;20 #include &lt;asm/mach/map.h&gt;21 #include &lt;asm/uaccess.h&gt;22 #include &lt;asm/io.h&gt;2324 #define LED_MAJOR 200 /* 主设备号 */25 #define LED_NAME \"led\" /* 设备名字 */2627 /*28 * GPIO 相关寄存器地址定义29 */30 #define ZYNQ_GPIO_REG_BASE 0xE000A00031 #define DATA_OFFSET 0x0000004032 #define DIRM_OFFSET 0x0000020433 #define OUTEN_OFFSET 0x0000020834 #define INTDIS_OFFSET 0x0000021435 #define APER_CLK_CTRL 0xF800012C3637 /* 映射后的寄存器虚拟地址指针 */38 static void __iomem *data_addr;39 static void __iomem *dirm_addr;40 static void __iomem *outen_addr;41 static void __iomem *intdis_addr;42 static void __iomem *aper_clk_ctrl_addr;434445 /*46 * @description : 打开设备47 * @param – inode : 传递给驱动的 inode48 * @param – filp : 设备文件， file 结构体有个叫做 private_data 的成员变量49 * 一般在 open 的时候将 private_data 指向设备结构体。50 * @return : 0 成功;其他 失败51 */52 static int led_open(struct inode *inode, struct file *filp)53 {54 return 0;55 }5657 /*58 * @description : 从设备读取数据59 * @param – filp : 要打开的设备文件(文件描述符)60 * @param – buf : 返回给用户空间的数据缓冲区61 * @param – cnt : 要读取的数据长度62 * @param – offt : 相对于文件首地址的偏移63 * @return : 读取的字节数，如果为负值，表示读取失败64 */65 static ssize_t led_read(struct file *filp, char __user *buf,66 size_t cnt, loff_t *offt)67 {68 return 0;69 }7071 /*72 * @description : 向设备写数据73 * @param – filp : 设备文件，表示打开的文件描述符74 * @param – buf : 要写给设备写入的数据75 * @param – cnt : 要写入的数据长度76 * @param – offt : 相对于文件首地址的偏移77 * @return : 写入的字节数，如果为负值，表示写入失败78 */79 static ssize_t led_write(struct file *filp, const char __user *buf,80 size_t cnt, loff_t *offt)81 {82 int ret;83 int val;84 char kern_buf[1];8586 ret = copy_from_user(kern_buf, buf, cnt);// 得到应用层传递过来的数据87 if(0 &gt; ret) {88 printk(KERN_ERR \"kernel write failed!\\r\\n\");89 return -EFAULT;90 }9192 val = readl(data_addr);93 if (0 == kern_buf[0])94 val &amp;= ~(0x1U &lt;&lt; 7); // 如果传递过来的数据是 0 则关闭 led95 else if (1 == kern_buf[0])96 val |= (0x1U &lt;&lt; 7); // 如果传递过来的数据是 1 则点亮 led9798 writel(val, data_addr);99 return 0;100 }101102 /*103 * @description : 关闭/释放设备104 * @param – filp : 要关闭的设备文件(文件描述符)105 * @return : 0 成功;其他 失败106 */107 static int led_release(struct inode *inode, struct file *filp)108 {109 return 0;110 }111112 /* 设备操作函数 */113 static struct file_operations led_fops = {114 .owner = THIS_MODULE,115 .open = led_open,116 .read = led_read,117 .write = led_write,118 .release = led_release,119 };120121 static int __init led_init(void)122 {123 u32 val;124 int ret;125126 /* 1.寄存器地址映射 */127 data_addr = ioremap(ZYNQ_GPIO_REG_BASE + DATA_OFFSET, 4);128 dirm_addr = ioremap(ZYNQ_GPIO_REG_BASE + DIRM_OFFSET, 4);129 outen_addr = ioremap(ZYNQ_GPIO_REG_BASE + OUTEN_OFFSET, 4);130 intdis_addr = ioremap(ZYNQ_GPIO_REG_BASE + INTDIS_OFFSET, 4);131 aper_clk_ctrl_addr = ioremap(APER_CLK_CTRL, 4);132133 /* 2.使能 GPIO 时钟 */134 val = readl(aper_clk_ctrl_addr);135 val |= (0x1U &lt;&lt; 22);136 writel(val, aper_clk_ctrl_addr);137138 /* 3.关闭中断功能 */139 val |= (0x1U &lt;&lt; 7);140 writel(val, intdis_addr);141142 /* 4.设置 GPIO 为输出功能 */143 val = readl(dirm_addr);144 val |= (0x1U &lt;&lt; 7);145 writel(val, dirm_addr);146147 /* 5.使能 GPIO 输出功能 */148 val = readl(outen_addr);149 val |= (0x1U &lt;&lt; 7);150 writel(val, outen_addr);151152 /* 6.默认关闭 LED */153 val = readl(data_addr);154 val &amp;= ~(0x1U &lt;&lt; 7);155 writel(val, data_addr);156157 /* 7.注册字符设备驱动 */158 ret = register_chrdev(LED_MAJOR, LED_NAME, &amp;led_fops);159 if(0 &gt; ret){160 printk(KERN_ERR \"Register LED driver failed!\\r\\n\");161 return ret;162 }163164 return 0;165 }166167 static void __exit led_exit(void)168 {169 /* 1.卸载设备 */170 unregister_chrdev(LED_MAJOR, LED_NAME);171172 /* 2.取消内存映射 */173 iounmap(data_addr);174 iounmap(dirm_addr);175 iounmap(outen_addr);176 iounmap(intdis_addr);177 iounmap(aper_clk_ctrl_addr);178 }179180 /* 驱动模块入口和出口函数注册 */181 module_init(led_init);182 module_exit(led_exit);183184 MODULE_AUTHOR(\"DengTao &lt;773904075@qq.com&gt;\");185 MODULE_DESCRIPTION(\"Alientek ZYNQ GPIO LED Driver\");186 MODULE_LICENSE(\"GPL\"); 第 2425 行， 定义了两个宏，设备名字和设备的主设备号。第 3035 行，本实验要用到的寄存器宏定义。第 3842 行，经过内存映射以后的寄存器地址指针。第 5255 行， led_open 函数，为空函数，可以自行在此函数中添加相关内容，一般在此函数中将设备结构体作为参数 filp 的私有数据(filp-&gt;private_data)。第 6569 行， led_read 函数，为空函数，如果想在应用程序中读取 LED 的状态，那么就可以在此函数中添加相应的代码，比如读取 MIO 的 DATA 寄存器的值，然后返回给应用程序。第 79100 行， led_write 函数，实现对 LED 灯的开关操作，当应用程序调用 write 函数向 led 设备写数据的时候此函数就会执行。首先通过函数 copy_from_user 获取应用程序发送过来的操作信息(打开还是关闭 LED)，最后根据应用程序的操作信息来控制寄存器打开或关闭LED 灯。第 107110 行， led_release 函数，为空函数，可以自行在此函数中添加相关内容，一般关闭设备的时候会释放掉 led_open 函数中添加的私有数据。第 113119 行，设备文件操作结构体 led_fops 的定义和初始化。第 121165 行，驱动入口函数 led_init，此函数实现了 LED 的初始化工作， 127131 行通过 ioremap 函数获取物理寄存器地址映射后的虚拟地址，得到寄存器对应的虚拟地址以后就可以完成相关初始化工作了。比如使能 GPIO 时钟、 关闭 MIO7 的中断功能、配置并使能 MIO7 的输出功能等。最后，最重要的一步！使用 register_chrdev 函数注册 led 这个字符设备。第 167178 行，驱动出口函数 led_exit，首先使用函数 unregister_chrdev 注销 led 这个字符设备，然后调用 iounmap 函数取消内存映射，因为设备已经被卸载，也就意味用不到了，必须要取消映射；需要注意的是这两顺序不要反了，不能在设备没有卸载的情况下，你就把人家的内存映射给取消了，这是不合理的！第 181182 行，使用 module_init 和 module_exit 这两个函数指定 led 设备驱动加载和卸载函数。第 184~186 行，添加模块 LICENSE、 作者信息以及模块描述信息。 对应的应用APP代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/** @description : main 主程序* @param - argc : argv 数组元素个数* @param - argv : 具体参数* @return : 0 成功;其他 失败*/int main(int argc, char *argv[]){ int fd, ret; unsigned char buf[1]; if(3 != argc) { printf(\"Usage:\\n\" \"\\t./ledApp /dev/led 1 @ close LED\\n\" \"\\t./ledApp /dev/led 0 @ open LED\\n\" ); return -1; } /* 打开设备 */ fd = open(argv[1], O_RDWR); if(0 &gt; fd) { printf(\"file %s open failed!\\r\\n\", argv[1]); return -1; } /* 将字符串转换为 int 型数据 */ buf[0] = atoi(argv[2]); /* 向驱动写入数据 */ ret = write(fd, buf, sizeof(buf)); if(0 &gt; ret){ printf(\"LED Control Failed!\\r\\n\"); close(fd); return -1; } /* 关闭设备 */ close(fd); return 0;} 编译和运行首先是编译驱动代码。驱动文件依赖了内核的的大量源码，不能直接通过交叉工具链编译。因此首先需要下载linux源码，由于petalinux本身没有包含内核文件，因此需要我们手动下载linux内核。使用以下命令下载： 1git clone --depth 1 https://github.com/Xilinx/linux-xlnx.git 或者，在Petalinux编译后，在build/tmp/work-shared/plnx_arm/kernel-source/中可以找到代码，将其复制到一个易于寻找的目录下。输入: 12make ARCH=arm xilinx_zynq_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12 等待编译完成。 如果整编内核，可以放在内核目录下的drivers/char下，并在该目录的Makefile中添加obj-m += demo_driver.o。这样在编译内核时可以编译该驱动。 如果只是单独编译，使用make modules。 make modules 指令为编译内核模块指令，该指令的功能是编译内核中所有配置为模块的程序得到模块ko文件，make modules 命令只能在内核源码顶层目录下执行。如果想单独编译一个模块，使用M=参数。M=DIR，程序会自动跳转到所指定的DIR目录中查找模块源码，编译生成ko文件。 1make M=DIR modules 基于此，我们可以编写一个makefile: 12345678KDIR := /home/lo/kernel-source #内核源码目录obj-m := led.oall: make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -C $(KDIR) M=`pwd` modulesclean: make -C $(KDIR) M=`pwd` clean 之后使用make命令即可。 获得.ko文件后复制到开发板，如果有网络，可以使用以下方式进行复制： 1scp led.ko root@192.168.1.133:/lib/modules/4.14.0-xilinx 输入命令加载驱动: 1insmod led.ko 之后可以在/proc/devices中找到文件。 或者： 12depmod # 生成.dep文件modprobe led.ko 然后需要在/dev目录下创建节点: 1mknod /dev/led c 200 0 mknod是创建节点命令，/dev/led是要创建的节点文件，c表示这是个字符设备，200是设备的主设备号，0是设备的次设备号。创建完成以后就会存在/dev/led 这个文件 编译APP。 1arm-linux-gnueabihf-gcc ledApp.c -o ledApp 复制到开发板运行: 12./ledApp /dev/led 1 //点亮 LED 灯./ledApp /dev/led 0 //关闭 LED 灯 当然如果使用petalinux工具，可以更简单的添加驱动，但那样编译时间长，不适合调试。 新字符设备以上字符设备的注册方法使用的是老版本的API(register_chrdev,unregister_chrdev)，现在都推荐使用新的API函数(cdev系列函数)，并有一套比较标准的创建方法。 新的字符设备注册方法在 Linux 中使用 cdev 结构体表示一个字符设备， cdev 结构体在include/linux/cdev.h文件中的定义如下： 12345678struct cdev { struct kobject kobj; struct module *owner; const struct file_operations *ops; struct list_head list; dev_t dev; unsigned int count;}; 这你需要关注两个成员，ops这就是要实现的file_operations，dev设备号。与老API不同，这里传递参数使用一个结构体传输。 1struct cdev test_cdev; cdev_init函数 1void cdev_init(struct cdev *cdev, const struct file_operations *fops) 初始化结构体，用来设定一些成员的初始值。 12345678struct cdev testcdev;/* 设备操作函数 */ static struct file_operations test_fops = { .owner = THIS_MODULE, /* 其他具体的初始项 */};testcdev.owner = THIS_MODULE;cdev_init(&amp;testcdev, &amp;test_fops); /* 初始化 cdev 结构体变量 */ cdev_add函数 该函数就是实际的注册函数。 1int cdev_add(struct cdev *p, dev_t dev, unsigned count) 参数 p 指向要添加的字符设备(cdev 结构体变量)，参数 dev 就是设备所使用的设备号，参数 count 是要添加的设备数量。 1cdev_add(&amp;testcdev, devid, 1); cdev_del函数 该函数就是实际的注销函数。 1void cdev_del(struct cdev *p) 示例： 1cdev_del(&amp;testcdev); /* 删除 cdev */ 使用文件的私有数据之前，我们使用变量来存储驱动的设备号，状态以及其他数据。这样其实不专业，对于一个设备的所有属性信息我们最好将其做成一个结构体，在open中传到私有数据中。 12345678910111213141516struct test_dev{ dev_t devid; /* 设备号 */ struct cdev cdev; /* cdev */ struct class *class; /* 类 */ struct device *device; /* 设备 */ int major; /* 主设备号 */ int minor; /* 次设备号 */};struct test_dev testdev;static int test_open(struct inode *inode, struct file *filp){ filp-&gt;private_data = &amp;testdev; /* 设置私有数据 */ return 0;} 之后在 write、 read、 close 等函数中直接读取private_data 即可得到设备结构体 。 自动创建设备节点我们往常加载驱动后还需要手动mknod创建设备节点，在驱动中实现自动创建设备节点的功能以后，使用 modprobe 加载驱动模块成功的话就会自动在/dev 目录下创建对应的设备文件。 自动功能由udev实现，这是一个应用程序，构建文件系统时会构建一个建议版本mdev。它会检测系统中硬件设备状态，自动创建和删除设备文件。这样可以在安装驱动时自动创建节点，也可以管理热拔插。 创建类和删除类 自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添加自动创建设备节点相关代码。在include/linux/device.h 中可以看到： 12345678#define class_create(owner, name) \\ ({ \\ static struct lock_class_key __key; \\ __class_create(owner, name, &amp;__key); \\ }) struct class *__class_create(struct module *owner, const char *name, struct lock_class_key *key) 宏展开后： 1struct class *class_create (struct module *owner, const char *name) 该代码实现了类的创建。参数 owner 一般为 THIS_MODULE，参数 name 是类名字。返回值是个指向结构体 class 的指针，也就是创建的类。 卸载驱动程序的时候需要删除掉类，类删除函数为 class_destroy，函数原型如下： 1void class_destroy(struct class *cls); 设备创建和删除 除了创建类以外，还需要在这个类下创建一个设备。 1struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char*fmt, ...) device_create 是个可变参数函数，参数 class 就是设备要创建哪个类下面；参数 parent是父设备，一般为 NULL，也就是没有父设备；参数 devt 是设备号；参数 drvdata 是设备可能会使用的一些数据，一般为 NULL；参数 fmt 是设备名字，如果设置 fmt=xxx 的话，就会生成/dev/xxx 这个设备文件。返回值就是创建好的设备。 卸载驱动的时候需要删除掉创建的设备: 1void device_destroy(struct class *class, dev_t devt) 参数 classs 是要删除的设备所处的类，参数 devt 是要删除的设备号 。 使用新API的代码示例在上面代码的基础上，这里只列出不同部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103...#define NEWCHRLED_CNT 1 /* 设备号个数 */#define NEWCHRLED_NAME \"newchrled\" /* 名字 */... /* newchrled 设备结构体 */struct newchrled_dev { dev_t devid; /* 设备号 */ struct cdev cdev; /* cdev */ struct class *class; /* 类 */ struct device *device; /* 设备 */ int major; /* 主设备号 */ int minor; /* 次设备号 */};static struct newchrled_dev newchrled; /* led 设备 */...static int led_open(struct inode *inode, struct file *filp){ filp-&gt;private_data = &amp;newchrled; /* 设置私有数据 */ return 0;}...static int __init led_init(void){ u32 val; int ret; .../* 7.注册字符设备驱动 */ /* 创建设备号 */ if (newchrled.major) { newchrled.devid = MKDEV(newchrled.major, 0); ret = register_chrdev_region(newchrled.devid, NEWCHRLED_CNT,CHRLED_NAME); if (ret) goto out1; } else { ret = alloc_chrdev_region(&amp;newchrled.devid, 0, NEWCHRLED_CNT,NEWCHRLED_NAME); if (ret) goto out1; newchrled.major = MAJOR(newchrled.devid); newchrled.minor = MINOR(newchrled.devid); } printk(\"newcheled major=%d,minor=%d\\r\\n\",newchrled.major,newchrled.minor); /* 初始化 cdev */ newchrled.cdev.owner = THIS_MODULE; cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops); /* 添加一个 cdev */ ret = cdev_add(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT); if (ret) goto out2; /* 创建类 */ newchrled.class = class_create(THIS_MODULE, NEWCHRLED_NAME); if (IS_ERR(newchrled.class)) { ret = PTR_ERR(newchrled.class); goto out3; } /* 创建设备 */ newchrled.device = device_create(newchrled.class, NULL, newchrled.devid, NULL, NEWCHRLED_NAME); if (IS_ERR(newchrled.device)) { ret = PTR_ERR(newchrled.device); goto out4; } return 0;out4: class_destroy(newchrled.class);out3: cdev_del(&amp;newchrled.cdev);out2: unregister_chrdev_region(newchrled.devid, NEWCHRLED_CNT);out1: led_iounmap();return ret;}static void __exit led_exit(void){ /* 注销设备 */ device_destroy(newchrled.class, newchrled.devid); /* 注销类 */ class_destroy(newchrled.class); /* 删除 cdev */ cdev_del(&amp;newchrled.cdev); /* 注销设备号 */ unregister_chrdev_region(newchrled.devid, NEWCHRLED_CNT); /* 取消地址映射 */ led_iounmap();}... 驱动中的倒退式处理方法 :出现错误后使用goto跳转来恢复之前的操作。 编译： 123456789KERN_DIR := 内核地址obj-m := newchrled.oall: make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -C $(KERN_DIR) M=`pwd` modulesclean: make -C $(KERN_DIR) M=`pwd` clean 使用make命令编译。 加载驱动： 123Depmod //第一次加载驱动的时候需要运行此命令modprobe newchrled.ko //加载驱动rmmod newchrled.ko //卸载驱动 基于设备树的驱动开发基于设备树的开发，就是将硬件信息写到设备树中，驱动只需要通过函数获取设备树信息，就不需要将寄存器地址之类的写到驱动中。 添加设备树想设备树根节点中添加以下节点： 123456789101112led { compatible = \"zynq,led\"; status = \"okay\"; default-state = \"on\"; reg = &lt;0xE000A040 0x4 0xE000A204 0x4 0xE000A208 0x4 0xE000A214 0x4 0xF800012C 0x4 &gt;; }; 这里主要是添加了5个相关寄存器地址。 添加到Linux系统中，可以进入到/proc/device-tree/目录中查看是否有“ led”这个节点。 驱动编写 驱动在之前的基础上进行设置，给出不同的部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* dtsled 设备结构体 */struct dtsled_dev { dev_t devid; /* 设备号 */ struct cdev cdev; /* cdev */ struct class *class; /* 类 */ struct device *device; /* 设备 */ int major; /* 主设备号 */ int minor; /* 次设备号 */ struct device_node *nd; /* 设备节点 */};static struct dtsled_dev dtsled; /* led 设备 */static inline void led_ioremap(void){ data_addr = of_iomap(dtsled.nd, 0); dirm_addr = of_iomap(dtsled.nd, 1); outen_addr = of_iomap(dtsled.nd, 2); intdis_addr = of_iomap(dtsled.nd, 3); aper_clk_ctrl_addr = of_iomap(dtsled.nd, 4);}static int __init led_init(void){ const char *str; u32 val; int ret; /* 1.获取 led 设备节点 */ dtsled.nd = of_find_node_by_path(\"/led\"); if(NULL == dtsled.nd) { printk(KERN_ERR \"led node can not found!\\r\\n\"); return -EINVAL; } /* 2.读取 status 属性 */ ret = of_property_read_string(dtsled.nd, \"status\", &amp;str); if(!ret) { if (strcmp(str, \"okay\")) return -EINVAL; } /* 2、获取 compatible 属性值并进行匹配 */ ret = of_property_read_string(dtsled.nd, \"compatible\", &amp;str); if(0 &gt; ret) return -EINVAL; if (strcmp(str, \"alientek,led\")) return -EINVAL; printk(KERN_ERR \"led device matching successful!\\r\\n\");/* 4.寄存器地址映射 */ led_ioremap();/* 5.使能 GPIO 时钟 *//* 6.关闭中断功能 *//* 7.设置 GPIO 为输出功能 *//* 8.使能 GPIO 输出功能 *//* 9.初始化 LED 的默认状态 */ val = readl(data_addr); ret = of_property_read_string(dtsled.nd, \"default-state\", &amp;str); if(!ret) { if (!strcmp(str, \"on\")) val |= (0x1U &lt;&lt; 7); else val &amp;= ~(0x1U &lt;&lt; 7); } else val &amp;= ~(0x1U &lt;&lt; 7); writel(val, data_addr);/* 10.注册字符设备驱动 */} 使用 of_iomap 函数替换之前使用 ioremap 函数来实现物理地址到虚拟地址的映射，它能够直接解析给定节点的 reg 属性，并将 reg 属性中存放的物理地址和长度进行映射，使用不同的下标依次对 reg 数组中记录的不同组“物理地址-长度” 地址空间进行映射。 其他函数的介绍printk函数在linux内核送使用printk进行输出而不是printf。printk 可以根据日志级别对消息进行分类，一共有 8 个消息级别，这 8 个消息级别定义在文件include/linux/kern_levels.h里面 ： 12345678910#define KERN_SOH \"\\001\" /* ASCII Start Of Header */#define KERN_SOH_ASCII '\\001'#define KERN_EMERG KERN_SOH \"0\" /* system is unusable */#define KERN_ALERT KERN_SOH \"1\" /* action must be taken immediately */#define KERN_CRIT KERN_SOH \"2\" /* critical conditions */#define KERN_ERR KERN_SOH \"3\" /* error conditions */#define KERN_WARNING KERN_SOH \"4\" /* warning conditions */#define KERN_NOTICE KERN_SOH \"5\" /* normal but significant condition */#define KERN_INFO KERN_SOH \"6\" /* informational */#define KERN_DEBUG KERN_SOH \"7\" /* debug-level messages */ 一共定义了 8 个级别，其中 0 的优先级最高， 7 的优先级最低。如果要设置消息级别，参考如下示例： 1printk(KERN_EMERG \"gsmi: Log Shutdown Reason\\n\");//消息级别为KERN_EMERG 默认级别可以设置(CONFIG_MESSAGE_LOGLEVEL_DEFAULT )，默认为4。同时还有CONSOLE_LOGLEVEL_DEFAULT 控制哪些消息可以显示在控制台上，默认为 7，意味着只有优先级高于 7 的消息才能显示在控制台上 。 copy_to_user内核空间的数据和用户空间的数据是分开的，想要向用户传参，需要调用函数： 1static inline long copy_to_user(void __user *to, const void *from, unsigned long n) 参数 to 表示目的，参数 from 表示源，参数 n 表示要复制的数据长度。如果复制成功，返回值为 0，如果复制失败则返回负数。","categories":[{"name":"ZYNQ学习笔记","slug":"ZYNQ学习笔记","permalink":"https://lostacnet.top/categories/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://lostacnet.top/tags/ZYNQ/"},{"name":"Linux","slug":"Linux","permalink":"https://lostacnet.top/tags/Linux/"}]},{"title":"ZYNQ学习笔记-Petalinux的使用","slug":"ZYNQ学习笔记-Petalinux的使用","date":"2024-03-15T13:32:07.000Z","updated":"2024-08-08T04:24:21.007Z","comments":true,"path":"post/31532/","link":"","permalink":"https://lostacnet.top/post/31532/","excerpt":"ZYNQ学习笔记-Petalinux的使用Petalinux可以简化ZYNQ-7000的Linux开发，这里记录一下基本使用流程。","text":"ZYNQ学习笔记-Petalinux的使用Petalinux可以简化ZYNQ-7000的Linux开发，这里记录一下基本使用流程。 设计流程Petalinux设计流程一般如下： 创建硬件。使用vivado创建工程，设定硬件，导出hdf文件。 创建Petalinux工程。 导入硬件。导入vivado生成的hdf。 设置工程。 设置内核。 设置根文件系统。 配置设备树。 编译工程。 打包制作BIN文件。 创建硬件工程这里需要使用vivado生成硬件工程。 这边偷懒一下，使用了小梅哥的BX71开发板给的出厂工程。其BlockDesign如图所示： 可以看见它HDMI输出了一个色条。并且使用了PL端的ENET，并且为了适配板上的物理层芯片使用加了一个转换模块。 处理器的设置如下，开启了QSPI，UART1(与板子上的转换芯片相连)，ENET0，USB0，SD0，GPIO。 ENET使用了EMIO(PL)端，并使用了MDIO(配置信号线)。 这里导出硬件信息，注意包含bit流。最后在工程目录下的sdk目录中得到hdf文件。 在linux中创建petalinux工程文件夹，在该文件夹下创建hdf文件夹，将hdf文件夹整个拷贝到hdf下。 创建Petalinux工程使用petalinux工程前，先使用source命令运行安装目录下的setting.sh文件，添加环境变量。 1source petalinux2018.3/settings.sh 切换到之前的工程目录，在终端输入以下命令创建工程： 1petalinux-create -t project --template zynq -n mylinux -t project:表明这是一个linux工程，而不是linux应用之类。 -n mylinux:指定工程名为mylinux。 --template zynq:设定这是一个ZYNQ的工程。 配置Petalinux工程第一次配置时，需要将hdf文件导入到工程中，petalinux解析完成后会弹出配置界面。进入刚刚创建的mylinux工程，输入以下命令导入。 12 petalinux-config --get-hw-description &lt;hdf 文件目录&gt; 导入成功后会自动弹出配置窗口： 这里对各个选项进行简单的说明。 Linux Components Selection 星号表示已经使能。First Stage Bootloader是自动生成fsbl.elf文件。第二个是自动更新ps_init,即fsbl中的第一个函数。自动配置会让程序跟着hdf文件更新。下面两个是配置u-boot和linux内核的来源，一般默认就行。 Auto Config Setting 自动配置各种组件(根据hdf文件)。 Subsystem AUTO Hardware Settings 配置一些硬件设置。 第一个为系统处理器设置，程序跑在哪个核。 第二个用来配置内存大小以及程序基地址等等，根据hdf文件自动生成。 第三个选择使用哪个串口进行标志输入输出以及波特率，这里只开了一个串口。 第四个为网络设置，包括使用主网口，MAC地址设置和是否自动IP地址获取(DHCP)。 第五个设置FLASH(QSPI)，设置FLASH的分区，用于从FLASH启动LInux时。 第六个设置默认的SD卡设备。 第七个设置RTC时钟，这里没开启。 最后为镜像设置。设置各种镜像存储在那个存储介质，包括boot(fsbl,bitstream,uboot,dtb(可选))、u-boot环境变量、jffs2文件系统(用来存配置信息)、dtb来源(设备树)。 DTG Settings MACHINE_NAME设置开发板的名字，用来对应开发板设备树(国外总是喜欢以开发板为配置单位)默认即可。 Kernel Bootargs设置，设置内核启动变量。 Devicetree flags 设备树相关 Devicetree overlay 设备树相关 Remove PL 设备树不自动包含PL端的设备。 u-boot Configuration 配置uboot相关的设置。 第一个不知道。 第二个设置了uboot的配置文件。 第三个设置netboot，网络启动相关。 第四个设置TFTP服务器ip地址，网络下载镜像时使用。 Image Packaging Configuration 第一个设置根文件系统的类型。默认是放在RAM中(内存模拟文件系统—根目录在内存中)，和内核镜像打包在一起。也可以放在SD_card。 关于INITRAMFS INITRAMFS 类型的根文件系统每次重新启动 linux 系统都是全新的、 未改动过的，也就是说启动系统后进行的所有修改掉电后就全部丢失了， 再次重新启动还是之前未修改过的根文件系统，选择 SD card 可以将根文件系统放在 SD 卡的 ext4 分区，这样启动系统后进行的所有修改掉电后就不会丢失了。 ——引用自正点原子 第二个设置了内核镜像名字。 第三个设备树相关。 第四个设置是否将镜像自动拷贝到tftp服务器目录中，这里没有搭建，设置为不使能。 第五个设置tftp服务器目录所在。 Firmware Version Configuration 配置版本名，可自定义。 Yocto Settings 底层的设置。Petalinux底层就是Yocto。 配置完成后进行保存Save，程序会自动进行配置。 配置配置内核终端输入如下命令配置内核: 1petalinux-config -c kernel 这里由于使用了GMII 2 RGMIIIP核，需要添加相应的驱动。 Device Driver-&gt;Network device support-&gt;PHY Device support and infrastructure中使能xilinx GMII2RGMII converter driver 。 配置Uboot 注意：由于petalinux2018的bug，如果将设备树放在sd卡，最后会生成booti(64位下的)命令，导致无法启动linux，这里需要将project-spec/meta-plnx-generated/recipes-bsp/u-boot/configs/platform-auto.h中的 1default_bootcmd=run uenvboot; run cp_kernel2ram &amp;&amp; run cp_dtb2ram &amp;&amp; booti ${netstart} - ${dtbnetstart} 将上面的booti改成bootm. 配置根文件系统终端输入如下命令配置内核: 1petalinux-config -c rootfs Filesystem Packages 配置常用的工具软件，包括内核调试软件、流媒体软件、 Python 软件以及图形界面软件等 。 Petalinux Package Groups 选择Petalinux提供的软件包，比如包含opencv的相关软件包依赖。 Image Features 配置根文件系统的某些功能，如是否支持 ssh，使用 dropbear的 ssh 还是 openssh 等。如果不希望每次启动 linux 后都得输入密码验证，可以使能该菜单下的“ debug-tweaks”选项。 apps 构建用户应用。 user packages 配置自定义软件包。 petalinux rootfs settings 主要用来设置root的密码。 最后可以编译出各种rootfs文件，可以将 rootfs.tar.gz 或者 rootfs.tar.bz2文件解压到 SD 卡的第二个分区——ext4 文件系统分区来测试根文件系统 。 配置设备树如果需要配置设备树，可以编辑当前 petalinux 工程目录下的 project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi 文件。 1vim project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi 编译Petalinux工程配置全部完成后，使用命令编译。 1petalinux-build 制作镜像编译完成后，petalinux生成了一系列文件，此时需要将这些分散的文件部署整合成易于部署的镜像。 1petalinux-package --boot --fsbl --fpga --u-boot --force –boot说明生成镜像 –fsbl指定镜像中的fsbl文件位置 –fpga指定bit流文件 –u-boot指定uboot即用户代码位置 –force强制覆盖已生成的文件 文件都默认在images/linux下，不指定就会使用默认路径。 BOOT.BIN就是启动镜像，image.ub是linux镜像。 制作SD启动卡使用SD卡引导linux启动，一般需要两个分区。一个是FAT32文件系统，用来放置启动镜像(BOOT.BIN,linux镜像)，另外一个是EXT4分区，用于存放根文件系统。由于本篇设置的是INITRAMFS，没有用到SD卡的文件系统，因此只需要FAT32分区。 将读卡器插入到电脑上，连接到虚拟机，查看其符号，我这里是/dev/sdb。 如果使用图形界面。插入后会自动挂载，先取消挂载，然后进行分区。 12umount /dev/sdb*sudo fdisk /dev/sdb 在fdisk界面输入p: 可以看到有一个FAT32分区/dev/sdb1。这里输入d将该分区删除。 接着输入n新建分区，输入p为主分区，使用默认分区号1和2048第一个扇区，设置第一个分区大小为100M。 之后先后输入t，c，将分区设为W95 FAT32(代号为c)。 之后输入a设置为引导分区。 此时FAT分区创建完毕，之后创建ext分区。 输入n，之后全部默认，将剩余的空间全部分走。 之后输入w保存，退出。 之后在分区创建文件系统： 12sudo mkfs.vfat -F 32 -n boot /dev/sdb1sudo mkfs.ext4 -L rootfs /dev/sdb2 如果使用图形界面，此时可以看到自动挂载了两个U盘。如果没有图形界面，还需手动挂载sdb1和sdb2。之后将BOOT.BIN和image.ub拷贝到boot下就可以了。 SD启动之后将SD插入到卡槽，利用串口终端即可登录。默认账户和密码为root。 FLASH启动当Linux文件系统不是太大时，可以直接将其放在FLASH中。其实就是将BOOT.BIN放在FLASH里面，在config中设置boot的路径后将最后生成的文件通过SDK的program flash烧录到QSPI FLASH即可。 问题编译时报错提示没有“phy1”123system-top.dtb: ERROR (phandle_references): /amba/ethernet@e000b000: Reference to non-existent node or label \"phy1\"system-top.dtb: ERROR (phandle_references): /amba/ethernet@e000b000/mdio/gmii_to_rgmii_0@31: Reference to non-existent node or label \"phy1\" 这是由于在配置中使能了MDIO(配置端口)，引用了一个外部的物理层芯片却没有为其添加设备树导致的，外部芯片无法自动添加到设备树中。这里需要手动添加：打开文件：project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi 在这个文件中添加自定义的设备树。 在文件最后添加: 123456&amp;gem0{phy1:phy@1 { device_type = \"ethernet-phy\"; reg = &lt;0x5&gt;;};}; &amp;gem0表示重写gem0，在其中添加一个phy1。 这本质还是当前版本的petalinux不能正确的读取hdf生成设备树，请使用与vivado相同版本的petalinux。","categories":[{"name":"ZYNQ学习笔记","slug":"ZYNQ学习笔记","permalink":"https://lostacnet.top/categories/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://lostacnet.top/tags/ZYNQ/"},{"name":"Linux","slug":"Linux","permalink":"https://lostacnet.top/tags/Linux/"}]},{"title":"ZYNQ学习笔记-Petalinux环境搭建","slug":"ZYNQ学习笔记-Petalinux环境搭建","date":"2024-03-12T13:20:03.000Z","updated":"2024-08-03T14:05:13.714Z","comments":true,"path":"post/31220/","link":"","permalink":"https://lostacnet.top/post/31220/","excerpt":"ZYNQ学习笔记-Petalinux环境搭建Xilinx官方为ZYNQ编译Linux相关程序提供了一个集成工具Petalinux，利用它，用户可以快速编译在ZYNQ上运行的Linux和应用。","text":"ZYNQ学习笔记-Petalinux环境搭建Xilinx官方为ZYNQ编译Linux相关程序提供了一个集成工具Petalinux，利用它，用户可以快速编译在ZYNQ上运行的Linux和应用。 前言开始我使用了2018.3版本的petalinux以配合我的vivado，但是发现WSL最老是18.04.6，而2018.3版本的petalinux只能到16.因此要么升级petalinux，要么降级ubuntu，这里由于wsl不能降级，最后选择了升级到2019.1，安装步骤只有版本号不同，其他一样。然而后来发现2019.1的只支持vivado2019.1到出的工程，因此最后只能无奈安装低版本的ubuntu。这里留下原教程，以供参考。 下载安装文件这里需要准备ubuntu-16.04.4-desktop-amd64.iso 和petalinux-v2018.3-final-installer.run。 之后安装ubuntu虚拟机–这里需要设置如下： 需要共享USB。最少需要50g的磁盘空间。 安装VMware Tool参考教程 安装依赖输入以下命令安装： 1234sudo apt-get install tofrodos iproute2 gawk gcc g++ git make net-tools libncurses5-dev \\tftpd zlib1g:i386 libssl-dev flex bison libselinux1 gnupg wget diffstat chrpath socat \\xterm autoconf libtool tar unzip texinfo zlib1g-dev gcc-multilib build-essential \\libsdl1.2-dev libglib2.0-dev screen pax gzip automake 安装程序之后输入以下命令进行安装： 12mkdir petalinux2018.3 # 设置路径./petalinux-v2018.3-final-installer.run petalinux2018.3/ # 安装 由于WSL的ubuntu的shell默认使用dash，需要先将其切换为bash： 1sudo dpkg-reconfigure dash 在弹出的命令框中选择NO。 之后进入安装文件夹，输入命令添加环境变量： 1source settings.sh 之后使用echo $PETALINUX检查是否成功。 安装驱动在petalinux目录下有一个tools文件夹，其中包含了驱动，这里先把jatg断开连接。 进入以下目录： 1tools/xsct/SDK/2018.3/data/xicom/cable_drivers/lin64/install_script/install_drivers 运行该目录下的文件： 1sudo ./install_drivers 如果驱动遇到问题，可以使用下面的命令删除驱动： 123sudo rm -f /etc/udev/rules.d/52-xilinx-digilent-usb.rulessudo rm -f /etc/udev/rules.d/52-xilinx-ftdi-usb.rulessudo rm -f /etc/udev/rules.d/52-xilinx-pcusb.rules WSL安装方法——对较新版本文件下载这里使用2018.3版本的petalinux，在官网下载petalinux-v2018.3-final-installer.run。直接复制到linux子系统中。 使用chmod +x xxx命令设置为可执行文件。 安装依赖首先需要确保WSL的版本为WSL2，使用以下命令查询： 1wsl -l -v 查看version版本，如果不是2，使用以下命令修改： 1wsl --set-version &lt;distribution name&gt; &lt;versionNumber&gt; 如果失败，自行搜索windows的WSL2安装，这里不多说了。注意使用的系统为Ubuntu 18.04.6 LTS。新版系统不支持老版本的Petalinux。 之后，需要安装相关的依赖库，输入以下命令安装： 1234sudo apt-get install tofrodos iproute2 gawk gcc g++ git make net-tools libncurses5-dev \\tftpd zlib1g:i386 libssl-dev flex bison libselinux1 gnupg wget diffstat chrpath socat \\xterm autoconf libtool tar unzip texinfo zlib1g-dev gcc-multilib build-essential \\libsdl1.2-dev libglib2.0-dev screen pax gzip automake 其中zlib1g:i386需要使用以下命令单独安装： 123sudo dpkg --add-architecture i386sudo apt-get updatesudo apt-get install zlib1g:i386 安装程序之后输入以下命令进行安装： 12mkdir petalinux2018.3 # 设置路径./petalinux-v2018.3-final-installer.run petalinux2018.3/ # 安装 由于WSL的ubuntu的shell默认使用dash，需要先将其切换为bash： 1sudo dpkg-reconfigure dash 在弹出的命令框中选择NO。 之后进入安装文件夹，输入命令添加环境变量： 1source settings.sh 之后使用echo $PETALINUX检查是否成功。 共享USB由于WLS2与Windows基本隔离，需要使用工具将Jtag以及其他设备共享到WLS。 本次需要使用到开源项目usbipd-win，根据使用手册下载安装。 安装完成后，输入以下命令查看USB设备： 1usbipd list 我电脑上的设备如上，5-1是串口，5-2就是Jtag。 之后根据BUSID，输入命令允许共享设备——这需要管理员身份启动： 1usbipd bind --busid 5-2 注意需要将WSL升级到最新版。 之后在WSL中输入lsusb即可查看设备。 可以看到ID是一样的。 如果想要取消连接，可以使用以下命令： 1usbipd detach --busid &lt;busid&gt; 安装驱动在petalinux目录下有一个tools文件夹，其中包含了驱动，这里先把jatg断开连接。 进入以下目录： 1tools/xsct/SDK/2018.3/data/xicom/cable_drivers/lin64/install_script/install_drivers 运行该目录下的文件： 1sudo ./install_drivers 安装完成。 如果驱动遇到问题，可以使用下面的命令删除驱动： 123sudo rm -f /etc/udev/rules.d/52-xilinx-digilent-usb.rulessudo rm -f /etc/udev/rules.d/52-xilinx-ftdi-usb.rulessudo rm -f /etc/udev/rules.d/52-xilinx-pcusb.rules 其他问题WSL 中出现 :Zone.Identifier 文件的原因和解决方法从 Windows 直接下载文件或移动文件到 WSL 目录时，会出现类似 :Zone.Identifier 的文件。 其中包含了一些跟关联文件有关的元数据。 该文件因为微软的 NTFS 功能而出现，虽然没有实际用途。 解决方法 移动文件时，不要通过资源管理器，而是通过 VS Code，这样不会生成该文件； 通过这条命令删除该文件：find . -name \"*:Zone.Identifier\" -type f -delete。","categories":[{"name":"ZYNQ学习笔记","slug":"ZYNQ学习笔记","permalink":"https://lostacnet.top/categories/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://lostacnet.top/tags/ZYNQ/"},{"name":"Linux","slug":"Linux","permalink":"https://lostacnet.top/tags/Linux/"},{"name":"WSL","slug":"WSL","permalink":"https://lostacnet.top/tags/WSL/"}]},{"title":"STM32学习笔记-CortexM3的函数跳转","slug":"STM32学习笔记-CortexM3的函数跳转","date":"2024-03-08T12:14:09.000Z","updated":"2024-08-03T14:04:20.447Z","comments":true,"path":"post/3814/","link":"","permalink":"https://lostacnet.top/post/3814/","excerpt":"STM32学习笔记-CortexM3的函数跳转STM32F1是CortexM3内核，这里记录一下其函数跳转与中断跳转中的寄存器与堆栈变换情况。","text":"STM32学习笔记-CortexM3的函数跳转STM32F1是CortexM3内核，这里记录一下其函数跳转与中断跳转中的寄存器与堆栈变换情况。 CortexM3的寄存器和堆栈首先，得知道M3各个寄存器。 这里主要需要关注R13栈堆寄存器(保存堆栈地址)，R14连接寄存器(储存跳转前地址)，R15程序计数寄存器(指向下一条要执行的指令地址)。 除此之外还有一些特殊功能寄存器。只能被MSR、MRS指令访问。 这里只需要关注xPSR寄存器(储存程序状态)，CONTROL寄存器（主要是其控制堆栈指针的功能）。 SP栈指针SP指针指向的是栈的地址，最开始指向栈底，使用压栈出栈指令的时候会自动进行管理地址的增减。栈堆一个很重要的作用就是在跳转中储存寄存器的值。 堆栈的 PUSH 与 POP 堆栈是一种存储器的使用模型。它由一块连续的内存和一个栈顶指针组成，用于实 现“后进先出”的缓冲区。其最典型的应用，就是在数据处理前先保存寄存器的值，再 在处理任务完成后从中恢复先前保护的这些值。 在执行 PUSH 和 POP 操作时，那个通常被称为 SP 的地址寄存器，会由硬件自动调整它的值，以避免后续操作破坏先前的数据。 栈寄存器分为**MSP(主栈)和PSP(线程栈)**，由CONTROL寄存器决定。系统复位后或处于处理模式时为MSP。MSP初地址在向量表的第一项。同一时间SP只能读到一个栈，但可以通过MRS/MSR 指令来指名道姓地访问具体的堆栈指针。 LR链接寄存器LR寄存器在使用跳转指令BL,BLX时，内核会将返回地址保存在LR中，方便之后直接使用BX LR返回。如果发生函数嵌套，需要在跳转前将BL的值压入栈，防止再次被覆盖。 在发生中断跳转到中断处理函数时，LR寄存器会储存一个叫EXC_RETURN的值，用来进行中断跳转流程。 PC寄存器这个不用多说，储存了下一条要执行指令的地址，程序往下运行的核心（也是程序跑飞的核心）。CortexM3只支持Thumb模式运行，因此其最低位必须为1，表示在Thumb模式，否则会产生一个fault异常。 xPSR寄存器程序状态寄存器，三合一，主要保存了一些状态（比如计算溢出、进位之类）。 CONTROL寄存器用来设定是使用MSP还是PSP以及设定是程序是特权级(可以访问全部地址和功能)还是用户级(受限的地址和寄存器访问)。 APCS标准ARM公司给ARM框架上的程序都规定了一套标准，所有编译器的编译结果都必须按照这个标准，这样编译出来的程序才能进行正确链接。APCS定义了以下几个方面： 对寄存器使用的限制。 使用栈的惯例。 在函数调用之间传递/返回参数。 可以被‘回溯’的基于栈的结构的格式，用来提供从失败点到程序入口的函数(和给予的参数)的列表。 这里给出它的几个要点： 参数和返回值传递，对于简单的情况，输入参数由R0-R3分别用来记录第1到第4个参数。当传递的参数超过4个时，就需要借助栈来保存参数。函数的返回值通常保存在R0中，若返回值为64位的，R1也用来保存返回值。 函数调用中的寄存器用法。函数或子程序应该保持R4-R11、R13(SP)和R14(LR)的数值。若这些寄存器在函数或子程序执行期间被修改，则其函数应该保持在栈中并在返回调用代码前恢复。这几个寄存器也被称作“被调用者保存寄存器”，也就是需要被调用者（例如子函数，中断等）进行保存的寄存器。而对于R0-R3、R12、则属于调用者保存寄存器，这几个寄存器是需要调用者做保存工作。在发生异常或中断啊时，R0-R3、R12、SP、PC会硬件自动进程压栈。 链接寄存器LR用于函数或子程序调用时返回地址的保存，若某函数需要调用另外一个函数或子程序，则它需要首先将LR的数值保存到栈中，否则，当执行了函数调用后，LR的当前值就会丢失。 总结一下，就是参数值传递按顺序存放在寄存器r0,r1,r2,r3里，超过4个参数值传递则放栈里。返回值放在r0,r1中。然后就是R4-R11、R13(SP)和R14(LR)的数值不能被改变。 函数跳转过程函数的跳转不涉及特权模式，其过程还是比较简单的（相对于中断处理来说）。 在这篇文章给出了一个具体的例子。 当程序需要进行函数跳转时，会将函数的参数放到R0,R1,R2,R3寄存器(一共4*32位)，如果需要更大空间，需要将参数压到栈中。如果这其中还有有用的数据，需要先将其也压入栈中（比如中断嵌套时，这其中还有要使用的参数）。 之后执行跳转指令，该指令会跳转到一个地址并将跳转前的地址存到LR寄存器中。 进行跳转后，子函数需要保存R4-R11、R14(LR)的值到栈中(如果不改动就不需要保存)。 执行子程序，将要返回的结果存放在R0、R1。 执行完成跳转回去前，将保存的寄存器值恢复出来。 利用LR的值进行跳转指令，回到原程序。 中断的跳转流程中断的跳转与函数跳转不同，中断会直接打断程序的运行，不会等程序准备好跳转（此时R0-R3等寄存器还没有准备好，可能存有重要数据）。另外，中断使用的栈是MSP和程序可能使用PSP，栈的位置不同，会涉及到栈地址的保存。 因此对于中断，有一个专门中断跳转流程。 1，入栈触发中断后，处理器要做的第一件事是保存现场。不像函数调用，此时无法保证APCS标准中的寄存器做好了跳转准备，因此处理器会依次把xPSR, PC, LR, R12以及R3-R0由硬件自动压入适当的堆栈中。如果此时正在使用PSP则压入PSP，否则压入MSP。进入中断后使用MSP。 2，取向量函数跳转指令需要地址，中断也需要。中断的地址储存在中断向量表中。在数据总线入栈时，指令总线（I-Code）会从向量表中读取中断处理函数的地址。 3，更新寄存器完成上述操作后，处理器会将SP变成MSP，同时在IPSR相应位置设置异常编号，将地址放进PC，更新LR值。 此时，填入LR寄存器的值是一个特殊的名为EXC_RETURN的值，该值标志了中断返回后使用线程模式还是处理模式，使用PSP还是MSP。同时还标志了栈帧类型（结束后会设置到CONTROL寄存器的FPCA位）。 4，进入中断进入中断函数后，和其他函数一样，软件去保存其他寄存器。之后执行自己的服务。结束后软件恢复保存的栈。 5，中断返回在中断函数中执行触发中断返回的指令（BX LR,POP,LDR,LDM）改变PC的值为EXC_RETURN，会触发异常返回。 根据EXC_RETURN确定返回后处理器的状态。之后进行出栈，恢复之前被硬件压栈的寄存器。 引入一个EXC_RETURN的作用：使编译器能够以编译普通函数的方式编译中断函数，而不必使用标识进行注明（比如51中的__interrupt）。 参考文章CM3权威指南 APCS，ARM 过程调用标准(ARM Procedure Call Standard)","categories":[{"name":"STM32学习笔记","slug":"STM32学习笔记","permalink":"https://lostacnet.top/categories/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"中断","slug":"中断","permalink":"https://lostacnet.top/tags/%E4%B8%AD%E6%96%AD/"},{"name":"堆栈","slug":"堆栈","permalink":"https://lostacnet.top/tags/%E5%A0%86%E6%A0%88/"},{"name":"STM32","slug":"STM32","permalink":"https://lostacnet.top/tags/STM32/"}]},{"title":"中兴F412在23端口禁用下使用telnet获取超级账户","slug":"中兴F412在23端口禁用下使用telnet获取超级账户","date":"2024-02-09T14:11:17.000Z","updated":"2024-03-26T15:36:43.177Z","comments":true,"path":"post/2911/","link":"","permalink":"https://lostacnet.top/post/2911/","excerpt":"中兴F412在23端口禁用下使用telnet获取超级账户常规情况下，可以直接使用telnet 192.168.1.1来进入光猫后台进行获取密码，但是现在会出现23端口被禁用问题，这里给出解决方法。","text":"中兴F412在23端口禁用下使用telnet获取超级账户常规情况下，可以直接使用telnet 192.168.1.1来进入光猫后台进行获取密码，但是现在会出现23端口被禁用问题，这里给出解决方法。 连接打开两个终端，其中一个输入： 1ping 192.168.1.1 -l 128 -t 另外一个负责telnet连接，输入： 1telnet 192.168.1.1 10128 输入账号密码： 12账号：root密码：Zte521 获取信息输入命令： 1sendcmd 1 DB p UserInfo 如果无效则: 1sendcmd 1 DB p DevAuthInfo Level用户组权限，1是超级管理员，2是普通用户 一般账户为telecomadmin，密码为telecomadminXXXXXXXX 如果输出太长看不到，可以使用grep命令: 1sendcmd 1 DB p DevAuthInfo | grep telecomadmin","categories":[{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://lostacnet.top/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"CMake学习笔记-The C Compiler is not able to compile a simple test program","slug":"CMake学习笔记-The-C-Compiler-is-not-able-to-compile-a-simple-test-program","date":"2024-02-07T11:20:09.000Z","updated":"2024-02-07T11:35:50.251Z","comments":true,"path":"post/2720/","link":"","permalink":"https://lostacnet.top/post/2720/","excerpt":"The C Compiler is not able to compile a simple test program问题在使用arm-none-eabi-gcc.exe进行交叉编译时，cmake提示报错。此时编译器路径正确，构建器选择正确。但是还是报错not able to compile a simple test program。","text":"The C Compiler is not able to compile a simple test program问题在使用arm-none-eabi-gcc.exe进行交叉编译时，cmake提示报错。此时编译器路径正确，构建器选择正确。但是还是报错not able to compile a simple test program。 问题分析这是由于Cmake会对编译器进行自检来测试编译器能否使用，但是其默认标准是编译一个可执行文件并运行是否正确。但是在交叉编译的情况下，我们编译的结果是不能直接运行的，因此需要想办法跳过检查。 解决方法常规解决方法是在使用project()前调用set(CMAKE_TRY_COMPILE_TARGET_TYPE \"STATIC_LIBRARY\")。这样就不会去编译一个可执行文件。 参考回答CMake: The C Compiler is not able to compile a simple test program","categories":[{"name":"CMake学习笔记","slug":"CMake学习笔记","permalink":"https://lostacnet.top/categories/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"}]},{"title":"树莓派Pico学习笔记-Win下Clion环境搭建","slug":"树莓派Pico学习笔记-Win下Clion环境搭建","date":"2024-02-07T08:00:10.000Z","updated":"2024-02-07T13:14:19.755Z","comments":true,"path":"post/2700/","link":"","permalink":"https://lostacnet.top/post/2700/","excerpt":"树莓派Pico学习笔记-Win下Clion环境搭建最近掏出了吃灰已久的合宙RP2040，打算先搭建好环境，借助它学习一下win下交叉编译与调试环境的搭建，以及CMake与Clion的使用。","text":"树莓派Pico学习笔记-Win下Clion环境搭建最近掏出了吃灰已久的合宙RP2040，打算先搭建好环境，借助它学习一下win下交叉编译与调试环境的搭建，以及CMake与Clion的使用。 下载安装首先完成以下软件的安装： Clion CMake——C语言生成器(Clion自带) ninja——C语言构建器(同make，nmake功能)(Clion自带) git——主要用于从github下载代码 arm-gcc工具链——编译代码 mingw——win上的gcc，用来编译elf2uf2工具(Clion自带) OpenOCD——调试工具 Pico-SDK 注意添加到环境变量。 基于Clion创建工程目录将SDK/external目录下的pico_sdk_import.cmake复制到工程目录。 添加程序代码文件main.c： 1234567891011121314151617181920212223/** * Copyright (c) 2020 Raspberry Pi (Trading) Ltd. * * SPDX-License-Identifier: BSD-3-Clause */#include \"pico/stdlib.h\"int main() {#ifndef PICO_DEFAULT_LED_PIN#warning blink example requires a board with a regular LED#else const uint LED_PIN = PICO_DEFAULT_LED_PIN; gpio_init(LED_PIN); gpio_set_dir(LED_PIN, GPIO_OUT); while (true) { gpio_put(LED_PIN, 1); sleep_ms(250); gpio_put(LED_PIN, 0); sleep_ms(250); }#endif} 添加CMakeLists.txt: 1234567891011121314151617cmake_minimum_required(VERSION 3.13)# initialize the SDK directlyinclude(pico_sdk_import.cmake)project(picotest)# initialize the Raspberry Pi Pico SDKpico_sdk_init()add_executable(blink main.c)# pull in common dependenciestarget_link_libraries(blink pico_stdlib)# create map/bin/hex/uf2 file etc.pico_add_extra_outputs(blink) 添加工具链这里基本与STM32环境的搭建过程一样。 在Clion的设置中构建、部署、执行-&gt;工具链添加新工具链ARM-GCC。 CMake自带，构建工具使用自带的Ninja。选择编译器和调试器为上面安装的ARM工具链中的。 其实无所谓，树莓派Pico的SDK已经指定好了，只需要将编译器添加到环境变量就可以直接用了，搞的我还以为mingw可以交叉编译了 之后点击CMake，选择工具链为刚刚创建的ARM-GCC，在下面的环境中添加PICO_SDK_PATH环境变量。 编译下载调试编译后在build中就会有uf2文件可以直接下载，或者使用调试器下载调试。 配置调试也与stm32相似，只需要注意一下配置文件的写法： 1234#pico.cfgsource [find interface/picoprobe.cfg]source [find target/rp2040.cfg] 基于命令行的搭建——接触底层添加环境变量 将PicoSDK目录添加到环境变量PICO_SDK_PATH。 或者在使用CMake命令时使用-DPICO_SDK_PATH=参数传递。 或者在txt中使用SET设置。 创建工程文件夹将SDK/external目录下的pico_sdk_import.cmake复制到工程目录。 添加程序代码文件main.c： 1234567891011121314151617181920212223/** * Copyright (c) 2020 Raspberry Pi (Trading) Ltd. * * SPDX-License-Identifier: BSD-3-Clause */#include \"pico/stdlib.h\"int main() {#ifndef PICO_DEFAULT_LED_PIN#warning blink example requires a board with a regular LED#else const uint LED_PIN = PICO_DEFAULT_LED_PIN; gpio_init(LED_PIN); gpio_set_dir(LED_PIN, GPIO_OUT); while (true) { gpio_put(LED_PIN, 1); sleep_ms(250); gpio_put(LED_PIN, 0); sleep_ms(250); }#endif} 添加CMakeLists.txt: 12345678910111213141516171819cmake_minimum_required(VERSION 3.13)# initialize the SDK directlyinclude(pico_sdk_import.cmake)#这句对交叉编译很重要，跳过编译器检查set(CMAKE_TRY_COMPILE_TARGET_TYPE \"STATIC_LIBRARY\")project(picotest)# initialize the Raspberry Pi Pico SDKpico_sdk_init()add_executable(blink main.c)# pull in common dependenciestarget_link_libraries(blink pico_stdlib)# create map/bin/hex/uf2 file etc.pico_add_extra_outputs(blink) 构建编译工程创建build文件夹，进入，在该文件夹下执行命令： 1cmake .. -G Ninja -G Ninja是为了生成Ninja使用的文件。否则，在Windos下，会优先使用VS的nmake。这里没有装vs，会提示nmake找不到。 当然也可以使用mingw自带的msys2，修改-G的参数即可。 也可以在这里传入PICO_SDK_PATH。 构建完成后，执行命令: 1cmake --build . 这里需要注意安装一个c语言编译器，因为这里会编译elf2uf2工具。 之后就可以在目录下看见uf2文件了。 下载elf文件并调试详见参考文章。 这里注意，openocd的配置文件已经在其目录下了，可以自行查看支持种类。 使用GDB远程调试功能连接到OpenOCD进行调试。 参考文章使用 DAPLink 调试烧录树莓派 Picohexo","categories":[{"name":"树莓派Pico学习笔记","slug":"树莓派Pico学习笔记","permalink":"https://lostacnet.top/categories/%E6%A0%91%E8%8E%93%E6%B4%BEPico%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"},{"name":"Clion","slug":"Clion","permalink":"https://lostacnet.top/tags/Clion/"},{"name":"rp2040","slug":"rp2040","permalink":"https://lostacnet.top/tags/rp2040/"},{"name":"OpenOCD","slug":"OpenOCD","permalink":"https://lostacnet.top/tags/OpenOCD/"}]},{"title":"CMake学习笔记-常用指令","slug":"CMake学习笔记-常用指令","date":"2024-02-04T06:12:29.000Z","updated":"2024-02-04T11:38:24.102Z","comments":true,"path":"post/2412/","link":"","permalink":"https://lostacnet.top/post/2412/","excerpt":"CMake学习笔记-常用指令CMake是使用C语言绕不开的坎，这里记录一下CMake常用的命令以供查阅。","text":"CMake学习笔记-常用指令CMake是使用C语言绕不开的坎，这里记录一下CMake常用的命令以供查阅。 一个最基本的CMakeLists.txt工程目录文件:main.cpp,CMakeLists.txt CMakeLists.txt: 123456# CMakeLists.txt# 关键字可小写PROJECT(HELLO)MESSAGE(STATUS \"This is BINARY dir\" ${PROJECT_BINART_DIR})MESSAGE(STATUS \"This is SOURCE dir\" ${PROJECT_SOURCE_DIR})ADD_EXECUTABLE(HELLO main.cpp) 使用以下命令编译： 12cmake .cmake --build . 语法基本原则 变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名 指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 指令是大小写无关的，参数和变量是大小写相关的。 SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号 内部构建与外部构建内部构建就是直接在CMakeLists.txt文件所在目录cmake .。这样生成的临时文件都在根目录，比较乱。 外部构建。在其他文件夹使用cmake project_dir。其中project_dir是工程路径。这样就不会在工程文件夹下生成临时文件了。 两个变量： PROJECT_SOURCE_DIR 工程路径 PROJECT_BINARY_DIR 编译路径，使用cmake的路径。 编译Debug版本默认编译为Release版本。 编译Debug(可供调试版本)： 1cmake .. -DCMAKE_BUILD_TYPE=debug 相关环境变量可以通过修改环境变量实现生产环境。比如在linux的bash中： 1export CMAKE_INCLUDE_PATH=/usr/include/hello CMAKE_INCLUDE_PATH，头文件路径。 CMAKE_LIBRARY_PATH，库文件路径。 PROJECT——指定工程名和语言project可以用来指定工程的名字和支持的语言，默认支持所有语言。 PROJECT (HELLO) 指定了工程的名字，并且支持所有语言—建议 PROJECT (HELLO CXX) 指定了工程的名字，并且支持语言是C++ PROJECT (HELLO C CXX) 指定了工程的名字，并且支持语言是C和C++ SET——指定变量用来显示的指定变量。 SET(SRC_LIST main.cpp t1.cpp t2.cpp)SRC_LIST就包含了后面三个。 MESSAGE——输出终端信息向终端输出用户信息。主要包括三种： SEND_ERROR产生错误，生成过程被跳过 STATUS输出信息 FATAL_ERROR立即终止所有cmake过程 ADD_EXECUTABLE——生成可执行文件用来指定生成可执行文件。 ADD_EXECUTABLE(hello ${SRC_LIST}) 生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容。 工程名(PROJECT指定)与生成可执行文件hello没有任何关系。 ADD_SUBDIRECTORY ——指定源文件子目录1ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 该指令用来向当前工程添加存放源文件的子目录(source_dir)，并可以指定中间二进制和目标二进制的存放位置(binary_dir)。 EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example。 使用例子： 工程树： 123456.├── build├── CMakeLists.txt└── src ├── CMakeLists.txt └── main.cpp 外层CMakeLists.txt 12PROJECT(HELLO)ADD_SUBDIRECTORY(src bin) src下的CMakeLists.txt 1ADD_EXECUTABLE(hello main.cpp) 对于ADD_SUBDIRECTORY(src bin)： 将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为build/bin 目录。如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录。 如果想要将最终编译结果放到外面而不是子文件夹： 在SRC目录下的CMakeLists.txt(哪里要改变目标存放路径，就在哪里加入上述的定义)中添加： 1234# 编译可执行文件的输出路径--放到了build下SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR})# 编译库文件的输出路径--放到了build/lib下SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) ADD_LIBRARY——构建库1ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) 和ADD_EXECUTABLE()一样。 hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so SHARED，动态库 STATIC，静态库 ${LIBHELLO_SRC} ：源文件 SET_TARGET_PROPERTIES——设置输出对象的参数123456#对hello_static的重名为helloSET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME \"hello\")#cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a，这里设置为不清理SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)#设置版本号，VERSION 指代动态库版本，SOVERSION 指代 API 版本。SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) INCLUDE_DIRECTORIES——添加头文件路径添加头文件路径，首先可以直接在代码中使用绝对路径。 或者使用关键字添加头文件搜索目录。 1INCLUDE_DIRECTORIES(/usr/include/hello) INCLUDE_DIRECTORIES 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割 LINK_DIRECTORIES——添加第三方共享库路径1LINK_DIRECTORIES(/home/myproject/libs) LINK_DIRECTORIES 添加非标准的共享库搜索路径。 或者直接添加共享库文件。 TARGET_LINK_LIBRARIES——添加需要链接的共享库1TARGET_LINK_LIBRARIES(main libhello.a)` TARGET_LINK_LIBRARIES 添加需要链接的共享库。 INSTALL——安装INSTALL可以安装：二进制，动态库，静态库，文件，脚本。 相关变量CMAKE_INSTALL_PREFIX。 安装文件1INSTALL(FILES file1 file2 DESTINATION path) FILES：文件 DESTINATION： 1、写绝对路径 2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION 定义的路径&gt; cmake -DCMAKE_INSTALL_PREFIX=/usr 在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径。 安装脚本1INSTALL(PROGRAMS runhello.sh DESTINATION bin) PROGRAMS：非目标文件的可执行程序安装(比如脚本之类) 安装文件夹中文件 在相应文件夹下创建CMakeLists.txt，其中使用INSTALL。 在工程目录通过DIRECTORY指定。 1INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake) DIRECTORY 后面连接的是所在 Source 目录的相对路径 注意：abc 和 abc/有很大的区别 目录名不以/结尾：这个目录将被安装为目标路径下的 目录名以/结尾：将这个目录中的内容安装到目标路径 安装共享库和头文件123456789#本例将hello共享库安装到&lt;prefix&gt;/lib下#hello.h安装到&lt;prefix&gt;/include/hello#文件放到该目录下INSTALL(FILES hello.h DESTINATION include/hello)#二进制，静态库，动态库安装都用TARGETS#ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。#hello是add_library添加的动态库对象，hello_static是静态INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib) 参考从零开始详细介绍CMake","categories":[{"name":"CMake学习笔记","slug":"CMake学习笔记","permalink":"https://lostacnet.top/categories/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"}]},{"title":"同时搭建Clion与Vscode的Platformio环境","slug":"同时搭建Clion与Vscode的Platformio环境","date":"2023-09-23T07:44:42.000Z","updated":"2023-09-23T08:50:59.102Z","comments":true,"path":"post/92344/","link":"","permalink":"https://lostacnet.top/post/92344/","excerpt":"同时搭建Clion与Vscode的Platformio环境众所周知，Arduino虽然库很多，但是它的编译速度实在是太慢了。按下编译，拿一杯茶品一下，品完还没编译完。为了同时享受Arduino的库(延长寿命)，同时享受更快的速度，我选择使用PlatformIO。","text":"同时搭建Clion与Vscode的Platformio环境众所周知，Arduino虽然库很多，但是它的编译速度实在是太慢了。按下编译，拿一杯茶品一下，品完还没编译完。为了同时享受Arduino的库(延长寿命)，同时享受更快的速度，我选择使用PlatformIO。 下载PlotformIO到官网查看PlatformIO。官网的版本有两个，一个是Core一个是IDE。其中IDE是基于Vscode，并且包含Core。 Clion要求使用CLI，即Core，但是由于IDE包含，我们只需要安装IDE就行。 打开Vscode插件市场，搜索PlatformIO，安装。等待一段时间，Vscode会自动安装Core组件。 安装完成后，重启Vscode，可以在侧栏中找到PIO的标志点开，找到PlatformIO Core CLI，在终端输入pio system info查看信息。 框中显示的信息是我修改过的，默认应该在C盘。 重新设置PIO的目录PIO CORE的安装目录默认都在C盘，但是我C盘实在是太满了，如果再加上一堆库，就要炸了，因此我需要重新定义一下PIO的位置。 首先在其他盘创建一个文件夹用来存放PIO的文件，这里我创建的是D:\\PlatformIO_Core\\。 然后设置环境变量，中添加上面创建的目录路径，命名为PLATFORMIO_CORE_DIR。 然后，将上面查到的路径里面的文件复制到我们创建的新目录下，然后删除源文件夹。 重启Vscode，再次查看目录位置，看是否为新目录。 将PIO CORE关联到命令行不要这么做，这个文件夹中有python，会导致Python无法正常运行 上面说到了，IDE是自带CORE，可以使用CLI，但是由于CLI程序的环境变量没有设置，因此暂时无法使用。这里我们在环境变量的PATH中添加D:\\PlatformIO_Core\\penv\\Scripts即platformio.exe所在位置。 完成后打开命令行窗口，输入pio命令查询能否正常运行。 配置CLION环境刚刚在上面我们将IDE的Core关联到了命令行，那么这时候在CLion中可以直接安装PlatformIO插件就可以使用了，路径可以留空(因为已经添加到环境变量中去了)。这里我不再多说，网上有很多。 打开设置，在platformio中输入我们创建的地址: 这里说一下，采用上面设置之后，就可以Vscode和Clion使用同一套工具开发platformio的工程了。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://lostacnet.top/tags/vscode/"},{"name":"Clion","slug":"Clion","permalink":"https://lostacnet.top/tags/Clion/"},{"name":"Arduino","slug":"Arduino","permalink":"https://lostacnet.top/tags/Arduino/"},{"name":"PlatformIO","slug":"PlatformIO","permalink":"https://lostacnet.top/tags/PlatformIO/"}]},{"title":"使用CLion搭建ESP32-IDF开发环境","slug":"使用CLion搭建ESP32-IDF开发环境","date":"2023-09-16T16:45:23.000Z","updated":"2023-09-22T18:28:57.389Z","comments":true,"path":"post/91745/","link":"","permalink":"https://lostacnet.top/post/91745/","excerpt":"使用CLion搭建ESP32-IDF开发环境ESP-IDFv4.0后，使用了CMake构建工程，而Clion也是使用CMake进行工程的构建的，理论上是可以使用CLion开发IDF的。为了能够在开发ESP32时使用上喷气机家族非常好用的代码补全系统，这里记录环境配置的过程。","text":"使用CLion搭建ESP32-IDF开发环境ESP-IDFv4.0后，使用了CMake构建工程，而Clion也是使用CMake进行工程的构建的，理论上是可以使用CLion开发IDF的。为了能够在开发ESP32时使用上喷气机家族非常好用的代码补全系统，这里记录环境配置的过程。 前置环境搭建前，需要先搭建好以下一些环境： 完整的ESP-IDF环境，可以进行正常开发。 可以正常使用的Clion。 添加工具链首先，我们需要将IDF使用工具链加入到CLion，包括虚拟python环境，idf.py，编译器等，这里IDF实际上已经做好了，在安装目录xxx\\Espressif下，有一个idf_cmd_init.bat文件，该脚本将所有的工具链都添加了进来，只需要在CLion选择它即可。 打开CLion设置，在构建、执行、部署-&gt;工具链中点击加号添加新工具链。命名为ESP-IDF，展开添加环境，选择环境文件，在弹窗中选择上面提到的idf_cmd_init.bat文件，点击应用。 更改工程CMake设置打开一个IDF工程(可以从IDF的example文件夹中复制)，打开设置，在构建、执行、部署-&gt;CMake中选择配置，将工具链修改为上面创建的ESP-IDF。 添加IDF_PATH环境变量在工程的CMakeLists中有这样一段代码: 1include($ENV{IDF_PATH}/tools/cmake/project.cmake) 从环境变量IDF_PATH路径得到IDF的cmake应用文件。 这个环境变量默认是没有的，因此需要我们进行添加IDF_PATH为安装目录xxx\\Espressif的环境变量，这里有三种添加方法，我只使用一种： 在每个工程中添加局部的环境变量这个在上面修改Cmake的地方有一个环境属性可以修改。 修改工具链的配置文件在工具链的配置文件的开头，加上设置环境变量的语句set IDF_PATH=xxx\\Espressif。 修改系统的环境变量本次使用的方法，在系统的环境变量中添加一条IDF_PATH。 添加其他编译参数完成上面步骤后，CLion会自动重新加载Cmake，完成后，我们就可以编译了。在右上角选择Cmake应用，按下编译按钮就可以编译。 但是我们还需要设置一些其他参数。 目标芯片 我们使用的ESP32S3芯片，因此我们需要在环境变量中添加IDF_TARGET=esp32s3.添加的位置如图所示： 添加menuconfig运行脚本到现在CLion还不能进行menuconfig等设置，这里我们可以使用Clion自带的终端进行操作。 首先。我们知道CLion默认的终端是powershell终端，在桌面上的idf启动文件实际上就是启动了一个终端，并且运行了IDF安装目录下面的Initialize-Idf.ps1脚本进行环境配置，因此我们只需要运行这个脚本就行。 在Clion界面点击右上角，点击编辑配置。 在弹出的窗口中，点击添加配置，添加脚本，选择脚本文本。在文本中填写以下内容： 点击确定保存。 之后可以在配置中选择menucofig运行，即可进行设置。由于不知道为什么方向键用不了，这里使用j,k建上下移动。 同理，可以用这种方式执行其他idf指令。 遇到的问题编译时，提示IDF_TARGET错误123IDF_TARGET in CMake cache does not match IDF_TARGET environment variable.To change the target, clear the build directory and sdkconfig file, andbuild the project again 这是环境变量中的IDF_TARGET(我们设置的)与工程中已有的Cmake变量(上次编译生成)不一样。 这时候，我们需要重新加载Cmake,选择重置缓存并重新加载CMake项目即可。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"Cmake","slug":"Cmake","permalink":"https://lostacnet.top/tags/Cmake/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"},{"name":"Clion","slug":"Clion","permalink":"https://lostacnet.top/tags/Clion/"}]},{"title":"ESP32下载FLASH模式配置","slug":"ESP32下载FLASH模式配置","date":"2023-09-16T09:10:55.000Z","updated":"2023-09-16T12:54:24.300Z","comments":true,"path":"post/91610/","link":"","permalink":"https://lostacnet.top/post/91610/","excerpt":"ESP32下载FLASH模式配置众所周知，ESP32的程序是下在外部的FLASH芯片中的，由于FLASH芯片的不同，下载使用的模式不同，需要根据芯片配置不同的FLASH下载模式。这里介绍一下不同的FLASH区别于配置。","text":"ESP32下载FLASH模式配置众所周知，ESP32的程序是下在外部的FLASH芯片中的，由于FLASH芯片的不同，下载使用的模式不同，需要根据芯片配置不同的FLASH下载模式。这里介绍一下不同的FLASH区别于配置。 FLASH工作模式的分类Flash常用的工作模式有以下4种： DUAL SPI 双线串行spi DOUT:地址为 1 线模式输入，数据为 2 线模式输出 DIO:地址为 2 线模式输入，数据为 2 线模式输出 Quad SPI 四线SPI QOUT:地址为 1 线模式输入，数据为 4 线模式输出 QIO:地址为 4 线模式输入，数据为 4 线模式输出 如何选择FLASH模式选择FLASH模式需要根据板子上实际的芯片进行设置，这就需要查找开发板的原理图或者模组的资料。 对于乐鑫的模组乐鑫的模组上会标NxRx，比如N8R2表示8MFlash与2Mpsram。 具体的模组使用的Flash，可以在相应模组的DATASHEET中找到。如在这里第三页，给出了相应的模块使用的Flash类型(Quad SPI)，在下载时注意要改成相应的Flash类型。 对于其他的开发板(以合宙为例)在开发板的资料中会给出。以合宙的ESP32-C3中，使用的Flash是W25Qxxx，是DUAL SPI 双线串行spi。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"},{"name":"FLASH","slug":"FLASH","permalink":"https://lostacnet.top/tags/FLASH/"}]},{"title":"谷歌浏览器crx无法拖拽安装","slug":"谷歌浏览器crx无法拖拽安装","date":"2023-09-11T17:03:53.000Z","updated":"2024-03-26T15:38:04.026Z","comments":true,"path":"post/91203/","link":"","permalink":"https://lostacnet.top/post/91203/","excerpt":"谷歌浏览器crx无法拖拽安装最近换用了谷歌浏览器，因为没有装插件导致不能IDM不能接管下载，发现crx拖拽无法安装，解决问题留档。","text":"谷歌浏览器crx无法拖拽安装最近换用了谷歌浏览器，因为没有装插件导致不能IDM不能接管下载，发现crx拖拽无法安装，解决问题留档。 问题描述将crx拖入插件界面后没有弹出安装框，而是弹出另存为窗口，打开开发者模式也没用。 解决方法这是浏览器的安全策略导致的。在浏览器地址栏输入: 1chrome://flags/#extensions-on-chrome-urls 将Extensions on chrome:// URLs项设为enable，重启后即可安装。","categories":[{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://lostacnet.top/tags/Chrome/"},{"name":"浏览器插件","slug":"浏览器插件","permalink":"https://lostacnet.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"}]},{"title":"STC52单片机的地址空间","slug":"STC52单片机的地址空间","date":"2023-09-06T17:28:48.000Z","updated":"2023-09-06T17:52:26.789Z","comments":true,"path":"post/9728/","link":"","permalink":"https://lostacnet.top/post/9728/","excerpt":"","text":"STC52单片机的地址空间51单片机的地址空间与STM32有着十分巨大的区别，在这里记录一下关于这方面的问题。本文的环境是Keil C51环境，使用STC89C52单片机。 栈空间SP指针与指向范围同其他单片机一样，51也有一个SP栈指针，但是**SP是向上增长的(与STM32不同)，并且SP只能指向内部RAM区(256B)**，即data(128B)和idata(128B)，是非常小的，在这之后是外部扩展的RAM区(xdata)，STC89C52单片机中这部分区域是”逻辑上扩展，物理上一体”，其实就是把储存芯片放到了封装内部吧。 硬件栈存在的问题我们都知道51资源少的可怜。 问题来了：当SP指向外部区后，会发送错误，重启。而内部空间在small模式下默认为变量优先存放区，但keil C51默认栈最小留1字节，当变量太多，留给栈的空间就十分的少。最后可能连进中断都会寄(进入中断需要16byte保存现场-地址和寄存器)。 模拟栈为了减少系统栈(SP的硬件栈)的使用，Keil C51默认所有函数都是不可重入的，局部变量使用固定的内存区，和static一样(正常都是存在栈里面的)。 当需要函数可重入时，使用 reentrant关键字标志，此时函数的局部变量储存在一个模拟栈，该栈由编译器维护，与SP无关，因此可以存在xdata区，可以很大，后果是访问速度可能慢了(具体看这个模拟栈所在区域)。","categories":[{"name":"51单片机学习笔记","slug":"51单片机学习笔记","permalink":"https://lostacnet.top/categories/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STC89C52","slug":"STC89C52","permalink":"https://lostacnet.top/tags/STC89C52/"},{"name":"堆栈","slug":"堆栈","permalink":"https://lostacnet.top/tags/%E5%A0%86%E6%A0%88/"},{"name":"寻址空间","slug":"寻址空间","permalink":"https://lostacnet.top/tags/%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4/"}]},{"title":"可重入函数与不可重入函数","slug":"可重入函数与不可重入函数","date":"2023-09-01T04:58:04.000Z","updated":"2023-09-16T08:18:46.741Z","comments":true,"path":"post/9158/","link":"","permalink":"https://lostacnet.top/post/9158/","excerpt":"可重入函数与不可重入函数今天在看51单片机的时候遇到一个名词:不可重入函数。听起来比较怪，故写一篇记录。","text":"可重入函数与不可重入函数今天在看51单片机的时候遇到一个名词:不可重入函数。听起来比较怪，故写一篇记录。 什么是不可重入函数不可重入函数就是执行过程中不能被中断的函数，该函数在被中断后重新再进入执行可能会发生问题，因此叫不可重入。反之，在这个函数执行的任何时刻可以中断进入其他代码，而返回时不会出现任何错误的函数就是可重入函数。 更加通俗一点，就是这个函数是不能被共享的，同一时间只能有一个任务在使用。 什么样的函数不可重入但一个函数满足一下条件时，是不可重入的： 函数内使用了静态(static)或全局变量 函数内调用了malloc()/free() 函数内调用了标准I/O函数 可见当函数内部使用了全局静态类型的东西时，就是不可重入。 为什么函数不可重入在多任务系统下，中断可能在任务执行的任何时间发生；如果一个函数的执行期间被中断后，到重新恢复到断点进行执行的过程中，函数所依赖的环境没有发生改变，那么这个函数就是可重入的，否则就不可重入。 而进入中断后，这些全局类型的东西可能在中断期间发生改变，那么当函数回到断点继续执行时，其结果就不可预料了。 如何预防 在函数体内不访问那些全局变量； 如果必须访问全局变量，记住利用互斥信号量来保护全局变量。或者调用该函数前关中断，调用后再开中断； 不使用静态局部变量； 不能调用任何不可重入的函数； 总之就是注意防止运行中静态/全局变量的改变。 在C51中的体现现在回到上面的问题。在C51中，由于没有硬件栈（？），为了提高程序的运行效率，所有局部变量存储在内存的固定位置(就像加了static)，因此所有函数都是不可重入函数。为了实现可重入，需要用一个模拟栈(运行效率低)来储存局部变量，因此需要使用reentrant来标出需要重入的函数。 1234int fun(char a,char b) reentrant//这样就是可重入的了{ return a+b;}","categories":[{"name":"c语言学习笔记","slug":"c语言学习笔记","permalink":"https://lostacnet.top/categories/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"},{"name":"中断","slug":"中断","permalink":"https://lostacnet.top/tags/%E4%B8%AD%E6%96%AD/"}]},{"title":"深入理解RISC-V-CH32V307的堆栈内存分配","slug":"深入理解CH32V307的堆栈内存分配","date":"2023-07-09T08:31:15.000Z","updated":"2024-03-10T08:17:10.189Z","comments":true,"path":"post/7931/","link":"","permalink":"https://lostacnet.top/post/7931/","excerpt":"","text":"深入理解CH32V307的堆栈内存分配在学习CH32V307的过程中，我发现其DVP例程中的图像缓冲区是直接用了SRAM中的一片内存地址，由于好奇直接使用这片地址为什么不会产生问题，故研究。最后学习了CH32V307堆栈的分配方式，以及修改堆栈空间大小的方法，学会大大扩展SRAM空间以及栈空间，防止爆栈。 一，芯片介绍官网在此CH32V307 不得不说这个片子给我带来了很多惊喜，让我学到了很多 我们看一下这个框图，主要关注一下FLASH与SRAM。 这里写的是256KB FLASH+64KB SRAM ，但实际上可以是（192K FLASH+128K SRAM）、（224K FLASH+96K SRAM）、（256K FLASH+64K SRAM）、（288K FLASH+32K SRAM）等和为320KB几种组合中的一种^1。 最大128KB，妈妈再也不用担心我内存不够用了 至于为什么是320KB，这篇文章中说： 其实赤菟V307内部有一块320 KB SRAM，分为A、B两块，A、B块的大小由用户选择字的user的SRAM_CODE_MODE 位决定，A块负责存放用户代码，B块留作单片机真正的SRAM，每次上电运行时，内部自动从Code Flash中加载A块大小的用户代码运行。 至于这段话在官方哪里说的，我没有找到。但结合用户手册中FLASH分为0等待和1等待区的描述，我认为这是正确的。(代码在SRAM中运行当然是0等待区) 二，配置方法通过MounRiver Studio(MRS)创建的工程默认是288K FLASH+32K SRAM的配置，将配置更改成其他有两种方式。 使用WCHLink下载器直接更改在MRS中的下载配置，或者WCHISP Studio中可以选择内存分配方式(ROM+RAM)。 改好后下次下载时就可以改变内存分配。 使用代码修改内存的分配方式在FLASH用户选择字寄存器中可以设置。 使用以下代码可以进行设置(来源于这篇文章)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061typedef enum{ FlASH_192_SRAM_128 = 0, FLASH_224_SRAM_96, FLASH_256_SRAM_64, FLASH_288_RAM_32} FLASH_SRAM_DEFIN;//note: this operation will take effect after resetvoid Config_Flash_SRAM(FLASH_SRAM_DEFIN SetFlashSRAM){ uint8_t UserByte = FLASH_GetUserOptionByte() &amp; 0xff; //get user option byte switch(SetFlashSRAM) { case 0: UserByte &amp;= ~(0xc0); // SRAM_CODE_MODE = 00 break; case 1: UserByte &amp;= ~(0xc0); // SRAM_CODE_MODE = 00 UserByte |= 0x7f; // SRAM_CODE_MODE = 01 break; case 2: UserByte &amp;= ~(0xc0); // SRAM_CODE_MODE = 00 UserByte |= 0xbf; // SRAM_CODE_MODE = 10 break; case 3: UserByte |= 0xff; // SRAM_CODE_MODE = 11 break; default: break; } FLASH_Unlock(); FLASH_ProgramOptionByteData(0x1ffff802, UserByte); FLASH_Lock();}/********************************************************************* * @fn main * * @brief Main program. * * @return none */int main(void){ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); Delay_Init(); USART_Printf_Init(115200); printf(\"SystemClk:%d\\r\\n\", SystemCoreClock); Config_Flash_SRAM(FLASH_288_RAM_32); //配置Flash为244 KB，SRAM为96KB ，复位后生效 printf(\"userByte = %02x \\r\\n\",FLASH_GetUserOptionByte() &amp; 0xff); while(1) { ; }} 修改LD文件更改了设置后，还需要修改Link.ld文件来重设程序的地址分配。 12345678910111213141516171819202122MEMORY{/* CH32V30x_D8C - CH32V305RB-CH32V305FB CH32V30x_D8 - CH32V303CB-CH32V303RB*//* FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 128K RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 32K*/ /* CH32V30x_D8C - CH32V307VC-CH32V307WC-CH32V307RC CH32V30x_D8 - CH32V303VC-CH32V303RC FLASH + RAM supports the following configuration FLASH-192K + RAM-128K FLASH-224K + RAM-96K FLASH-256K + RAM-64K FLASH-288K + RAM-32K *//* 在这里修改成设置的大小 */ FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 288K RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 32K} 修改栈大小同样的，在LD文件中可以修改栈大小,在LD文件的开头 12345ENTRY( _start )__stack_size = 2048;PROVIDE( _stack_size = __stack_size ); 其中修改__stack_size = 2048;就是栈大小，可以自行设置，但要注意不要设太大超过了占了其他数据区(这个下面讲)。 设置栈大小后，除开必要数据区，剩下了就全是堆区了，默认分配情况下你有19K左右的堆，也就是用malloc函数分配的区域，非常的浪费。 这个Link.ld文件就是这次的重头系，规划了储存器空间的分配。 通常，程序编译的最后一步就是链接，此过程根据“*.ld”链接文件将多个目标文件**(.o)和库文件(.a)输入文件链接成一个可执行输出文件(.elf)。涉及到对空间和地址的分配以及符号解析与重定位**。 而ld链接脚本控制这整个链接过程，主要用于规定各输入文件中的程序、数据等内容段在输出文件中的空间和地址如何分配。通俗的讲，链接脚本用于描述输入文件中的段，将其映射到输出文件中，并指定输出文件中的内存分配。 -ld链接脚本说明 关于CH32V307连接脚本的说明，可以参考这两篇文章，写的很好很详细。 RISC-V MCU CH32V307/CH32V203/CH32V003等 ld链接脚本说明 RISC-V MCU堆栈机制 本文大部分参考于这两篇文章。 三，内存空间分配方式在深入理解上面步骤是如何改变堆栈大小之前，我们需要先理解一下内存的分配方式。 通常，一个内存空间会被分为以下区域: Text:储存用户代码，为只读区，程序从FLASH读出后在此运行(这个片子中就是上面的A区)。 data:储存已初始化的全局变量，这里data的起始地址怎么配置都是0x20000000。 bss:储存未初始化的全局变量。 heap:堆区，malloc函数分配的动态区域。 stack:栈区，调用函数的传参空间。 在CH32V307中，text大小由设置配置，而bss与data则是由编译器编译后决定大小。最后剩下的区域就是堆栈区，栈区可以由用户配置大小。 在本芯片中，data端的起始地址就是设置的RAM的起始地址0x20000000,bss端的结束地址根据不同的用户程序决定，该地址后到RAM地址的结束都是堆栈区域，其中heap区从bss结束地址开始，向高地址增长，stac从RAM结束开始，向低地址增长。 当栈与堆重合，就爆栈了，会出现各种奇怪的东西。 四，连接脚本中对栈的设置在连接脚本的开头和结尾有关于栈的配置： 123456789101112131415161718192021ENTRY( _start )__stack_size = 2048;PROVIDE( _stack_size = __stack_size );............/*bss分配空间的代码*/... PROVIDE( _end = _ebss); PROVIDE( end = . ); .stack ORIGIN(RAM) + LENGTH(RAM) - __stack_size : { PROVIDE( _heap_end = . ); . = ALIGN(4); PROVIDE(_susrstack = . ); . = . + __stack_size; PROVIDE( _eusrstack = .); } &gt;RAM 这里解释几个符号： .:表示当前地址，随着分配区域递增，也可以进行运算改变 PROVIDE():定义全局变量 .stack:栈区分配设置 代码解读： 首先，PROVIDE( end = . );将当前地址（bss结束）赋给了end变量，这里就是heap的起始地址。 之后，.stack ORIGIN(RAM) + LENGTH(RAM) - __stack_size :将栈顶的地址给出，就是栈最大可以生长到的地址：RAM结束地址减去栈的大小。 PROVIDE( _heap_end = . ); 栈顶的地址同时也是堆结束的地址，这样堆的大小就确定了是：bss结束到栈顶。 PROVIDE(_susrstack = . );栈顶地址。 PROVIDE( _eusrstack = .);栈底地址，在上面的运算中其实就是ORIGIN(RAM) + LENGTH(RAM)。 至此，我们就明白了堆栈是怎么分配了，只需要修改__stack_size就可以设置栈大小了，默认RAM中除去data、bss、stack等剩余的都为heap空间。 通过访问end,_heap_end可以获得heap 的大小与地址。通过访问_susrstack,_eusrstack可以获得栈的大小和地址。 五，测试编写ld文件，修改成以下配置: 12345678__stack_size = 20K;.....MEMORY{ FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 192K RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 128K} 在main函数中编写; 1234567extern uint32_t _end;//堆起始地址extern uint32_t _eusrstack; /* 声明外部变量 _eusrstack */extern uint32_t _susrstack; /* 声明外部变量 _susrstack */ printf(\"heap start address = 0x%08x\\r\\n\",&amp;_end);//打印堆起始地址printf(\"stac start address = 0x%08x\\r\\n\",&amp;_eusrstack);//打印栈底地址printf(\"stac end address = 0x%08x\\r\\n\",&amp;_susrstack);//打印栈顶地址 获得以下输出： 123heap start address = 0x20002858stac start address = 0x20020000stac end address = 0x2001b000 将栈地址相减即使栈的大小，将堆地址与栈顶相减即可得到堆区大小。 六，疑问解释知道上面这些知识后，再反过来看开头的问题，就可以解释了。 首先是DVP缓冲区的地址: 12UINT32 JPEG_DVPDMAaddr0 = 0x20005000;UINT32 JPEG_DVPDMAaddr1 = 0x20005000 + OV2640_JPEG_WIDTH; 根据地址范围，我们发现，这就是在heap区随便来了一块区域，这样的话如果使用malloc的话就会导致问题。 什么sb配置完全不考虑例程在其他地方跑是吧 第二个疑惑就是为什么要在debug.c中重定义_sbrk. 12345678910111213141516171819/********************************************************************* * @fn _sbrk * * @brief Change the spatial position of data segment. * * @return size: Data length */__attribute__((used)) void *_sbrk(ptrdiff_t incr){ extern char _end[]; extern char _heap_end[]; static char *curbrk = _end; if ((curbrk + incr &lt; _end) || (curbrk + incr &gt; _heap_end)) return NULL - 1; curbrk += incr; return curbrk - incr;} heap只有起始地址，没有结束地址约束，这样最终会导致malloc永远都不会返回NULL 而定义_sbrk后，使用_heap_end变量就可以判断是否出现空间不足。","categories":[{"name":"CH32V307学习笔记","slug":"CH32V307学习笔记","permalink":"https://lostacnet.top/categories/CH32V307%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"堆栈","slug":"堆栈","permalink":"https://lostacnet.top/tags/%E5%A0%86%E6%A0%88/"},{"name":"CH32V307","slug":"CH32V307","permalink":"https://lostacnet.top/tags/CH32V307/"},{"name":"ld链接文件","slug":"ld链接文件","permalink":"https://lostacnet.top/tags/ld%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6/"},{"name":"内存分区","slug":"内存分区","permalink":"https://lostacnet.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"},{"name":"malloc","slug":"malloc","permalink":"https://lostacnet.top/tags/malloc/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://lostacnet.top/tags/RISC-V/"}]},{"title":"基于matlab的快速定位限速标志牌算法","slug":"基于matlab的快速定位限速标志牌算法","date":"2023-05-29T15:22:04.000Z","updated":"2024-03-26T15:37:08.770Z","comments":true,"path":"post/52922/","link":"","permalink":"https://lostacnet.top/post/52922/","excerpt":"基于matlab的快速定位限速标志牌算法数学实验的综合实验设计，要求使用matlab建立模型和算法，能够快速从图片中取出含有限速标志的图片区域。并截取保存为图片文件。 要求算法能够自动提取红色圆形图框区域。","text":"基于matlab的快速定位限速标志牌算法数学实验的综合实验设计，要求使用matlab建立模型和算法，能够快速从图片中取出含有限速标志的图片区域。并截取保存为图片文件。 要求算法能够自动提取红色圆形图框区域。 一，题目分析要定位限速标志，首先需要明白标志的特征，一个典型的限速标志如下： 该图像为一圈红色圆形区域中间包含黑色数字的形式组成，题目上要求能够自动提取红色圆形图框区域，那我们只需要想办法把这个圆弄出来。 那么基本思想如下： 提取出图像中的红色像素区域 找到这些像素区域中的圆 根据圆的位置对原图进行截图 对截取到的图片进行进一步判别 二，具体步骤首先亮出例程图： 图片的读取与转化首先需要对图片进行读取和转化。 使用imread(file)读取图像，该函数会返回RGB图像数组: 1image=imread('pic/include-80.png'); 由于RGB图像不易处理，这里需先转换为HSV图像。 关于RGB,HSV,HSL：三分钟带你快速学习RGB、HSV和HSL颜色空间 使用rgb2hsv(img)进行转化，该函数会返回一个MxNx3的数组，对应图像的H，S，V分量。 1234hsvImg=rgb2hsv(image);%转换到HSV空间h1=hsvImg(:,:,1);%H分量s1=hsvImg(:,:,2);%S分量v1=hsvImg(:,:,3);%V分量 之后，需要提取出其中的红色像素点。该步骤可以使用matlab数组运算和逻辑运算，判断HSV三个域中的每个像素点是否在红色像素点数值范围，是为1，否为0，最后将三个域的数组相与运算，就得到了只有红色像素位置信息图片，顺便还进行了图像的二值化。 12hsvReg1=((h1&lt;=0.056&amp;h1&gt;=0)|(h1&gt;=0.740&amp;h1&lt;=1.0)) &amp; s1&gt;=0.169&amp; s1&lt;=1.0 &amp;v1&gt;=0.180&amp;v1&lt;=1.0;%提取红色分量 figure;imshow(hsvReg1);title('原图hsv检测图像'); 得到的结果如下: 图像的降噪处理可以看到，此时图像已经可以十分清楚的看到圆环了。 之后需要对图像进行降噪处理，消除图像中像素点的很少的无效区域，便于之后对图像进行处理。 使用bwareaopen(BW,P)删除二值化图像BW中像素量少于P的所有连通分量。可以将像素少于P的色块区域删除。 12hsvReg1=bwareaopen(hsvReg1,110);%110为去除像素点阙值figure;imshow(hsvReg1);title('图像降噪结果'); 其中P的值需要根据实际情况进行选择，太大可能导致较小的图像被直接删没了，太大图像就会有很多杂点。 运行结果: 可以看到少了很多杂点。 填充平滑图像现在我们得到了包含各种色块的图像，由于我们使用圆度进行检测，因此需要让目标色块尽可能平滑饱满，跟圆长得更加接近，减少以下情况对识别的干扰： 首先需要填充图像内部的小黑点。这里使用闭运算imclose(I,SE)，使用结构元素 SE 对灰度或二值图像 I 执行形态学闭运算。形态学闭运算是先膨胀后腐蚀，这两种运算使用相同的结构元素。 这里补充一下关于图像开闭运算的知识： 膨胀：求局部最大值的操作 腐蚀：求局部最小值的操作 开运算imopen()：先腐蚀后膨胀称为开 (Open) 局部的区域大小和形状由SE指定。原图经过开运算后，去除孤立的小点，毛刺和小桥（即连通两块区域的小点），而总的位置和形状不变。 闭运算imclose()：先膨胀后腐蚀称为闭 (Close) 局部的区域大小和形状由SE指定。原图经过闭运算后，能够填平小湖（即小孔），弥合小缝隙，而总的位置和形状不变。 参考文章:开闭运算 imopen imclose SE可由函数strel()生成，该函数可以生成很多类型的平面元素结构，我们只需要使用SE = strel(\"disk\",r)盘型结构，其他结构可以参考官方文档。 对图像进行闭运算： 1234se=strel('disk',2);%半径为2hsvReg1=imclose(hsvReg1,se);hsvReg1=imfill(hsvReg1,'holes');figure;imshow(hsvReg1);title('图像填充平滑后结果'); 其中imfill(hsvReg1,'holes')填充了图像中的孔，即无法通过从图像边缘填充背景来到达的一组背景像素。结果是圆环变成圆。 划分连通区域该步骤将上图中的图块分别标记编号并求其边缘点。 使用函数[B,L]=bwboundaries(hsvReg1,'noholes')，该函数将图像上的连通域分别标记并记录边界点在cell类型的B中，在L中储存标记后的区域。 其中指定参数noholes将不会将hole作为新对象，而是将包括hole的整体作为一个整体。 1234567[B,L]=bwboundaries(hsvReg1,'noholes');figure;imshow(label2rgb(L,@jet,[.5 .5 .5]));%5hold on;for k=1:length(B) boundary=B{k}; plot(boundary(:,2),boundary(:,1),'w','LineWidth',2);end 处理结果： 区分了每个连通域及其边界。 计算连通域特性获得了不同连通域后，我们需要计算不同连通域的特性。 使用regionprops(BW,properties)进行计算，根据properties字符串计算标记好连通域的BW中不同连通域的不同特性，并返回结构体数组。 在该题中，我们依据图形的圆度判断是否为圆，因此我们需要求: Centroid:区域的质心，对应圆心 Area:实际的像素数，对应面积 Circularity:圆度，由(4*Area *pi)/(Perimeter^2)计算，由于matlab2017没有，因此直接求Perimeter Perimeter:围绕区域的边界，如果图像包含不连续区域，regionprops 将返回意外结果。(所以先填充平滑) 1stats=regionprops(L,'Area','Centroid','Perimeter'); 提取图形中的圆在该步骤中，我们遍历每一个连通域，求其圆度，保持圆度大于阈值threshold的连通域的圆心，半径(由周长计算)。 123456789101112131415threshold=0.88;%圆度的阈值cents={};%圆心rs=[];%周长stats=regionprops(L,'Area','Centroid','Perimeter');for k=1:length(B) area=stats(k).Area; perimeter=stats(k).Perimeter; Circularity=4*pi*area/perimeter^2;%计算圆度 if Circularity&gt;threshold cents{end+1}=stats(k).Centroid; r=perimeter/(2*pi); rs(end+1)=r; endend 裁剪图像获得圆心和半径后，我们可以计算出圆所在图像区域，使用imcrop(I,rect)进行裁剪。 rect是一个四元素数组，第一二个元素为矩形的左上角坐标，第三个元素是矩形的长，第四个是宽。 12345for i=1:length(cents) rect=[cents{i}(1)-rs(i) cents{i}(2)-rs(i) 2*rs(i) 2*rs(i)]; result=imcrop(image,rect); figure;imshow(result);title('图像裁剪结果');end 结果如下： 三，结论本方法使用提取红色像素进行二值化，通过对二值化图像找圆的方式找到原图中的红色圆形区域，以定位限速牌。由于使用圆度进行判断，判断方法较为单一，当阈值过大，会导致变形的限速牌无法识别，当阈值过小，一些图像则会被误识别，因此还需要进行改进，以获得更加准确的方案。 目前，可以考虑对裁剪后的图像进行文字识别OCR，如果有限速的数字则可以更为准确的判断。 四，代码附录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849image=imread('pic/include-80.png');% image=imread('pic/include-120-100.png');% image=imread('pic/1.png');threshold=0.95;%圆度的阈值%======= HSV颜色分割图像 =======%hsvImg=rgb2hsv(image);%转换到HSV空间h1=hsvImg(:,:,1);%H分量s1=hsvImg(:,:,2);%S分量v1=hsvImg(:,:,3);%V分量 hsvReg1=((h1&lt;=0.056&amp;h1&gt;=0)|(h1&gt;=0.740&amp;h1&lt;=1.0)) &amp; s1&gt;=0.169&amp; s1&lt;=1.0 &amp;v1&gt;=0.180&amp;v1&lt;=1.0;%提取红色分量 % figure;imshow(hsvReg1);title('原图hsv检测图像');%======= 降噪 =======%hsvReg1=bwareaopen(hsvReg1,110);%110为去除像素点阙值% figure;imshow(hsvReg1);title('图像降噪结果');%======= 填充平滑图像 =======%se=strel('disk',2);hsvReg1=imclose(hsvReg1,se);hsvReg1=imfill(hsvReg1,'holes');% figure;imshow(hsvReg1);title('图像填充平滑后结果');%======= 划分连通域 =======%[B,L]=bwboundaries(hsvReg1,'noholes');% figure;imshow(label2rgb(L,@jet,[.5 .5 .5]));%5% hold on;% for k=1:length(B)% boundary=B{k};% plot(boundary(:,2),boundary(:,1),'w','LineWidth',2);% end%======= 计算连通域特性 =======%cents={};%圆心rs=[];%周长stats=regionprops(L,'Area','Centroid','Perimeter');for k=1:length(B) area=stats(k).Area; perimeter=stats(k).Perimeter; Circularity=4*pi*area/perimeter^2;%计算圆度 if Circularity&gt;threshold cents{end+1}=stats(k).Centroid; r=perimeter/(2*pi); rs(end+1)=r; endend%======= 剪切保存图像 =======%for i=1:length(cents) rect=[cents{i}(1)-rs(i) cents{i}(2)-rs(i) 2*rs(i) 2*rs(i)]; result=imcrop(image,rect); figure;imshow(result);title('图像裁剪结果');end","categories":[{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://lostacnet.top/tags/matlab/"},{"name":"图像处理","slug":"图像处理","permalink":"https://lostacnet.top/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"FreeRTOS头文件引用顺序问题","slug":"FreeRTOS头文件引用顺序问题","date":"2023-05-25T17:45:45.000Z","updated":"2023-05-29T15:39:32.711Z","comments":true,"path":"post/52645/","link":"","permalink":"https://lostacnet.top/post/52645/","excerpt":"FreeRTOS头文件引用顺序问题今天在调ESPIDF时候遇到一个非常奇怪的问题。最后发现是关于FreeRTOS头文件的引用顺序导致的。困扰了好几个小时，这里记录。","text":"FreeRTOS头文件引用顺序问题今天在调ESPIDF时候遇到一个非常奇怪的问题。最后发现是关于FreeRTOS头文件的引用顺序导致的。困扰了好几个小时，这里记录。 问题描述今天在写ESP32IDF工程时，发现自己的头文件引用一直有问题，具体表现为交换两个头文件引用顺序会导致出现一大堆报错： 1234//错误的引用顺序#include \"my_event.h\"#include \"lvgl_port.h\" my_event.h 123456789101112#ifndef _MY_EVENT_H#define _MY_EVENT_H#include \"freertos/semphr.h\"//信号量#include \"freertos/FreeRTOS.h\"#include \"freertos/task.h\"extern SemaphoreHandle_t xGuiSemaphore;//GUI信号量防止多线程操作GUI#endif lvgl_port.h 12345678910111213141516#ifndef _LVGL_PORT_H#define _LVGL_PORT_H......#define LVGL_TICK_PERIOD_MS 2#include \"freertos/FreeRTOS.h\"#include \"esp_lcd_panel_io.h\" //IO口和电平定义设置#include \"hx8369.h\"//hx8369面板的创建......#endif //_LVGL_PORT_H 以这样的顺序引用会导致疯狂的报错： 6,直接蒙了。 结果是，工程里到处都是红标，完全无法定位错误在哪里。 问题解决经过我一点一点加改头文件，终于发现把那两个头文件引用顺序换一下就可以编译了（？？？？？什么玄学解决方法，我不服啊） 经过再深入查看所有引用的头文件，终于定位了问题： FreeRTOS.h 12345#ifndef INC_FREERTOS_H#define INC_FREERTOS_H.....#endif semphr.h 123#ifndef INC_FREERTOS_H #error \"include FreeRTOS.h\" must appear in source files before \"include semphr.h\"#endif 这个#error直接导致sempher.h必须要在FreeRTOS.h之后引用。 对于上面的问题，是因为在lvgl_port.h中已经包含了FreeRTOS.h所以能让后面不报错。 这个ERROR直接淹没在报错的汪洋大海中，根本定位不到！！！ 所以只要注意，使用FreeRTOS其他组件时，头文件必须在 FreeRTOS.h后引用。 后续为了弄明白为什么会有如此奇怪的设计，头文件都要按依赖顺序来引用，而不是顺便引用或者自动include依赖的头文件，我到官网找了一下发现如下回答： It is to make it more obvious what is going on - I have a personal preference not to include one header file from inside another because you can get yourself tied up on knots - but besides my preference formal coding standards (such as those for safety or security certifications) normally forbid nesting headers. In FreeRTOS there is one place where it can’t be avoided because you have to get the configuration file, portable header, and then the checks to see which configuration items are left undefined, all in the correct order. 原来是大佬的洁癖啊。 现在凌晨2点了，害。","categories":[{"name":"FreeRTOS学习笔记","slug":"FreeRTOS学习笔记","permalink":"https://lostacnet.top/categories/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"}]},{"title":"Clion移植LVGL模拟器","slug":"Clion移植LVGL模拟器","date":"2023-05-24T14:39:46.000Z","updated":"2023-09-16T16:46:59.380Z","comments":true,"path":"post/52439/","link":"","permalink":"https://lostacnet.top/post/52439/","excerpt":"Clion移植LVGL模拟器LVGL官方提供的模拟器方案是在Win上使用codeblock，但是其推荐的Linux上使用的vscode等一些项目是使用Cmake构建的，而Clion这这个超级好用而且学生免费的IDE又正好是使用Cmake作为构建工具的，理论是可以运行所有Cmake工程的。所以打算尝试将模拟器移植到Clion下。","text":"Clion移植LVGL模拟器LVGL官方提供的模拟器方案是在Win上使用codeblock，但是其推荐的Linux上使用的vscode等一些项目是使用Cmake构建的，而Clion这这个超级好用而且学生免费的IDE又正好是使用Cmake作为构建工具的，理论是可以运行所有Cmake工程的。所以打算尝试将模拟器移植到Clion下。 本文需要准备的环境： Clion：喷气机的C语言IDE，使用学生邮箱免费使用。已配置好Mingw的C语言环境。 SDL：一个C语言图形库，lvgl模拟器的依赖。官网，请自行下载SDL2-devel-xxx-mingw版本的压缩包。 lvgl：图形库仓库，这里使用v8.2版本。 lv_port_pc_eclipse：一个基于Cmake的模拟器仓库，本文的移植对象。 lv_drivers：lvgl在pc上的驱动库。 一，SDL库的安装由于pc的lvgl依赖于SDL库运行，这里需要先在Clion中添加SDL库。 解压SDL将下载的SDL库解压到一个文件夹，我下载的是SDL2-devel-2.26.5-mingw.zip，将压缩包解压，随便放一个地方。由于我们使用Cmake直接添加库文件，因此不需要设置环境变量之类（网上大都将SDL目录复制到了MinGW目录下，这样虽然方便添加，但会污染MinGW目录，不是很好）。记住x86_64-w64-mingw32目录的位置。 该目录如下： bin包含Dll动态链接库 include包含了头文件 lib包含了静态库文件 Tip：以下内容仅供学习，如需快速移植请直接到第二节 设置Cmake新建一个Clion工程，打开CMakeLists.txt,添加以下内容。 12345678910111213141516# 以下为工程设置，每个人不一样cmake_minimum_required(VERSION 3.22)project(test C)set(CMAKE_C_STANDARD 99)# 这里设置了一个变量，将上面要记住的目录保存到SDL2_DIRset(SDL2_DIR E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32)# 添加头文件地址include_directories(${SDL2_DIR}/include)# 添加库文件夹地址，添加dll文件夹和lib文件夹link_directories(${SDL2_DIR}/bin ${SDL2_DIR}/lib)add_executable(test main.c)# 设置test编译项目需要连接的库，注意顺序target_link_libraries(test mingw32 SDL2 SDL2main ) 在上面的代码中，需要使用link_directories()同时添加bin和lib这两个库文件搜索路径。 按道理说dll应该只需要在运行时在引用，在编译时不需要，只需要静态库文件，但这里如果不加bin就会在编译时报错，不知道为什么。 使用target_link_libraries()添加项目要使用的库文件，注意添加顺序，被依赖的库放在依赖它的库的后面，被优先编译。 这里需要注意，因为SDL2在引用头文件时，将用户的main重定义为了SDLmain进行了接管，因此如果把mingw放最先编译，可能直接找不到WinMain报错。 运行测试代码main.c 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include \"SDL2/SDL.h\"int main(int argc, char *argv[]) { // 初始化SDL SDL_Init(SDL_INIT_VIDEO); // 创建SDL窗口指针 SDL_Window *window = SDL_CreateWindow( \"SDL2Test\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 640, 480, 0 ); // 创建渲染器 SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE); // 设置渲染器 SDL_SetRenderDrawColor(renderer, 0, 0, 0, SDL_ALPHA_OPAQUE); SDL_RenderClear(renderer); // 渲染 SDL_RenderPresent(renderer); // 等待3000ms SDL_Delay(3000); // 销毁窗口&amp;退出 SDL_DestroyWindow(window); SDL_Quit(); return 0;} 测试效果为出现黑色窗口，几秒后结束。 可能的报错： 12345678910E:/Code_R/test/main.c: In function 'SDL_main':E:/Code_R/test/main.c:4:1: error: number of arguments doesn't match prototype 4 | int main() { | ^~~In file included from E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32/include/SDL2/SDL.h:32, from E:/Code_R/test/main.c:2:E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32/include/SDL2/SDL_main.h:155:29: error: prototype declaration 155 | extern SDLMAIN_DECLSPEC int SDL_main(int argc, char *argv[]); | ^~~~~~~~ninja: build stopped: subcommand failed. 这是由于SDL的接管机制，将main()如下重定义： 12#define main SDL_mainextern SDLMAIN_DECLSPEC int SDL_main(int argc, char *argv[]); 因此main函数必须为以下形式： 1int main(int argc, char *argv[]){} 可能的报错： 1undefined reference to `WinMain' 同样是SDL接管机制导致找不到main函数，这里是因为链接顺序问题导致包含真正main的SDL没有先编译。注意target_link_libraries()的顺序。 可能的报错： 12345678E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: /Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:73: undefined reference to `SDL_memcpy'E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: /Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:74: undefined reference to `SDL_free'E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: /Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:64: undefined reference to `SDL_wcslen'E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: /Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:64: undefined reference to `SDL_iconv_string'E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32/lib/libSDL2main.a(SDL_windows_main.o): in function `OutOfMemory':/Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:26: undefined reference to `SDL_ShowSimpleMessageBox'E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32/lib/libSDL2main.a(SDL_windows_main.o): in function `main_getcmdline':/Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:79: undefined reference to `SDL_SetMainReady' 没有添加bin路径或者link_directories中lib与bin顺序的问题（这个顺序是什么玄学问题）。 可能的问题： 1cannot find -lSDL2main link_directories没有添加lib. 可能成功编译但是运行失败，这是因为缺少dll库，将bin文件夹下的dll复制到exe目录下即可。 其他安装方法： 使用SDL库中.cmake文件，使用find_package(SDL2 REQUIRED SDL2) LVGL项目中使用这种方法。 二，移植lvgl模拟器将下载的lvgl库和lv_drivers分别放到lv_port_pc_eclipse中的相应文件夹，使用Clion打开项目。 此时应该会报错： 12345678910111213141516CMake Error at CMakeLists.txt:10 (find_package): By not providing \"FindSDL2.cmake\" in CMAKE_MODULE_PATH this project has asked CMake to find a package configuration file provided by \"SDL2\", but CMake did not find one. Could not find a package configuration file provided by \"SDL2\" with any of the following names: SDL2Config.cmake sdl2-config.cmake Add the installation prefix of \"SDL2\" to CMAKE_PREFIX_PATH or set \"SDL2_DIR\" to a directory containing one of the above files. If \"SDL2\" provides a separate development package or SDK, be sure it has been installed. 这是需要设置SDL2中SDL2Config.cmake和 sdl2-config.cmake文件所在目录。添加： 1SET(SDL2_DIR E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32/lib/cmake/SDL2) 可能报错： 1undefined reference to `SDL_main' 这是删除了SDL接管导致的，参考main.c的13行，注释掉这个行： 1#define SDL_MAIN_HANDLED /*To fix SDL's \"undefined reference to WinMain\" issue*/ 加了这个修复反而报错了，估计是linux与win的不同导致的。 之后将dll复制到生成的exe相同目录下。 直接运行就行了。 这里涉及到很多关于C语言编译过程的问题，需要补习很多知识。","categories":[{"name":"LVGL学习笔记","slug":"LVGL学习笔记","permalink":"https://lostacnet.top/categories/LVGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"lvgl","slug":"lvgl","permalink":"https://lostacnet.top/tags/lvgl/"},{"name":"SDL","slug":"SDL","permalink":"https://lostacnet.top/tags/SDL/"},{"name":"Clion","slug":"Clion","permalink":"https://lostacnet.top/tags/Clion/"}]},{"title":"ESP32-IDF组件找不到头文件而mian可以找到情况解决","slug":"ESP32-IDF组件找不到头文件而mian可以找到情况解决","date":"2023-05-14T12:14:59.000Z","updated":"2023-05-29T15:32:56.942Z","comments":true,"path":"post/51414/","link":"","permalink":"https://lostacnet.top/post/51414/","excerpt":"ESP32-IDF组件找不到头文件而mian可以找到情况解决今天学习IDF时出现了一个怪现象，明明一个头文件（库），在main.c中都可以引用并编译成功，而在组件中就找不到头文件，甚至在组件中可以点开打开该头文件，而编译时就是找不到。这里记录解决方法。","text":"ESP32-IDF组件找不到头文件而mian可以找到情况解决今天学习IDF时出现了一个怪现象，明明一个头文件（库），在main.c中都可以引用并编译成功，而在组件中就找不到头文件，甚至在组件中可以点开打开该头文件，而编译时就是找不到。这里记录解决方法。 问题分析这其实是组件依赖问题，引用该头文件确没有依赖这个库，自然就找不到头文件。而main组件在构建过程中自动依赖所有其他组件，因此可以直接使用，而其他组件只包含了通用组件依赖，因此就需要添加依赖了。 通用组件依赖。一下组件在使用时不需要添加依赖： cxx、newlib、freertos、esp_hw_support、heap、log、soc、hal、esp_rom、esp_common、esp_system。 添加依赖在idf_component_register()中的REQUIRES或者PRIV_REQUIRES中添加依赖。 如，要使用lcd，i2c，gpio，lvgl，esp_timer，就需要这样写: 1234idf_component_register(SRCS \"hx8369.c\" \"lvgl_port.c\" \"gt911.c\" INCLUDE_DIRS \"./include\" REQUIRES esp_lcd driver lvgl esp_timer)#i2c和GPIO包含在driver中","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"}]},{"title":"ESP32-IDF编译时出现undefined reference to function()","slug":"ESP32-IDF编译时出现undefined-reference-to-function","date":"2023-05-14T11:39:05.000Z","updated":"2023-05-29T15:32:19.594Z","comments":true,"path":"post/51439/","link":"","permalink":"https://lostacnet.top/post/51439/","excerpt":"ESP32-IDF编译时出现undefined reference to function()在编译ESP32项目时出现了奇怪的错误，在Link CXX executable test.elf时失败，并报错undefined reference to 'lv_demo_music'。是编译报错。这里记录解决方法。","text":"ESP32-IDF编译时出现undefined reference to function()在编译ESP32项目时出现了奇怪的错误，在Link CXX executable test.elf时失败，并报错undefined reference to 'lv_demo_music'。是编译报错。这里记录解决方法。 原因分析上面的报错意思很简单，其实就是虽然声明了这个函数(有头文件)，没有报错undeclare，但是由于**没有编译这个函数(没编译.c文件)**，导致编译器在链接的时候找不到。 这其实是CMake文件没有写好编译范围，导致没有将目标文件编译的原因。 解决方法解决方法也很简单，参考官方文档的构建系统。该文档中说明，可以使用SRCS SRC_DIRS指定要编译的文件，文件夹。 添加编译单个文件： 12idf_component_register(SRCS library/a.c library/b.c platform/platform.c ...) 添加编译包含多个文件的文件夹： 12idf_component_register(SRC_DIRS library platform ...) 后台会使用通配符在指定的目录中查找源文件。但是请注意，在使用这种方法的时候，如果组件中添加了一个新的源文件，CMake 并不知道重新运行配置，最终该文件也没有被加入构建中。这在使用命令行单步编译时需要注意。 问题解决我是在移植lvgl时出现的BUG，由于ESP公司是LVGl的合作伙伴，lvgl对ESP-IDF做了专门的适配，其直接克隆的仓库就可以做为一个组件使用。在项目CMakeList.txt中，可以看到这一行： 1include(${CMAKE_CURRENT_LIST_DIR}/env_support/cmake/esp.cmake)c 引用了env_support目录下的cmake文件,打开该文件。 123456789101112131415161718192021222324252627282930313233file(GLOB_RECURSE SOURCES ${LVGL_ROOT_DIR}/src/*.c)# ${LVGL_ROOT_DIR}/demos/*.c)idf_build_get_property(LV_MICROPYTHON LV_MICROPYTHON)if(LV_MICROPYTHON) idf_component_register( SRCS ${SOURCES} INCLUDE_DIRS ${LVGL_ROOT_DIR} ${LVGL_ROOT_DIR}/src ${LVGL_ROOT_DIR}/../ REQUIRES main) target_compile_definitions(${COMPONENT_LIB} INTERFACE \"-DLV_CONF_INCLUDE_SIMPLE\") if(CONFIG_LV_ATTRIBUTE_FAST_MEM_USE_IRAM) target_compile_definitions(${COMPONENT_LIB} INTERFACE \"-DLV_ATTRIBUTE_FAST_MEM=IRAM_ATTR\") endif()else() idf_component_register(SRCS ${SOURCES} INCLUDE_DIRS ${LVGL_ROOT_DIR} ${LVGL_ROOT_DIR}/src ${LVGL_ROOT_DIR}/../) target_compile_definitions(${COMPONENT_LIB} PUBLIC \"-DLV_CONF_INCLUDE_SIMPLE\") if(CONFIG_LV_ATTRIBUTE_FAST_MEM_USE_IRAM) target_compile_definitions(${COMPONENT_LIB} PUBLIC \"-DLV_ATTRIBUTE_FAST_MEM=IRAM_ATTR\") endif()endif() 可以看到，两次idf_component_register()使用的源文件为${SOURCES}，而该变量定义在： 1file(GLOB_RECURSE SOURCES ${LVGL_ROOT_DIR}/src/*.c) 可以看到，只编译了src文件夹，我们使用的函数在demos文件夹下，因此可以直接修改为 1file(GLOB_RECURSE SOURCES ${LVGL_ROOT_DIR}/src/*.c ${LVGL_ROOT_DIR}/demos/*.c) 重新编译，问题解决。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"c语言函数-containerof()","slug":"c语言函数-containerof","date":"2023-05-12T02:00:41.000Z","updated":"2023-05-29T15:30:57.014Z","comments":true,"path":"post/51200/","link":"","permalink":"https://lostacnet.top/post/51200/","excerpt":"c语言函数-containerof()今天在看ESP32库的源码时，发现了一个神奇的函数：__containerof()。可以从结构体成员的地址获得该结构体的地址，实现一种类似于找father的方法，故记录。","text":"c语言函数-containerof()今天在看ESP32库的源码时，发现了一个神奇的函数：__containerof()。可以从结构体成员的地址获得该结构体的地址，实现一种类似于找father的方法，故记录。 函数原型123#define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) 1#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) 函数作用函数实现的功能也很简单，用来已知成员的地址和名称以及该结构体的类型，求该结构体的地址。 分析该函数的核心步骤是： 1type的起始地址 = ptr - size (这里需要都转换为char *，因为它为单位字节) 其中的核心是size的获得。 1#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) 这里使用了0地址的用法。当一个0地址被强转为TYPE结构体的地址，那么它成员的地址就会变成该成员相对于结构体地址的偏移。(TYPE *)0)-&gt;MEMBER指向了成员，(size_t) &amp;((TYPE *)0)-&gt;MEMBER取了这个成员的地址并强转为size_t。 然后是这一看起来没有用的一行。 1const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); 这一行是用来提供警告的，如果传入的参数参数类型不一样（可能是传错了），这就会产生一个警告，帮助排查错误。 最后，有一个宏函数的返回问题。 123456789#define kaddr(addr)\\({\\int tmp = addr;\\if (addr &gt; 5) \\ tmp = 2;\\else\\ tmp = 3;\\(addr+tmp);\\})\\ 上述函数在最后一句不是一个完整的句子，而只有右值。该右值就会作为返回值返回。","categories":[{"name":"c语言学习笔记","slug":"c语言学习笔记","permalink":"https://lostacnet.top/categories/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"}]},{"title":"ESP-IDF在Vscode中Monitor出现乱码的解决","slug":"ESP-IDF在Vscode中Monitor出现乱码的解决","date":"2023-05-09T16:29:49.000Z","updated":"2023-05-29T15:38:26.932Z","comments":true,"path":"post/51029/","link":"","permalink":"https://lostacnet.top/post/51029/","excerpt":"ESP-IDF在Vscode中Monitor出现乱码的解决ESP-IDF的vscode插件在更新到v1.6.2后Monitor窗口出现乱码，无法监控程序的log，这里给出临时解决方法。","text":"ESP-IDF在Vscode中Monitor出现乱码的解决ESP-IDF的vscode插件在更新到v1.6.2后Monitor窗口出现乱码，无法监控程序的log，这里给出临时解决方法。 问题描述今天打开Vscode准备学学ESP32，然后发现下载烧录进去后Monitor窗口直接给我蹦出一大堆乱码。好家伙，我代码可是一点都没改啊。 查找问题像这种一看就是波特率出现了问题，我打开串口助手使用115200波特率可以正常收到信息，而Monitor打开串口的波特率设置是460800，那么这种一定板子上的波特率设置问题。 但是我找遍了SDK的菜单也没看见设置波特率的选项。无奈放弃。但是今天刷B站，大数据居然给我推了出现这个BUG的视频（该死的大数据），打开评论区，发现有人说github已经有issue了。我赶紧去看，果然有人遇到了和我一样的bug。并且已经有人给出了解决方法。 果然出现问题后第一步就应该去github下看看有没有issue。 解决方法issue 问题原因波特率不匹配问题。 ESP上设置的是115200，而监控器设置的是460800，因此出现问题。 这是由于v1.6.2设置了错误的初始波特率。 解决方案打开./.vscode/settings.json，在json中添加下列新键值对 1\"idf.monitorBaudRate\": \"115200\", 开发者已经回应，将在v1.6.3的插件中解决这个问题。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"vscode","slug":"vscode","permalink":"https://lostacnet.top/tags/vscode/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-并口LCD","slug":"ESP-IDF学习笔记-并口LCD","date":"2023-05-09T09:14:26.000Z","updated":"2023-05-29T15:35:56.387Z","comments":true,"path":"post/5914/","link":"","permalink":"https://lostacnet.top/post/5914/","excerpt":"ESP-IDF学习笔记-并口LCDESP32S3中提供了一堆外设，其中就包括LCD外设。该外设可以直接驱动屏幕，支持SPI，I2C，8080，RGB接口的屏幕。这与STM32不同（需要基于FSMC或者SPI写驱动），硬件完成了大部分操作。这里记录使用8080并口屏的方法，以及使用触摸作为输入。","text":"ESP-IDF学习笔记-并口LCDESP32S3中提供了一堆外设，其中就包括LCD外设。该外设可以直接驱动屏幕，支持SPI，I2C，8080，RGB接口的屏幕。这与STM32不同（需要基于FSMC或者SPI写驱动），硬件完成了大部分操作。这里记录使用8080并口屏的方法，以及使用触摸作为输入。 官方文档 一，配置步骤概览以8080总线驱动的HX8369A屏幕为例，ESP32中提供的API结构大概如下： 初始化总线1esp_lcd_new_i80_bus(); 使用该函数定义时钟源，D/C引脚，WR引脚，总线宽度(8/16)，数据引脚，单次最大传输数据量，DMA对齐参数。是对仅对8080总线的定义。 定义一个i80panel的IO1esp_lcd_new_panel_io_i80(); 在LCD驱动中，使用panel处理一个需要驱动的屏幕，需要我们去设置这个panel的io口。这个IO口是包含i80在内的片选等一个屏幕的io的合集。同时还定义了io口电平的含义(命令数据是高电平还是低电平等)，定义了屏幕的数据时钟速度，是否交换颜色数据字节，刷新完成回调(用于GUI)，命令长度和参数长度等定义。 创建一个panel1esp_lcd_new_panel_st7789() 在这一步创建一个面板句柄，绑定了特定的屏幕驱动芯片，设置reset脚，色域深度等。 初始化屏幕123esp_lcd_panel_reset(panel_handle);//在init前必须resetesp_lcd_panel_init(panel_handle); 这一步将初始化屏幕。 设置其他参数设置屏幕间隙，是否交换x/y轴等。 二，配置步骤这里使用HX8369A驱动的480*800屏幕，利用8线8080数据线驱动的屏幕。 初始化总线1esp_err_t esp_lcd_new_i80_bus(const esp_lcd_i80_bus_config_t *bus_config, esp_lcd_i80_bus_handle_t *ret_bus) 该函数创建了一个i80句柄(ret_bus)。输入参数： esp_lcd_i80_bus_config_t 12345678910typedef struct { int dc_gpio_num; //D/C线 int wr_gpio_num; //WR线 lcd_clock_source_t clk_src; //选择时钟源 int data_gpio_nums[SOC_LCD_I80_BUS_WIDTH]; //数据线数组 size_t bus_width; //设定数据线宽度, 8 or 16 size_t max_transfer_bytes; //最大传输长度，这里决定了内部DMA的传输长度 size_t psram_trans_align; //PSRAM中的数据，DMA使用的数据对齐长度 size_t sram_trans_align; //SRAM中的数据，DMA使用的数据对齐长度} esp_lcd_i80_bus_config_t; 其中： clk_src 时钟源选择。一般选择LCD_CLK_SRC_DEFAULT(LCD_CLK_SRC_PLL160M)。还可以选择LCD_CLK_SRC_PLL240M,LCD_CLK_SRC_XTAL。 max_transfer_bytes 决定了内部DMA的传输长度，一般为行的整数倍:EXAMPLE_LCD_H_RES * 100 * sizeof(uint16_t) psram_trans_align PRAM中使用的数据对齐，支持16，32，64。 Supported alignment: 16, 32, 64. A higher alignment can enables higher burst transfer size, thus a higher i80 bus throughput. sram_trans_align 一般为4 这个DMA对齐我还没搞明白，但应该是和STM32DMA设置中的字半字之类有关吧。 使用例： 12345678910111213141516171819202122232425262728293031 esp_lcd_i80_bus_handle_t i80_bus = NULL; esp_lcd_i80_bus_config_t bus_config = { .clk_src = LCD_CLK_SRC_DEFAULT, .dc_gpio_num = EXAMPLE_PIN_NUM_DC, .wr_gpio_num = EXAMPLE_PIN_NUM_PCLK, .data_gpio_nums = { EXAMPLE_PIN_NUM_DATA0, EXAMPLE_PIN_NUM_DATA1, EXAMPLE_PIN_NUM_DATA2, EXAMPLE_PIN_NUM_DATA3, EXAMPLE_PIN_NUM_DATA4, EXAMPLE_PIN_NUM_DATA5, EXAMPLE_PIN_NUM_DATA6, EXAMPLE_PIN_NUM_DATA7,#if CONFIG_EXAMPLE_LCD_I80_BUS_WIDTH &gt; 8 EXAMPLE_PIN_NUM_DATA8, EXAMPLE_PIN_NUM_DATA9, EXAMPLE_PIN_NUM_DATA10, EXAMPLE_PIN_NUM_DATA11, EXAMPLE_PIN_NUM_DATA12, EXAMPLE_PIN_NUM_DATA13, EXAMPLE_PIN_NUM_DATA14, EXAMPLE_PIN_NUM_DATA15,#endif }, .bus_width = CONFIG_EXAMPLE_LCD_I80_BUS_WIDTH, .max_transfer_bytes = 480 * 100 * sizeof(uint16_t), .psram_trans_align = 64, .sram_trans_align = 4, }; ESP_ERROR_CHECK(esp_lcd_new_i80_bus(&amp;bus_config, &amp;i80_bus)); 创建IO设备句柄1esp_err_t esp_lcd_new_panel_io_i80(esp_lcd_i80_bus_handle_t bus, const esp_lcd_panel_io_i80_config_t *io_config, esp_lcd_panel_io_handle_t *ret_io) 在i80总线的基础上创建IO句柄。 参数： bus esp_lcd_new_i80_bus()创建的句柄 ret_io 创建出来的句柄 io_config 12345678910111213141516171819202122typedef struct { int cs_gpio_num; /*!&lt; 片选线，设为-1不使用*/ uint32_t pclk_hz; /*!&lt; 像素时钟频率 */100ns size_t trans_queue_depth; /*!&lt; 传输队列长度，越大数据吞吐量越大 */ esp_lcd_panel_io_color_trans_done_cb_t on_color_trans_done; /*!&lt; 数据传输完成回调，用于GUI */ void *user_ctx; /*!&lt; 用户参数，传递给回调 on_color_trans_done's user_ctx */ int lcd_cmd_bits; /*!&lt; 命令的位数 */ int lcd_param_bits; /*!&lt; 参数的位数 */ struct { unsigned int dc_idle_level: 1; /*!&lt; 空闲时D/C的电平 */ unsigned int dc_cmd_level: 1; /*!&lt; 命令时D/C的电平 */ unsigned int dc_dummy_level: 1; /*!&lt; Level of DC line in DUMMY phase */ unsigned int dc_data_level: 1; /*!&lt; 数据时D/C的电平 */ } dc_levels; /*!&lt; 为每个8080定义自己的逻辑电平 */ struct { unsigned int cs_active_high: 1; /*!&lt; 片选有效电平 */ unsigned int reverse_color_bits: 1; /*!&lt; 是否反转bit, D[N:0] -&gt; D[0:N] */ unsigned int swap_color_bytes: 1; /*!&lt; 交换两个颜色字节 */ unsigned int pclk_active_neg: 1; /*!&lt; 是否使用wr下降沿传输数据 */ unsigned int pclk_idle_low: 1; /*!&lt; 空闲时wr的电平 */ } flags; /*!&lt; Panel IO config flags */} esp_lcd_panel_io_i80_config_t; 其中回调函数的模板： 12345678910typedef bool (*esp_lcd_panel_io_color_trans_done_cb_t)(esp_lcd_panel_io_handle_t panel_io, esp_lcd_panel_io_event_data_t *edata, void *user_ctx);//examplestatic bool example_notify_lvgl_flush_ready(esp_lcd_panel_io_handle_t panel_io, esp_lcd_panel_io_event_data_t *edata, void *user_ctx){ lv_disp_drv_t *disp_driver = (lv_disp_drv_t *)user_ctx; lv_disp_flush_ready(disp_driver); return false;} 例子： 12345678910111213141516171819202122#include \"esp_lcd_panel_io.h\"esp_lcd_panel_io_handle_t io_handle = NULL; esp_lcd_panel_io_i80_config_t io_config = { .cs_gpio_num = EXAMPLE_PIN_NUM_CS, .pclk_hz = EXAMPLE_LCD_PIXEL_CLOCK_HZ, .trans_queue_depth = 10, .dc_levels = { .dc_idle_level = 0, .dc_cmd_level = 0, .dc_dummy_level = 0, .dc_data_level = 1, }, .flags = { .swap_color_bytes = !LV_COLOR_16_SWAP, // Swap can be done in LvGL (default) or DMA }, .on_color_trans_done = example_notify_lvgl_flush_ready, .user_ctx = &amp;disp_drv, .lcd_cmd_bits = EXAMPLE_LCD_CMD_BITS, .lcd_param_bits = EXAMPLE_LCD_PARAM_BITS, }; ESP_ERROR_CHECK(esp_lcd_new_panel_io_i80(i80_bus, &amp;io_config, &amp;io_handle)); 创建panel句柄创建完IO句柄后，驱动知道了怎么发数据，但是还不知道发什么数据/命令。因此，需要一层驱动层。 使用如下命令创建面板。 1esp_err_t esp_lcd_new_panel_st7789(const esp_lcd_panel_io_handle_t io, const esp_lcd_panel_dev_config_t *panel_dev_config, esp_lcd_panel_handle_t *ret_panel) 创建了一个基于st7789的面板句柄。 io 上面创建的io句柄 ret_panel 创建出来的句柄 panel_dev_config 设置结构体 1234567891011121314#include \"esp_lcd_panel_vendor.h\"typedef struct { int reset_gpio_num; /*!&lt; reset引脚，使用-1为不使用 */ union { lcd_color_rgb_endian_t color_space; /*!&lt; @弃用 Set RGB color space, please use rgb_endian instead */ lcd_color_rgb_endian_t rgb_endian; /*!&lt; 颜色顺序，RGB或者BGR */ }; unsigned int bits_per_pixel; /*!&lt; 颜色深度, in bpp(bits per pixel) */ struct { unsigned int reset_active_high: 1; /*!&lt; 设置reset有效电平 */ } flags; /*!&lt; LCD panel config flags */ void *vendor_config; /*!&lt; vendor specific configuration, optional, left as NULL if not used */} esp_lcd_panel_dev_config_t; 其中： rgb_endian:LCD_RGB_ENDIAN_RGB/LCD_RGB_ENDIAN_BGR 例子: 12345678esp_lcd_panel_handle_t panel_handle = NULL;ESP_LOGI(TAG, \"Install LCD driver of st7789\");esp_lcd_panel_dev_config_t panel_config = { .reset_gpio_num = EXAMPLE_PIN_NUM_RST, .rgb_endian = LCD_RGB_ENDIAN_RGB, .bits_per_pixel = 16,};ESP_ERROR_CHECK(esp_lcd_new_panel_st7789(io_handle, &amp;panel_config, &amp;panel_handle)); 然而，这是ST7789的驱动，我这个sb开发板是hx8369A驱动的，这个在官方的库中没支持。（虽然官方也只支持了ST7789，nt35510,ssd1306），在esp的组件库中也没有。但是在例程中给的库lvgl_esp32_drivers中有这个芯片，在该库中实现了一个hx8396a的panel生成，我这个开发板的店家也是直接用的那里面的驱动，然后好像改成了8080发送数据。然后我问店家怎么移植，他直接说用这个，然后说他们不教这个？？？ 关于如果需要其他IC驱动的芯片（冷门的导致ESP官方没有支持的），需要自己添加驱动层代码，我会在另一篇文章细说。 调用函数初始化以下函数都实际在上面的panel中实现的。 1esp_err_t esp_lcd_panel_reset(esp_lcd_panel_handle_t panel); 重置屏幕，该函数需要在使用esp_lcd_panel_init()前被调用。 1esp_err_t esp_lcd_panel_init(esp_lcd_panel_handle_t panel); 初始化屏幕。 1esp_err_t esp_lcd_panel_mirror(esp_lcd_panel_handle_t panel, bool mirror_x, bool mirror_y); 在某个轴镜像屏幕。与esp_lcd_panel_swap_xy()协同使用。 1esp_err_t esp_lcd_panel_swap_xy(esp_lcd_panel_handle_t panel, bool swap_axes); 交换x/y轴。与esp_lcd_panel_mirror()协同使用。 1esp_err_t esp_lcd_panel_set_gap(esp_lcd_panel_handle_t panel, int x_gap, int y_gap) 设置x/y上的间隙（到边框的距离）。间隙是指液晶面板的左/顶部两侧分别与实际显示的第一行/列之间的空间（像素）。 当定位或对准比LCD小的框架时，设置间隙是很有用的。 1esp_err_t esp_lcd_panel_invert_color(esp_lcd_panel_handle_t panel, bool invert_color_data) 颜色反转。 1esp_err_t esp_lcd_panel_disp_on_off(esp_lcd_panel_handle_t panel, bool on_off) 打开或者关闭显示。 例子: 123456789#include \"esp_lcd_panel_ops.h\" esp_lcd_panel_reset(panel_handle); esp_lcd_panel_init(panel_handle); // Set inversion, x/y coordinate order, x/y mirror according to your LCD module spec // the gap is LCD panel specific, even panels with the same driver IC, can have different gap value esp_lcd_panel_invert_color(panel_handle, true); esp_lcd_panel_set_gap(panel_handle, 0, 20); 三，使用屏幕ESP库提供了最基础的画点函数。 1esp_err_t esp_lcd_panel_draw_bitmap(esp_lcd_panel_handle_t panel, int x_start, int y_start, int x_end, int y_end, const void *color_data) 一个窗口中绘制像素点。 Tips:start点被包含而end点没有被包含。 当初始化化完IO句柄后，其实已经可以实现发送和接收数据来驱动屏幕了，后面不过是封装了特定的驱动。 1esp_err_t esp_lcd_panel_io_rx_param(esp_lcd_panel_io_handle_t io, int lcd_cmd, void *param, size_t param_size) 发送命令并接收参数。 1esp_err_t esp_lcd_panel_io_tx_param(esp_lcd_panel_io_handle_t io, int lcd_cmd, const void *param, size_t param_size) 发送命令和参数。 1esp_err_t esp_lcd_panel_io_tx_color(esp_lcd_panel_io_handle_t io, int lcd_cmd, const void *color, size_t color_size) 发送颜色数据。 这个函数将要发送的数据加入到后台队列，由DMA+中断发送。 由于有缓存时间存在，因此需要回调处理数据的生命周期。 四，SDKconfig中的设置在LCD and Touch Panel---&gt;LCD Peripheral Configuration中，需要注意这样一个设置LCD panel io foramt buffer size。该参数的值与io层单次最大发送数据量param_size有关，如果该值设置过小，会导致发送时报错。 在本人移植驱动过程中，由于没有设置该值，导致在初始化时在下面函数中报错 1esp_lcd_panel_io_tx_param(io, 0x2D, cmd_192,192); 192超过了默认值大小，导致报错。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-MQTT客户端","slug":"ESP-IDF学习笔记-MQTT客户端","date":"2023-05-03T07:49:05.000Z","updated":"2023-05-29T15:34:17.208Z","comments":true,"path":"post/5349/","link":"","permalink":"https://lostacnet.top/post/5349/","excerpt":"","text":"先上官方文档 参考文献 一，MQTT协议的简介网上很多这里不作讲解，参考这篇文章 二，ESP_MQTT的配置过程ESP_MQTT实现了MQTT客户端的功能，支持多种协议，这里仅以TCp为例。基本步骤如下; 使用esp_mqtt_client_init()配置mqtt。 使用esp_mqtt_client_register_event()注册事件处理函数。 使用esp_mqtt_client_start()开启mqtt客户端。 MQTT的运行与WiFi类似，都是基于事件进行处理。但是，WiFi库是基于ESP_EVENT库而MQTT库则是使用的内建的事件处理循环。 初始化MQTT1esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config); 使用该函数初始化MQTT客户端，并创建MQTT客户端句柄。 esp_mqtt_client_config_t 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110typedef struct esp_mqtt_client_config_t { /** * Broker 相关设置 */ struct broker_t { /** * Broker address * * - uri 优先于其他字段 * - 如果uri没有设置，至少hostname, transport and port 应该被设置. */ struct address_t { const char *uri; /*!&lt; 完整的 *MQTT* broker URI */ const char *hostname; /*!&lt; Hostname, to set ipv4 pass it as string) */ esp_mqtt_transport_t transport; /*!&lt; 选择协议类型*/ const char *path; /*!&lt; Path in the URI*/ uint32_t port; /*!&lt; *MQTT* server port */ } address; /*!&lt; Broker地址设置 */ /** * Broker 的身份验证 * * 如果不设置这部分，将不会验证Broker的身份，为安全考虑建议设置验证 */ struct verification_t { bool use_global_ca_store; /*!&lt; 是否使用全局 ca_store, 详见 esp-tls文档*/ esp_err_t (*crt_bundle_attach)(void *conf); /*!&lt; Pointer to ESP x509 Certificate Bundle attach function for the usage of certificate bundles. */ const char *certificate; /*!&lt; 证书数据，默认为NULL，验证服务器时不需要. */ size_t certificate_len; /*!&lt; 证书数据长度 */ const struct psk_key_hint *psk_hint_key; /*!&lt; 指向esp_tls.h中定义的PSK结构的指针，以启用PSK 认证（作为证书验证的替代）. 只有当没有其他验证方式时启用*/ bool skip_cert_common_name_check; /*!&lt; 跳过对服务器证书CN字段的任何验证，这降低了TLS的安全性，使*MQTT*客户端容易受到MITM攻击 */ const char **alpn_protos; /*!&lt; 用于ALPN的以NULL为结尾的支持应用协议列表 */ } verification; /*!&lt; broker的身份验证 */ } broker; /*!&lt; Broker 地址和验证信息 */ /** * Client related credentials for authentication. */ struct credentials_t { const char *username; /*!&lt; *MQTT* 用户名*/ const char *client_id; /*!&lt; 设置 *MQTT* 客户端ID. 如果 set_null_client_id == true 忽略. 如果是NULL则为默认设置. Default client id is ``ESP32_%CHIPID%`` where `%CHIPID%` are last 3 bytes of MAC address in hex format */ bool set_null_client_id; /*!&lt; 用户ID是否为NULL */ /** * 客户端验证 * * 对于使用TLS的相互认证，用户可以选择证书和密钥, * 安全认证信息（如果设置了）. * */ struct authentication_t { const char *password; /*!&lt; *MQTT* 密码 */ const char *certificate; /*!&lt; ssl认证的证书, 需要与key一起提供.如果没有验证则不需要*/ size_t certificate_len; /*!&lt; 证书的长度.*/ const char *key; /*!&lt; ssl认证的私钥，需要与证书一起提供，如果没有验证则不需要*/ size_t key_len; /*!&lt; key的长度.*/ const char *key_password; /*!&lt; 客户端密钥解密密码，不是PEM也不是DER, 如果提供，len也必须正确提供. */ int key_password_len; /*!&lt; `key_password`的长度 */ bool use_secure_element; /*!&lt; 启用安全元素，在ESP32-ROOM-32SE中可用，用于SSL连接。 */ void *ds_data; /*!&lt; 数字签名，数字签名外设在一些Espressif设备中是可用的。 */ } authentication; /*!&lt; 用户验证信息 */ } credentials; /*!&lt; 用户验证信息 */ /** * *MQTT* 会话相关设置 */ struct session_t { /** * 遗嘱设置. */ struct last_will_t { const char *topic; /*!&lt; 遗嘱消息的主题 */ const char *msg; /*!&lt; 遗嘱消息，以NULL空字符结尾*/ int msg_len; /*!&lt; 遗嘱长度，如果msg不以NULL结尾，需要设置正确长度 */ int qos; /*!&lt; 遗嘱消息质量 */ int retain; /*!&lt; 遗嘱保留标志 */ } last_will; /*!&lt; 遗嘱设置 */ bool disable_clean_session; /*!&lt; *MQTT* 持久会话设置， */ int keepalive; /*!&lt; *MQTT* keepalive时间, 默认 120 seconds */ bool disable_keepalive; /*!&lt; 设置 `disable_keepalive=true` 来关闭 keep-alive, keepalive 默认开启. Note: 设置keepalive为0不会关闭keepalive，而是使用默认的时间长度 */ esp_mqtt_protocol_ver_t protocol_ver; /*!&lt; *MQTT* 使用的协议版本.*/ int message_retransmit_timeout; /*!&lt; 重传超时时间 */ } session; /*!&lt; *MQTT* 会话设置. */ /** * 网络相关设置 */ struct network_t { int reconnect_timeout_ms; /*!&lt; 断开连接后重新自动连接到broker间隔的时间，默认为10s*/ int timeout_ms; /*!&lt; 网络操作超时时间，默认10s. */ int refresh_connection_after_ms; /*!&lt; 刷新连接事件间隔 */ bool disable_auto_reconnect; /*!&lt; 设置为true关闭自动重连 */ } network; /*!&lt; 网络设置 */ /** * 客户端任务设置 */ struct task_t { int priority; /*!&lt; *MQTT* 任务优先级*/ int stack_size; /*!&lt; *MQTT* 任务栈大小*/ } task; /*!&lt; FreeRTOS 任务设置.*/ /** * Client 用户缓冲区大小设置 * * Client 有两个缓冲区：输入和输出缓冲区 */ struct buffer_t { int size; /*!&lt; size of *MQTT* send/receive buffer*/ int out_size; /*!&lt; size of *MQTT* output buffer. If not defined, defaults to the size defined by ``buffer_size`` */ } buffer; /*!&lt; Buffer size configuration.*/} esp_mqtt_client_config_t; 使用 uri 字段的格式为 scheme://hostname:port/path 当前支持 mqtt、mqtts、ws 和 wss 协议 基于 TCP 的 MQTT 示例： mqtt://mqtt.eclipseprojects.io：基于 TCP 的 MQTT，默认端口 1883 mqtt://mqtt.eclipseprojects.io:1884：基于 TCP 的 MQTT，端口 1884 mqtt://username:password@mqtt.eclipseprojects.io:1884：基于 TCP 的 MQTT， 端口 1884，带有用户名和密码 基于 SSL 的 MQTT 示例： mqtts://mqtt.eclipseprojects.io：基于 SSL 的 MQTT，端口 8883 mqtts://mqtt.eclipseprojects.io:8884：基于 SSL 的 MQTT，端口 8884 基于 WebSocket 的 MQTT 示例： ws://mqtt.eclipseprojects.io:80/mqtt 基于 WebSocket Secure 的 MQTT 示例： wss://mqtt.eclipseprojects.io:443/mqtt 客户端凭据 credentials 字段下包含所有客户端相关凭据。 username：指向用于连接服务器用户名的指针，也可通过 URI 设置 client_id：指向客户端 ID 的指针，默认为 ESP32_%CHIPID%，其中 %CHIPID% 是十六进制 MAC 地址的最后 3 个字节 认证 可以通过 authentication 字段设置认证参数。客户端支持以下认证方式： password：使用密码 certificate 和 key：进行双向 TLS 身份验证，PEM 或 DER 格式均可 use_secure_element：使用 ESP32-WROOM-32SE 中的安全元素 ds_data：使用某些乐鑫设备的数字签名外设 MQTT 协议中的 Keep Alive 机制 MQTT 协议是承载于 TCP 协议之上的，而 TCP 协议以连接为导向，在连接双方之间，提供稳定、有序的字节流功能。 但是，在部分情况下，TCP 可能出现半连接问题。所谓半连接，是指某一方的连接已经断开或者没有建立，而另外一方的连接却依然维持着。在这种情况下，半连接的一方可能会持续不断地向对端发送数据，而显然这些数据永远到达不了对端。为了避免半连接导致的通信黑洞，MQTT 协议提供了 Keep Alive 机制，使客户端和 MQTT 服务器可以判定当前是否存在半连接问题，从而关闭对应连接。 MQTT持久会话与Clean Session详解 MQTT客户端在发起服务器连接时，可以设置是否创建一个持久会话。但Clean Session为true，指在创建一个新的会话时，在客户端断开连接时会话会自动销毁，为false时，在客户端断开连接时会话仍然保持，直到其重新连接或者会话超时注销。 持久会话可以避免因网络中断导致的重复订阅或者错过离线期间的消息。 注册事件函数1esp_err_t esp_mqtt_client_register_event(esp_mqtt_client_handle_t client, esp_mqtt_event_id_t event, esp_event_handler_t event_handler, void *event_handler_arg) 使用该函数注册事件处理函数。该事件处理的用法与esp_event库相似。 一个标准的事件处理模板为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * @brief Event handler registered to receive MQTT events * * This function is called by the MQTT client event loop. * * @param handler_args user data registered to the event. * @param base Event base for the handler(always MQTT Base in this example). * @param event_id The id for the received event. * @param event_data The data for the event, esp_mqtt_event_handle_t. */static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data){ ESP_LOGD(TAG, \"Event dispatched from event loop base=%s, event_id=%d\", base, event_id); esp_mqtt_event_handle_t event = event_data; esp_mqtt_client_handle_t client = event-&gt;client; int msg_id; switch ((esp_mqtt_event_id_t)event_id) { case MQTT_EVENT_CONNECTED: ESP_LOGI(TAG, \"MQTT_EVENT_CONNECTED\"); msg_id = esp_mqtt_client_publish(client, \"/topic/qos1\", \"data_3\", 0, 1, 0); ESP_LOGI(TAG, \"sent publish successful, msg_id=%d\", msg_id); msg_id = esp_mqtt_client_subscribe(client, \"/topic/qos0\", 0); ESP_LOGI(TAG, \"sent subscribe successful, msg_id=%d\", msg_id); msg_id = esp_mqtt_client_subscribe(client, \"/topic/qos1\", 1); ESP_LOGI(TAG, \"sent subscribe successful, msg_id=%d\", msg_id); msg_id = esp_mqtt_client_unsubscribe(client, \"/topic/qos1\"); ESP_LOGI(TAG, \"sent unsubscribe successful, msg_id=%d\", msg_id); break; case MQTT_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"MQTT_EVENT_DISCONNECTED\"); break; case MQTT_EVENT_SUBSCRIBED: ESP_LOGI(TAG, \"MQTT_EVENT_SUBSCRIBED, msg_id=%d\", event-&gt;msg_id); msg_id = esp_mqtt_client_publish(client, \"/topic/qos0\", \"data\", 0, 0, 0); ESP_LOGI(TAG, \"sent publish successful, msg_id=%d\", msg_id); break; case MQTT_EVENT_UNSUBSCRIBED: ESP_LOGI(TAG, \"MQTT_EVENT_UNSUBSCRIBED, msg_id=%d\", event-&gt;msg_id); break; case MQTT_EVENT_PUBLISHED: ESP_LOGI(TAG, \"MQTT_EVENT_PUBLISHED, msg_id=%d\", event-&gt;msg_id); break; case MQTT_EVENT_DATA: ESP_LOGI(TAG, \"MQTT_EVENT_DATA\"); printf(\"TOPIC=%.*s\\r\\n\", event-&gt;topic_len, event-&gt;topic); printf(\"DATA=%.*s\\r\\n\", event-&gt;data_len, event-&gt;data); break; case MQTT_EVENT_ERROR: ESP_LOGI(TAG, \"MQTT_EVENT_ERROR\"); if (event-&gt;error_handle-&gt;error_type == MQTT_ERROR_TYPE_TCP_TRANSPORT) { log_error_if_nonzero(\"reported from esp-tls\", event-&gt;error_handle-&gt;esp_tls_last_esp_err); log_error_if_nonzero(\"reported from tls stack\", event-&gt;error_handle-&gt;esp_tls_stack_err); log_error_if_nonzero(\"captured as transport's socket errno\", event-&gt;error_handle-&gt;esp_transport_sock_errno); ESP_LOGI(TAG, \"Last errno string (%s)\", strerror(event-&gt;error_handle-&gt;esp_transport_sock_errno)); } break; default: ESP_LOGI(TAG, \"Other event id:%d\", event-&gt;event_id); break; }}//示例注册函数esp_mqtt_client_register_event(client, ESP_EVENT_ANY_ID, mqtt_event_handler, NULL); 开始MQTT客户端1esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client); 开启MQTT客户端服务。 订阅/取消订阅1int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) 将客户端订阅到定义的主题，并定义了QOS。需要在连接服务器后进行。 1int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) 取消订阅。 发布内容ESP提供了两种发布内容的方法，阻塞式和非阻塞。 1int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain); 阻塞式发布一个消息。超时时间为config中的网络超时时间。使用这个API不需要先连接到服务器，此时消息会自动加入后台队列(如果设置了MQTT_SKIP_PUBLISH_IF_DISCONNECTED为true，则不会尝试发送而是直接返回-1) 1int esp_mqtt_client_enqueue(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain, bool store) 将信息排队到outbox，以便稍后发送。通常用于qos&gt;0的消息，但如果store=true，也可用于qos=0的消息。 这个API生成并存储发布消息到内部的outbox中，而实际发送至网络是在mqtt任务中进行的（与esp_mqtt_client_publish()相反，后者在用户任务的任务中立即发送发布消息）。因此，它可以作为esp_mqtt_client_publish()的一个非阻塞版本。 QOS服务质量 QoS0，At most once，至多一次,Sender 发送的一条消息，Receiver 最多能收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，也就算了； QoS1，At least once，至少一次,Sender 发送的一条消息，Receiver 至少能收到一次，也就是说 Sender 向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，但是因为重传的原因，Receiver 有可能会收到重复的消息； QoS2，Exactly once，确保只有一次,Sender 发送的一条消息，Receiver 确保能收到而且只收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，同时保证 Receiver 不会因为消息重传而收到重复的消息。 当我们使用MQTT客户端发布消息（PUBLISH）时，如果将RETAIN标志位设置为true，那么MQTT服务器会将最近收到的一条RETAIN标志位为true的消息保存在服务器端（内存或文件）。特别注意：MQTT服务器只会为每一个Topic保存最近收到的一条RETAIN标志位为true的消息！也就是说，如果MQTT服务器上已经为某个Topic保存了一条Retained消息，当客户端再次发布一条新的Retained消息，那么服务器上原来的那条消息会被覆盖！ 每当MQTT客户端连接到MQTT服务器并订阅了某个topic，如果该topic下有Retained消息，那么MQTT服务器会立即向客户端推送该条Retained消息。 如果客户端想让MQTT服务器删除某个Topic下保存的Retained消息，唯一的方法是向MQTT服务器发布一条RETAIN标志位为true的空消息。空消息即为发布消息（PUBLISH）的时候，Payload中设置0个字节的内容。删除了某个Topic下保存的Retained消息，如果客户端没有再发布Retained消息，则MQTT服务器上对于该Topic就没有了Retained消息。 其他API1esp_err_t esp_mqtt_client_set_uri(esp_mqtt_client_handle_t client, const char *uri); 更新uri。 1esp_err_t esp_mqtt_client_reconnect(esp_mqtt_client_handle_t client); 手动重新连接。 1esp_err_t esp_mqtt_client_disconnect(esp_mqtt_client_handle_t client); 手动断连。 1esp_err_t esp_mqtt_set_config(esp_mqtt_client_handle_t client, const esp_mqtt_client_config_t *config); 更新设置，在MQTT_EVENT_BEFORE_CONNECT前。 三，其他参考事件参考User event handler receives context data in esp_mqtt_event_t structure with client - MQTT client handle various other data depending on event type MQTT_EVENT_ANY MQTT_EVENT_ERROR 在错误事件中，额外的上下文：连接返回代码，来自esp_tls的错误处理（如果支持） MQTT_EVENT_CONNECTED connected event, additional context: session_present flag MQTT_EVENT_DISCONNECTED disconnected event MQTT_EVENT_SUBSCRIBED subscribed event, additional context: msg_id message id error_handle error_type in case subscribing failed data pointer to broker response, check for errors. data_len length of the data for this event MQTT_EVENT_UNSUBSCRIBED unsubscribed event, additional context: msg_id MQTT_EVENT_PUBLISHED published event, additional context: msg_id MQTT_EVENT_DATA data event, additional context: msg_id message id topic pointer to the received topic topic_len length of the topic data pointer to the received data data_len length of the data for this event current_data_offset offset of the current data for this event total_data_len total length of the data received retain retain flag of the message qos QoS level of the message dup dup flag of the message Note: Multiple MQTT_EVENT_DATA could be fired for one message, if it is longer than internal buffer. In that case only first event contains topic pointer and length, other contain data only with current data length and current data offset updating. MQTT_EVENT_BEFORE_CONNECT The event occurs before connecting MQTT_EVENT_DELETED Notification on delete of one message from the internal outbox, if the message couldn’t have been sent and acknowledged before expiring defined in OUTBOX_EXPIRED_TIMEOUT_MS. (events are not posted upon deletion of successfully acknowledged messages) This event id is posted only if MQTT_REPORT_DELETED_MESSAGES==1 Additional context: msg_id (id of the deleted message). MQTT_USER_EVENT Custom event used to queue tasks into mqtt event handler All fields from the esp_mqtt_event_t type could be used to pass an additional context data to the handler.","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"},{"name":"MQTT","slug":"MQTT","permalink":"https://lostacnet.top/tags/MQTT/"}]},{"title":"ESP-IDF学习笔记-WIFI连接","slug":"ESP-IDF学习笔记-WIFI连接","date":"2023-04-29T14:52:41.000Z","updated":"2023-05-29T15:35:27.952Z","comments":true,"path":"post/42952/","link":"","permalink":"https://lostacnet.top/post/42952/","excerpt":"ESP-IDF学习笔记-WIFI连接使用ESP32的WIFI需要使用3个库的API，涉及NVS_FLASH，ESP_NETIF,ESP_WIFI,ESP_EVENT。nvs保存配置，netif提供tcp/ip操作接口，wifi库提供wiif的配置接口。","text":"ESP-IDF学习笔记-WIFI连接使用ESP32的WIFI需要使用3个库的API，涉及NVS_FLASH，ESP_NETIF,ESP_WIFI,ESP_EVENT。nvs保存配置，netif提供tcp/ip操作接口，wifi库提供wiif的配置接口。 首先提供一下官方文档： 非易失存储库 WIFI库 ESP-NETIF ESP_EVENT 还有描述整个WiFi编程结构的指南(非常关键的指南，放在了API指南里，要不是我搜一个函数我还找不到)： WIFI驱动指南 一，配置步骤概览初始化NVS NVS（非易失存储库）是ESP32分区中用来储存少量需要掉电保存的数据的分区（如果数据量很大，需要储存在文件系统的分区中）。在WIFI的配置中，该区存储了WIFI的设置，包扩上次连接的WIFI信息，上次开启的热点信息等配置信息（在设置wifi时自动储存）。因此，为了实现WiFi记忆功能，在使用WIFI前，需要先初始化NVS。如果不初始化，需要在每次运行时重新配置WiFi。 创建ESP-NETIF工作 ESP-NETIF库**提供了tcp/ip操作的相关接口(Lwip)**，与wifi驱动接口绑定后，可以处理tcp/ip的各种事务，包括DHCP等各种操作。为了使我们的WIFI能够正常联网，我们需要创建一个ESP-NETIF工作。 设置WIFI WIFI库提供了操作WIFI的驱动，包括设置站点模式，配置WiFi信息，连接WIFI等操作。 事件循环 事件循环是ESPIDF提供的用于不同组件交流操作的库。一个组件可以创建事件，另外一个组件可以通过注册事件函数响应相应的事件。通过事件循环，各个库可以协同运行。其典型例子就是使用与WIFI库有关的组件时，比如使用DHCP获取IP地址，需要在WIFI库成功连接到WIFI之后，而DHCP的实现是高层库做的，因此就需要通过事件来通知其他组件WIFI已经连接，DHCP库通过将自己的函数注册成相应事件的处理函数，就可以实现协同运行。 二，具体配置流程初始化NVS首先在设置菜单中将WIFI选项中的WiFi NVS flash选中，使能WiFi_NVS_FLASH。让wifi设置能保存在NVS中。 这里直接给出代码，感兴趣可以看官方文档。 123456789#include \"nvs_flash.h\"esp_err_t ret = nvs_flash_init();if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); }ESP_ERROR_CHECK(ret); 初始化ESP-NETIF和创建事件循环首先调用函数初始化netif。 1esp_err_t esp_netif_init(void) 这个函数在应用中需要被调用一次。(This function should be called exactly once from application code, when the application starts up.) 然后创建默认事件循环。 1esp_err_t esp_event_loop_create_default(void); 该函数创建了一个默认参数的事件循环，开始处理各个组件的事件。默认事件循环是一个特殊的，包含了各种系统事件处理（如wifi事件）。默认循环使用的事件注册API与用户的事件循环有一点不同，以下使用的API都是默认循环的API。如果想知道用户API是什么，可以参考官方手册。 创建完成后，需要将netif的处理函数放入对应的事件中，比如在STA开启后自动开启DHCP客户端获取IP。 这里NETIF库已经写好了默认配置，直接调用函数即可。 1esp_netif_t *esp_netif_create_default_wifi_sta(void);//sta模式 同样，如果开启了AP模式，则调用下面的函数。 1esp_netif_t *esp_netif_create_default_wifi_ap(void); sta/ap模式需要同时调用两个函数。 使用例子: 1234567#include \"esp_event.h\"#include \"esp_wifi.h\"... ESP_ERROR_CHECK(esp_netif_init()); ESP_ERROR_CHECK(esp_event_loop_create_default());//创建默认事件处理循环 esp_netif_create_default_wifi_sta(); 注册处理函数在事件循环中加入了netif中默认的处理函数后，我们还需要注册自己的处理函数，用来实现一些功能，比如在启动wifi后开始连接ap，或者在断开连接后进行重连等。 一个事件处理函数的模板如下： 1234567891011/*arg是传入的参数，在注册函数时设置event_base是事件基，表示一个大类的事件event_id是具体的事件event_data是传递的数据，比如在IP_EVENT 下的 IP_EVENT_STA_GOT_IP 事件会把获取到的IP地址传递过来*/static void event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){...} 创建好处理函数后，使用以下函数进行注册： 1esp_err_t esp_event_handler_instance_register(esp_event_base_t event_base, int32_t event_id, esp_event_handler_t event_handler, void *event_handler_arg, esp_event_handler_instance_t *instance); 参数: event_base – [in] 基事件 event_id – [in] 具体事件id event_handler – [in] 要注册的处理函数 event_handler_arg – [in] 要传递参数的指针，该函数不保留备份，因此需要确保其在被使用时有效 instance – [out] 输出的句柄，可以用来删除(unregister)这个事件函数，如果不需要可以填NULL。 同时，如果不需要句柄，调用以下函数即可： 1esp_err_t esp_event_handler_register(esp_event_base_t event_base, int32_t event_id, esp_event_handler_t event_handler, void *event_handler_arg); 上面两个函数在底层都调用了同一个函数进行注册，因此功能是一样的。 注意，对于event_base存在一个ESP_EVENT_ANY_BASE匹配全部的基事件;对于event_id存在ESP_EVENT_ANY_ID对应基事件的全部事件。即，ESP_EVENT_ANY_BASE+ESP_EVENT_ANY_ID==全部事件都响应。 对于同一事件多个处理函数，遵守先注册先调用，后注册后调用原则。(参考) 由于该规则，自己的事件处理函数注册必须要在esp_netif_create_default_wifi_sta()之后。 esp_netif_create_default_wifi_sta()中注册了该组件的事件函数，为保证用户正常上网，该事件函数需在用户函数之前执行。 一部分WiFi相关事件在后文附上，也可以直接参考官方手册 示例，这里来自官方例程的一部分，调用的FreeRTOS的eventGroupAPI通知IP事件的完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include \"esp_wifi.h\"#include \"esp_event.h\"#include \"freertos/event_groups.h\"#define EXAMPLE_ESP_MAXIMUM_RETRY 10static int s_retry_num = 0;static EventGroupHandle_t s_wifi_event_group;static void event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){ if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) { esp_wifi_connect();//STa开启后开始连接wifi } else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) { if (s_retry_num &lt; EXAMPLE_ESP_MAXIMUM_RETRY) { esp_wifi_connect();//连接失败，重新连接 s_retry_num++; ESP_LOGI(TAG, \"retry to connect to the AP\"); } else { xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT); } ESP_LOGI(TAG,\"connect to the AP fail\"); } else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) { ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data; ESP_LOGI(TAG, \"got ip:\" IPSTR, IP2STR(&amp;event-&gt;ip_info.ip)); s_retry_num = 0; xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT); }}void app_main(void){ ... esp_event_handler_instance_t instance_any_id;//创建句柄，用来管理该函数生命周期 esp_event_handler_instance_t instance_got_ip; ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;event_handler, NULL, &amp;instance_any_id)); ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;event_handler, NULL, &amp;instance_got_ip));} 设置WiFi处理好上层要响应的事件后，可以开始配置底层的WiFi驱动。 首先初始化WiFi驱动的资源和参数： 12wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();//获取WIFI默认配置。这样可以给每个值都赋上初值ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));//初始化WIFI 使用WIFI_INIT_CONFIG_DEFAULT()获得每个变量的初值，这样可以防止某个参数忘记或设错导致的初始化失败。 在WiFi库的API被调用之前，esp_wifi_init()必须被调用。 之后设置WiFi的模式和相应模式的配置： 1esp_err_t esp_wifi_set_mode(wifi_mode_t mode);//设置模式 mode有以下几种: WIFI_MODE_STA:sta模式 WIFI_MODE_AP:ap模式 WIFI_MODE_APSTA:sta/ap模式 默认模式是STA。 设置相应模式的参数 1esp_err_t esp_wifi_set_config(wifi_interface_t interface, wifi_config_t *conf); 其中wifi_interface_t如下： 1234typedef enum { WIFI_IF_STA = ESP_IF_WIFI_STA, WIFI_IF_AP = ESP_IF_WIFI_AP,} wifi_interface_t; wifi_config_t结构体定义如下: 1234typedef union { wifi_ap_config_t ap; /**&lt; configuration of AP */ wifi_sta_config_t sta; /**&lt; configuration of STA */} wifi_config_t; 这是一个联合，设置ap和sta时分别设置不同的部分。 对于wifi_sta_config_t需要关注的成员如下: 成员名 类型 作用 ssid[32] uint8_t WiFi的SSID password[64] uint8_t WiFi的密码 scan_method wifi_scan_method_t 选择扫描模式 bssid_set bool 1:检查AP的MAC 0:不检查 bssid uint8_t 目的AP的MAC channel uint8_t 0:通道未知 ;1-13 sort_method wifi_sort_method_t 扫描排序顺序设置 threshold wifi_scan_threshold_t 安全性强于或信号强度强于该设置的AP可被使用 wifi_scan_method_t: WIFI_FAST_SCAN快速扫描模式，找到匹配的SSID后停止 WIFI_ALL_CHANNEL_SCAN扫描完全部通道为止 wifi_sort_method_t: WIFI_CONNECT_AP_BY_SIGNAL按信号强弱整理 WIFI_CONNECT_AP_BY_SECURITY按加密等级整理 wifi_scan_threshold_t: int8_t rssi信号的强度 wifi_auth_mode_t authmode最低信号的认证方式，如果想连接开放WiFi及以上，需设置为WIFI_AUTH_OPEN wifi_auth_mode_t: 12345678910111213typedef enum { WIFI_AUTH_OPEN = 0, /**&lt; authenticate mode : open */ WIFI_AUTH_WEP, /**&lt; authenticate mode : WEP */ WIFI_AUTH_WPA_PSK, /**&lt; authenticate mode : WPA_PSK */ WIFI_AUTH_WPA2_PSK, /**&lt; authenticate mode : WPA2_PSK */ WIFI_AUTH_WPA_WPA2_PSK, /**&lt; authenticate mode : WPA_WPA2_PSK */ WIFI_AUTH_WPA2_ENTERPRISE, /**&lt; authenticate mode : WPA2_ENTERPRISE */ WIFI_AUTH_WPA3_PSK, /**&lt; authenticate mode : WPA3_PSK */ WIFI_AUTH_WPA2_WPA3_PSK, /**&lt; authenticate mode : WPA2_WPA3_PSK */ WIFI_AUTH_WAPI_PSK, /**&lt; authenticate mode : WAPI_PSK */ WIFI_AUTH_OWE, /**&lt; authenticate mode : OWE */ WIFI_AUTH_MAX} wifi_auth_mode_t; 一个最小设置的例子： 12345678wifi_config_t wifi_config = { .sta = { .ssid = \"SSID\", .password = \"PASSWORD\", .threshold.authmode = WIFI_AUTH_WPA_WPA2_PSK, .sae_pwe_h2e = WPA3_SAE_PWE_BOTH,//添加这个是为了兼容最新的认证标准WPA3 }, }; 对于wifi_ap_config_t需要关注的成员如下: 成员 类型 作用 ssid[32] uint8_t SSID password[64] uint8_t 密码 ssid_len uint8_t strlen(WIFI_SSID) channel uint8_t 选择通道 authmode wifi_auth_mode_t 选择认证方式 ssid_hidden uint8_t 是否广播SSID(SSID是否可见) max_connection uint8_t 最大连接数 一个最小的config如下： 12345678910111213wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .channel = EXAMPLE_ESP_WIFI_CHANNEL, .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK, .pmf_cfg = { .required = false,//这里关闭了对pmf的要求，让其能连接更多设备 }, }, }; 如果开启了nvs，esp_wifi_set_config()的设置会被储存在nvs中，下次不用配置，可以使用esp_wifi_get_config()获取设置。 当一切都配置好后，可以开启WiFi： 1esp_err_t esp_wifi_start(void); 开启后，可以在事件循环中使用esp_err_t esp_wifi_connect(void)去连接WiFi，参考上面事件函数中的代码。 对于已经连接的AP，使用以下API获得信息: 1esp_err_t esp_wifi_sta_get_ap_info(wifi_ap_record_t *ap_info); 注意：在获得IP前，禁止一切socket操作。 三，扫描WiFi在通常的应用中，我们不可能将WiFi信息固定。因此，在连接WiFi前先扫描WiFi是十分必要的，扫描仅在sta或sta/ap模式使用。 扫描使用以下API： 1esp_err_t esp_wifi_scan_start(const wifi_scan_config_t *config, bool block); 其中，block用来确定是否阻塞式扫描。如果为1，将会阻塞直到扫描完成。否则，会立刻返回，结果一般在事件循环中处理。 config用来配置扫描设置，具有以下字段： uint8_t *ssid:AP的SSID，如果不为NULL，则仅扫描相同NULL uint8_t *bssid:AP的MAC，如果不为NULL，则仅扫描相同MAC uint8_t channel:如果该字段值为 0，将进行全信道扫描；反之，将针对特定信道进行扫描。 bool show_hidden:如果该字段值为 0，本次扫描将忽略具有隐藏 SSID 的 AP；反之，这些 AP 也会在扫描时被视为正常 AP。 wifi_scan_type_t scan_type:WIFI_SCAN_TYPE_ACTIVE主动扫描； WIFI_SCAN_TYPE_PASSIVE 被动扫描 wifi_scan_time_t scan_time:用来控制扫描时间，不用关心。 将该参数设为NULL则使用默认扫描。 该函数扫描出的结果会储存在内存中，直到调用esp_wifi_scan_get_ap_records()或者esp_err_t esp_wifi_clear_ap_list(void)释放。 主动扫描:通过发送 probe request 进行扫描。该模式为默认的扫描模式。 被动扫描:不发送 probe request。跳至某一特定信道并等待 beacon。应用程序可通过 wifi_scan_config_t 中的 scan_type 字段使能被动扫描。 调用 API sp_wifi_set_config() 可全局配置一些扫描属性，请参阅 station的配置。 如果国家信息有误，调用函数 esp_wifi_set_country() 进行配置。 当全部扫描完成后，会产生WIFI_EVENT_SCAN_DONE事件，在该事件函数中，使用以下API获得扫描得到的AP数量： 1esp_err_t esp_wifi_scan_get_ap_num(uint16_t *number); 获得AP数量后，使用以下API获得具体信息： 1esp_err_t esp_wifi_scan_get_ap_records(uint16_t *number, wifi_ap_record_t *ap_records); 参数： number:该参数是一个输入输出参数。但作为输入参数，它指示了ap_records最多储存的数量。作为输出参数，它则与esp_err_t esp_wifi_scan_get_ap_num(uint16_t *number);输出一样。 ap_records:储存扫描到AP信息的参数 ap_records: 1234567891011121314151617181920typedef struct { uint8_t bssid[6]; /**&lt; MAC address of AP */ uint8_t ssid[33]; /**&lt; SSID of AP */ uint8_t primary; /**&lt; channel of AP */ wifi_second_chan_t second; /**&lt; secondary channel of AP */ int8_t rssi; /**&lt; signal strength of AP */ wifi_auth_mode_t authmode; /**&lt; authmode of AP */ wifi_cipher_type_t pairwise_cipher; /**&lt; pairwise cipher of AP */ wifi_cipher_type_t group_cipher; /**&lt; group cipher of AP */ wifi_ant_t ant; /**&lt; antenna used to receive beacon from AP */ uint32_t phy_11b:1; /**&lt; bit: 0 flag to identify if 11b mode is enabled or not */ uint32_t phy_11g:1; /**&lt; bit: 1 flag to identify if 11g mode is enabled or not */ uint32_t phy_11n:1; /**&lt; bit: 2 flag to identify if 11n mode is enabled or not */ uint32_t phy_lr:1; /**&lt; bit: 3 flag to identify if low rate is enabled or not */ uint32_t wps:1; /**&lt; bit: 4 flag to identify if WPS is supported or not */ uint32_t ftm_responder:1; /**&lt; bit: 5 flag to identify if FTM is supported in responder mode */ uint32_t ftm_initiator:1; /**&lt; bit: 6 flag to identify if FTM is supported in initiator mode */ uint32_t reserved:25; /**&lt; bit: 7..31 reserved */ wifi_country_t country; /**&lt; country information of AP */} wifi_ap_record_t; 一个例子： 1234567891011121314151617181920#include \"esp_wifi.h\"#define DEFAULT_SCAN_LIST_SIZE 10 ... esp_wifi_scan_start(NULL, true); ESP_ERROR_CHECK(esp_wifi_scan_get_ap_records(&amp;number, ap_info)); ESP_ERROR_CHECK(esp_wifi_scan_get_ap_num(&amp;ap_count)); ESP_LOGI(TAG, \"Total APs scanned = %u\", ap_count); for (int i = 0; (i &lt; DEFAULT_SCAN_LIST_SIZE) &amp;&amp; (i &lt; ap_count); i++) { ESP_LOGI(TAG, \"SSID \\t\\t%s\", ap_info[i].ssid); ESP_LOGI(TAG, \"RSSI \\t\\t%d\", ap_info[i].rssi); print_auth_mode(ap_info[i].authmode); if (ap_info[i].authmode != WIFI_AUTH_WEP) { print_cipher_type(ap_info[i].pairwise_cipher, ap_info[i].group_cipher); } ESP_LOGI(TAG, \"Channel \\t\\t%d\\n\", ap_info[i].primary); }... 附录-WiFi事件描述该部分来自官方文档，在这里做参考。以下为具体事件名，头两个单词同时也是基事件名。 WIFI_EVENT_WIFI_READY Wi-Fi 驱动程序永远不会生成此事件，因此，应用程序的事件回调函数可忽略此事件。在未来的版本中，此事件可能会被移除。 WIFI_EVENT_SCAN_DONE 扫描完成事件，由 esp_wifi_scan_start() 函数触发，将在以下情况下产生： 扫描已完成，例如：Wi-Fi 已成功找到目标 AP 或已扫描所有信道。 当前扫描因函数 esp_wifi_scan_stop() 而终止。 在当前扫描完成之前调用了函数 esp_wifi_scan_start()。此时，新的扫描将覆盖当前扫描过程，并生成一个扫描完成事件。 以下情况下将不会产生扫描完成事件： ​ 当前扫描被阻止。 ​ 当前扫描是由函数 esp_wifi_connect() 触发的。 接收到此事件后，事件任务暂不做任何响应。首先，应用程序的事件回调函数需调用 esp_wifi_scan_get_ap_num() 和 esp_wifi_scan_get_ap_records() 获取已扫描的 AP 列表，然后触发 Wi-Fi 驱动程序释放在扫描过程中占用的内存空间（切记该步骤）。 更多详细信息，请参阅 ESP32-S3 Wi-Fi 扫描。 WIFI_EVENT_STA_START 如果调用函数 esp_wifi_start() 后接收到返回值 ESP_OK，且当前 Wi-Fi 处于 station 或 station/AP 共存模式，则将产生此事件。接收到此事件后，事件任务将初始化 LwIP 网络接口 (netif)。通常，应用程序的事件回调函数需调用 esp_wifi_connect() 来连接已配置的 AP。 WIFI_EVENT_STA_STOP 如果调用函数 esp_wifi_stop() 后接收到返回值 ESP_OK，且当前 Wi-Fi 处于 station 或 station/AP 共存模式，则将产生此事件。接收到此事件后，事件任务将进行释放 station IP 地址、终止 DHCP 客户端服务、移除 TCP/UDP 相关连接并清除 LwIP station netif 等动作。此时，应用程序的事件回调函数通常不需做任何响应。 WIFI_EVENT_STA_CONNECTED 如果调用函数 esp_wifi_connect() 后接收到返回值 ESP_OK，且 station 已成功连接目标 AP，则将产生此连接事件。接收到此事件后，事件任务将启动 DHCP 客户端服务并开始获取 IP 地址。此时，Wi-Fi 驱动程序已准备就绪，可发送和接收数据。如果您的应用程序不依赖于 LwIP（即 IP 地址），则此刻便可以开始应用程序开发工作。但是，如果您的应用程序需基于 LwIP 进行，则还需等待 got ip 事件发生后才可开始。 WIFI_EVENT_STA_DISCONNECTED 此事件将在以下情况下产生： ​ 1. 调用了函数 esp_wifi_disconnect() 或 esp_wifi_stop()，且 Wi-Fi station 已成功连接至 AP。 ​ 2. 调用了函数 esp_wifi_connect()，但 Wi-Fi 驱动程序因为某些原因未能成功连接至 AP，例如：未扫描到目标 AP、验证超时等。 或存在多个 SSID 相同的 AP，station 无法连接所有已找到的 AP，也将产生该事件。 ​ 3. Wi-Fi 连接因为某些原因而中断，例如：station 连续多次丢失 N beacon、AP 踢掉 station、AP 认证模式改变等。 接收到此事件后，事件任务的默认动作为： ​ 1. 关闭 station 的 LwIP netif。 ​ 2. 通知 LwIP 任务清除导致所有套接字状态错误的 UDP/TCP 连接。针对基于套接字编写的应用程序，其回调函数可以在接收到此 事件时（如有必要）关闭并重新创建所有套接字。 应用程序处理此事件最常用的方法为：调用函数 esp_wifi_connect() 重新连接 Wi-Fi。但是，如果此事件是由函数 esp_wifi_disconnect() 引发的，则应用程序不应调用 esp_wifi_connect() 来重新连接。应用程序须明确区分此事件的引发原因，因为某些情况下应使用其它更好的方式进行重新连接。请参阅 Wi-Fi 重新连接 和 连接 Wi-Fi 时扫描。 需要注意的另一点是：接收到此事件后，LwIP 的默认动作是终止所有 TCP 套接字连接。大多数情况下，该动作不会造成影响。但对某些特殊应用程序可能除外。例如： 应用程序创建一个了 TCP 连接，以维护每 60 秒发送一次的应用程序级、保持活动状态的数据。 由于某些原因，Wi-Fi 连接被切断并引发了 WIFI_EVENT_STA_DISCONNECTED 事件。根据当前实现，此时所有 TCP 连接都将被移除，且保持活动的套接字将处于错误的状态中。但是，由于应用程序设计者认为网络层 不应 考虑这个 Wi-Fi 层的错误，因此应用程序不会关闭套接字。 5 秒后，因为在应用程序的事件回调函数中调用了 esp_wifi_connect()，Wi-Fi 连接恢复。同时，station 连接至同一个 AP 并获得与之前相同的 IPV4 地址。 60 秒后，当应用程序发送具有保持活动状态的套接字的数据时，套接字将返回错误，应用程序将关闭套接字并在必要时重新创建。 在上述场景中，理想状态下应用程序套接字和网络层将不会受到影响，因为在此过程中 Wi-Fi 连接只是短暂地断开然后快速恢复。应用程序可通过 LwIP menuconfig 启动“IP 改变时保持 TCP 连接”的功能。 IP_EVENT_STA_GOT_IP 当 DHCP 客户端成功从 DHCP 服务器获取 IPV4 地址或 IPV4 地址发生改变时，将引发此事件。此事件意味着应用程序一切就绪，可以开始任务（如：创建套接字）。 IPV4 地址可能由于以下原因而发生改变： ​ 1. DHCP 客户端无法重新获取/绑定 IPV4 地址，且 station 的 IPV4 重置为 0。 ​ 2. DHCP 客户端重新绑定了其它地址。 ​ 3. 静态配置的 IPV4 地址已发生改变。 函数 ip_event_got_ip_t 中的字段 ip_change 说明了 IPV4 地址是否发生改变。 套接字的状态是基于 IPV4 地址的，这意味着，如果 IPV4 地址发生改变，则所有与此 IPV4 相关的套接字都将变为异常。接收到此事件后，应用程序需关闭所有套接字，并在 IPV4 变为有效地址时重新创建应用程序。 IP_EVENT_GOT_IP6 当 IPV6 SLAAC 支持自动为 ESP32-S3 配置一个地址，或 ESP32-S3 地址发生改变时，将引发此事件。此事件意味着应用程序一切就绪，可以开始任务（如：创建套接字）。 IP_EVENT_STA_LOST_IP 当 IPV4 地址失效时，将引发此事件。 此事件不会在 Wi-Fi 断连后立刻出现。Wi-Fi 连接断开后，首先将启动一个 IPV4 地址丢失计时器，如果 station 在该计时器超时之前成功获取了 IPV4 地址，则不会发生此事件。否则，此事件将在计时器超时时发生。 一般来说，应用程序可忽略此事件。这只是一个调试事件，主要使应用程序获知 IPV4 地址已丢失。 WIFI_EVENT_AP_START 与 WIFI_EVENT_STA_START 事件相似。 WIFI_EVENT_AP_STOP 与 WIFI_EVENT_STA_STOP 事件相似。 WIFI_EVENT_AP_STACONNECTED 每当有一个 station 成功连接 ESP32-S3 AP 时，将引发此事件。接收到此事件后，事件任务将不做任何响应，应用程序的回调函数也可忽略这一事件。但是，您可以在此时进行一些操作，例如：获取已连接 station 的信息等。 WIFI_EVENT_AP_STADISCONNECTED 此事件将在以下情况下发生： ​ 1. 应用程序通过调用函数 esp_wifi_disconnect() 或 esp_wifi_deauth_sta() 手动断开 station 连接。 ​ 2. Wi-Fi 驱动程序出于某些原因断开 station 连接，例如：AP 在过去 5 分钟（可通过函数 esp_wifi_set_inactive_time() 修改该时间）内未接收到任何数据包等。 ​ 3. station 断开与 AP 之间的连接。 发生此事件时，事件任务将不做任何响应，但应用程序的事件回调函数需执行一些操作，例如：关闭与此 station 相关的套接字等。 WIFI_EVENT_AP_PROBEREQRECVED 默认情况下，此事件处于禁用状态，应用程序可以通过调用 API esp_wifi_set_event_mask() 启用。 启用后，每当 AP 接收到 probe request 时都将引发此事件。 WIFI_EVENT_STA_BEACON_TIMEOUT 如果 station 在 inactive 时间内未收到所连接 AP 的 beacon，将发生 beacon 超时，将引发此事件。inactive 时间通过调用函数 esp_wifi_set_inactive_time() 设置。 WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START 非连接模块在 Interval 开始时触发此事件。 请参考 非连接模块功耗管理 。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-GPIO的简单使用","slug":"ESP-IDF学习笔记-GPIO的简单使用","date":"2023-04-27T09:35:33.000Z","updated":"2023-05-29T15:33:21.552Z","comments":true,"path":"post/42735/","link":"","permalink":"https://lostacnet.top/post/42735/","excerpt":"ESP-IDF学习笔记-GPIO的简单使用ESP32中的GPIO可以分为简单的GPIO和专用GPIO，这里记录普通GPIO的使用。每个管脚都可用作一个通用 IO，或连接一个内部外设信号。通过 GPIO 交换矩阵、IO MUX 和 RTC IO MUX，可配置外设模块的输入信号来源于任何的 GPIO 管脚，并且外设模块的输出信号也可连接到任意 GPIO 管脚。这些模块共同组成了芯片的输入输出控制。","text":"ESP-IDF学习笔记-GPIO的简单使用ESP32中的GPIO可以分为简单的GPIO和专用GPIO，这里记录普通GPIO的使用。每个管脚都可用作一个通用 IO，或连接一个内部外设信号。通过 GPIO 交换矩阵、IO MUX 和 RTC IO MUX，可配置外设模块的输入信号来源于任何的 GPIO 管脚，并且外设模块的输出信号也可连接到任意 GPIO 管脚。这些模块共同组成了芯片的输入输出控制。 官方文档 参考文章 一，GPIO配置头文件:driver/gpio.h GPIO配置分为结构体配置和函数配置。 结构体配置函数原型: 1esp_err_t gpio_config(const gpio_config_t *pGPIOConfig); 可配置GPIO‘的输入输出模式、上下拉、中断类型、引脚。 使用的gpio_config_t结构体： 成员 类型 作用 典型值 pin_bit_mask uint64_t 选择引脚，以位为单位选择 如(1 &lt;&lt; 18)|(1 &lt;&lt; 19) mode gpio_mode_t 选择输入输出模式 GPIO_MODE_DISABLE pull_up_en gpio_pullup_t 选择是否上拉 GPIO_PULLUP_DISABLE/GPIO_PULLUP_ENABLE pull_down_en gpio_pulldown_t 选择是否下拉 GPIO_PULLDOWN_DISABLE/GPIO_PULLDOWN_ENABLE intr_type gpio_int_type_t 中断触发模式 GPIO_INTR_DISABLE 详细参数解析： gpio_mode_t： GPIO_MODE_DISABLE:失能输入输出 GPIO_MODE_INPUT:输入模式 GPIO_MODE_OUTPUT:输出模式 GPIO_MODE_OUTPUT_OD:开漏输出模式 GPIO_MODE_INPUT_OUTPUT_OD:开漏输入输出模式 GPIO_MODE_INPUT_OUTPUT:输入输出模式 gpio_int_type_t: GPIO_INTR_DISABLE:禁止中断 GPIO_INTR_POSEDGE:上升沿中断 GPIO_INTR_NEGEDGE:下降沿中断 GPIO_INTR_ANYEDGE:边缘中断 GGPIO_INTR_LOW_LEVEL:低电平中断 GPIO_INTR_HIGH_LEVEL:高电平中断 pin_bit_mask: 该参数使用每个bit表示要操作的GPIO口，典型使用值如下: 12345678910// 表示此配置对 GPIO2生效，因为这个64位数的第2位（从零开始）为1pin_bit_mask = 0b0100// 表示此配置对 GPIO0 和 GPIO5 生效，因为第0位和第5位为1pin_bit_mask = 0b100001// 表示此配置对 GPIO16 和 GPIO 18 生效，采用位运算pin_bit_mask = (1ull &lt;&lt; 16) | (1ull &lt;&lt; 18) 使用例: 12345678gpio_config_t gpio={ .pin_bit_mask=1&lt;&lt;GPIO_NUM_3, .mode=GPIO_MODE_OUTPUT, .pull_down_en=0, .pull_up_en=1, .intr_type=GPIO_INTR_DISABLE, }; gpio_config(&amp;gpio); 使用gpio_reset_pin()重置IO口。 ’ 函数配置就是将上面的结构体分成了多个函数进行配置，这里不多讲，请自行参考官方文档。 123456789101112esp_err_t gpio_set_intr_type(gpio_num_t gpio_num, gpio_int_type_t intr_type);esp_err_t gpio_intr_enable(gpio_num_t gpio_num);esp_err_t gpio_intr_disable(gpio_num_t gpio_num);esp_err_t gpio_set_direction(gpio_num_t gpio_num, gpio_mode_t mode);esp_err_t gpio_set_pull_mode(gpio_num_t gpio_num, gpio_pull_mode_t pull);esp_err_t gpio_pullup_en(gpio_num_t gpio_num);esp_err_t gpio_pullup_dis(gpio_num_t gpio_num);esp_err_t gpio_set_drive_capability(gpio_num_t gpio_num, gpio_drive_cap_t strength);//设置IO口驱动能力esp_err_t gpio_get_drive_capability(gpio_num_t gpio_num, gpio_drive_cap_t *strength);esp_err_t gpio_hold_en(gpio_num_t gpio_num);//保持IO口状态esp_err_t gpio_hold_dis(gpio_num_t gpio_num); 二，IO口的使用设置IO口输出： 1esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level); 读取IO口状态： 1int gpio_get_level(gpio_num_t gpio_num); 当IO口没有设置为输入，则读取的值恒为0。 三，中断的使用1，设置中断类型通过结构体配置，或者使用gpio_set_intr_type()函数设置触发中断的条件。 2，创建中断服务函数创建形如以下的中断服务函数 12345678static QueueHandle_t gpio_evt_queue = NULL;...static void IRAM_ATTR gpio_isr_handler(void* arg){ uint32_t gpio_num = (uint32_t) arg; xQueueSendFromISR(gpio_evt_queue, &amp;gpio_num, NULL);} 这里使用的FreeRTOS的消息队列传递中断信息。因为GPIO中断在IRAM中工作，好处是在flash禁用的情况下也可以响应中断。且速度更快，对于这种频繁触发的中断是有利的。但是这个中断也因此无法使用printf等串口打印工作，需要转入其他Task中执行。详见官网API参考—— 中断分配Interrupt Allocation 3，创建中断处理任务函数123456789static void gpio_task_example(void* arg){ uint32_t io_num; for(;;) { if(xQueueReceive(gpio_evt_queue, &amp;io_num, portMAX_DELAY)) { printf(\"GPIO[%\"PRIu32\"] intr, val: %d\\n\", io_num, gpio_get_level(io_num)); } }} 4,安装中断服务1esp_err_t gpio_install_isr_service(int intr_alloc_flags); 参数： intr_alloc_flags – Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. 该函数与gpio_isr_register() 不兼容。gpio_isr_register() 会创建一个中断服务函数处理全部的中断，用户需要在这个处理函数中分辨IO口分别处理。而使用这个函数，会用gpio_isr_register() 创建一个设置好的中断服务函数，分辨IO口的任务已经写好，使用gpio_isr_handler_add()添加每个中断的服务函数。 相应的有移除函数。 1void gpio_uninstall_isr_service(void); 5，为每个IO口添加handle1esp_err_t gpio_isr_handler_add(gpio_num_t gpio_num, gpio_isr_t isr_handler, void *args); 其中**args是上面创建的中断服务函数传入**的参数。 该函数需要在gpio_install_isr_service()后调用。使用该函数添加的服务函数不在需要使用IRAM_ATTR,除非在使用gpio_install_isr_service()时设置了ESP_INTR_FLAG_IRAM 。 删除函数: 1esp_err_t gpio_isr_handler_remove(gpio_num_t gpio_num); 6,开启任务1xTaskCreate(gpio_task_example, \"gpio_task_example\", 2048, NULL, 10, NULL); 注意，上面用到的FreeRTOS的API需要引入相应头文件。 123#include \"freertos/FreeRTOS.h\"#include \"freertos/task.h\"#include \"freertos/queue.h\" 一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include \"freertos/FreeRTOS.h\"#include \"freertos/task.h\"#include \"freertos/queue.h\"#include \"driver/gpio.h\"static QueueHandle_t gpioevent=NULL;static void IRAM_ATTR gpio_intr(void *arg){ uint32_t gpio_num=(uint32_t )arg; xQueueSendFromISR(gpioevent,&amp;gpio_num,NULL);}static void gpio_task(void *arg){ uint32_t io_num; for(;;){ if(xQueueReceive(gpioevent,&amp;io_num,portMAX_DELAY)) { printf(\"GPIO[%\"PRIu32\"] intr, val: %d\\n\", io_num, gpio_get_level(io_num)); } }}void app_main(void){ gpio_config_t gpio; gpio.pull_down_en=0; gpio.mode=GPIO_MODE_INPUT; gpio.pin_bit_mask=1&lt;&lt;GPIO_NUM_8; gpio.intr_type=GPIO_INTR_POSEDGE; gpio.pull_up_en=1; gpio_config(&amp;gpio); gpioevent=xQueueCreate(10, sizeof(uint32_t)); xTaskCreate(gpio_task, \"gpio_task\", 2048, NULL, 10, NULL); gpio_install_isr_service(0); gpio_isr_handler_add(GPIO_NUM_8, gpio_intr, (void*) GPIO_NUM_8); while(1) { ... }}","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-UART的使用","slug":"ESP-IDF学习笔记-UART的使用","date":"2023-04-24T14:43:27.000Z","updated":"2023-05-29T15:34:55.279Z","comments":true,"path":"post/42443/","link":"","permalink":"https://lostacnet.top/post/42443/","excerpt":"ESP-IDF学习笔记-UART的使用ESP32中串口的使用与STM32中大有不同。在ESP32中使用串口，需要配置串口，设置引脚，安装驱动之后才能使用。接收和发送数据也不是直接向寄存器写数据，而是先存到FIFO中，交由ESP32自动发送。其中断的使用更是结合了FreeRTOS的特性进行的。","text":"ESP-IDF学习笔记-UART的使用ESP32中串口的使用与STM32中大有不同。在ESP32中使用串口，需要配置串口，设置引脚，安装驱动之后才能使用。接收和发送数据也不是直接向寄存器写数据，而是先存到FIFO中，交由ESP32自动发送。其中断的使用更是结合了FreeRTOS的特性进行的。 先摆上官方文档。 本文参考于这篇文章 一，串口的配置步骤一个串口的典型使用步骤如下: 使用uart_param_config()设置UART参数 使用art_set_pin()分配UART引脚 使用uart_driver_install()安装UART驱动 使用uart_read_bytes()/uart_write_bytes()收发数据 (可选)新建task读取事件队列处理中断事件 (可选)删除驱动释放资源 其中，1、2、3步可以调换顺序。 二，配置的具体步骤同STM32HAL库的句柄一样，ESP32中使用一个uart_port_t类型的UART_NUM_x变量识别不同的UART控制器，在调用函数时需指明。 其中UART_NUM_MAX表示该芯片最大的uart控制器数，上面的x最大为UART_NUM_MAX-1。 ESP32中默认使用UART_NUM_0作为log库的输出。 UART参数的配置UART参数的配置主要用两种方式，一种是使用uart_param_config+结构体一次性配置；另一种是使用分离函数进行配置。、 单步配置（结构体）使用的函数原型： 1esp_err_t uart_param_config(uart_port_t uart_num, const uart_config_t *uart_config) 参数： uart_num使用的UART编号 uart_config配置的结构体 返回： ESP_OK Success ESP_FALL Parameter error uart_config_t结构体成员： 成员 类型 作用 可用参数 baud_rate int 波特率 宏定义UART_BITRATE_MAX为支持的最大波特率 data_bits uart_word_length_t 数据位长度 UART_DATA_X_BITS(X=5~8 )或UART_DATA_BITS_MAX parity uart_parity_t 校验位 UART_PARITY_X(X=DISABLE,EVEN,ODD) stop_bits uart_stop_bits_t 停止位 UART_STOP_BITS_X(X=1,1_5,2,MAX) flow_ctrl uart_hw_flowcontrol_t 硬件流控制 UART_HW_FLOWCTRL_X(X=DISABLE,RTS,CTS,CTS_RTS,MAX) rx_flow_ctrl_thresh uint8_t 硬件流控制阈值 — source_clk uart_sclk_t 时钟源选择 UART_SCLK_X(X=APB,RTC,XTAL,DEFAULT(APB)) 如果不使用硬件流控制，可以使用 uart_set_rts() 和 uart_set_dtr()软件流控制。 使用例： 123456789101112#include \"driver/uart.h\"#define EX_UART_NUM UART_NUM_0uart_config_t uart_config = { .baud_rate = 115200, .data_bits = UART_DATA_8_BITS, .parity = UART_PARITY_DISABLE, .stop_bits = UART_STOP_BITS_1, .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, .source_clk = UART_SCLK_DEFAULT, };uart_param_config(EX_UART_NUM, &amp;uart_config); 多步配置多步配置的函数表如下： 欲配置的参数 函数 波特率(Baud rate) uart_set_baudrate() 传输数据位长(Number of transmitted bits) uart_set_word_length() selected out of uart_word_length_t 奇偶校验(parity control) uart_set_parity() selected out of uart_parity_t 停止位数(Number of stop bits) uart_set_stop_bits() selected out of uart_stop_bits_t 硬件流控方式(Hardware flow control mode) uart_set_hw_flow_ctrl() selected out of uart_hw_flowcontrol_t 通信方式(Communication mode) uart_set_mode() selected out of uart_mode_t 同时，上面的每个函数都有一个_get_对应对象来检查当前设置的值。例如，要检查当前波特率值，调用uart_get_baudrate()。 分配引脚使用的函数原型 1esp_err_t uart_set_pin(uart_port_t uart_num, int tx_io_num, int rx_io_num, int rts_io_num, int cts_io_num) 参数： uart_num使用的串口编号 tx_io_numTX引脚 rx_io_numRX引脚 rts_io_numRTS引脚 cts_io_numCTS引脚 返回： ESP_OK Success ESP_FALL Parameter error 对于后四个参数，可以使用宏UART_PIN_NO_CHANGE保留已经配置的引脚或者默认引脚。 如果设置的GPIO有该功能的IOMUX（复用），则信号会直接接到该引脚而不通过GPIO矩阵，这样能够支持更高的速率。例如。ESP32S3中IO43是默认的U0TXD，IO44是默认的U0RXD；IO17–U1TXD，IO18–U1RXD。 ESP32提供了一些宏用来定义这些能直连的引脚，参考官方文档，或者见本章高级用法篇。 内部信号能够被输出到多个GPIO，但只有一个GPIO能输入。 经实际测试，ESP32S3的UART好像不能换引脚。 使用例: 123#include \"driver/uart.h\"uart_set_pin(UART_NUM_0,UART_PIN_NO_CHANGE,UART_PIN_NO_CHANGE,UART_PIN_NO_CHANGE,UART_PIN_NO_CHANGE); 安装驱动使用的函数原型： 1esp_err_t uart_driver_install(uart_port_t uart_num, int rx_buffer_size, int tx_buffer_size, int queue_size, QueueHandle_t *uart_queue, int intr_alloc_flags); 参数： uart_num使用的串口编号 rx_buffer_size接收缓冲区大小 tx_buffer_size发送缓冲区大小 queue_size事件队列大小 uart_queue事件队列句柄，如果成功，这里会有一个新的事件队列。如果设为NULL将不使用 intr_alloc_flags用于分配中断的标志。传入一个或多个ESP_INTR_FLAG_*(详见esp_intr_alloc.h)，不能使用ESP_INTR_FLAG_IRAM(在meunconfig中设置) 返回： ESP_OK Success ESP_FALL Parameter error 安装UART驱动程序，同时，UART ISR处理器将被附加到运行该函数的同一个CPU核心上。Rx_buffer_size应该大于UART_FIFO_LEN。Tx_buffer_size应该是**0或者大于UART_FIFO_LEN**。 UART_FIFO_LEN是一个宏定义，定义硬件FIFO的大小 如果发送缓存区为0，则使用uart_write_bytes()时会阻塞发送。 例子： 1uart_driver_install(UART_NUM_0,1024,512,0,NULL,0); 收发数据发数据使用的函数原型： 1int uart_write_bytes(uart_port_t uart_num, const void *src, size_t size); 参数： uart_num使用的串口编号 src数据地址 size数据长度 返回： (-1) Parameter error OTHERS (&gt;=0) The number of bytes pushed to the TX FIFO 如果缓冲区为0，该函数会阻塞直到所有数据被发送或者所有数据被加入FIFO。 缓冲区中的数据会被UART ISR逐步转移到FIFO。（有点像32的Transmit_IT）。 函数uart_write_bytes_with_break()与其功能类似，但会在结束时添加串行中断信号。“串行中断信号”意味着 Tx 线保持低电平的时间长于一个数据帧。 uart_tx_chars()也能将数据写入Tx FIFO，但不会等待可用空间，而是立即放入硬件FIFO。 uart_wait_tx_done()用于监听发送缓冲区，在缓冲区为空时返回。 123// Wait for packet to be sentconst uart_port_t uart_num = UART_NUM_2;ESP_ERROR_CHECK(uart_wait_tx_done(uart_num, 100)); // wait timeout is 100 RTOS ticks (TickType_t) 接数据使用的函数原型： 1int uart_read_bytes(uart_port_t uart_num, void *buf, uint32_t length, TickType_t ticks_to_wait) ticks_to_wait是超时时间，值是RTOS的ticks。 使用该函数前应使用uart_get_buffered_data_len()获得缓冲区数据的长度。比如： 123456// Read data from UART.const uart_port_t uart_num = UART_NUM_2;uint8_t data[128];int length = 0;ESP_ERROR_CHECK(uart_get_buffered_data_len(uart_num, (size_t*)&amp;length));length = uart_read_bytes(uart_num, data, length, 100); 清除缓冲区： 1esp_err_t uart_flush(uart_port_t uart_num); 清除RX缓冲区的内容。 1esp_err_t uart_flush_input(uart_port_t uart_num); 清除输入缓存区内容（如果想等待发送完成，请使用uart_wait_tx_done）。 使用中断这里提到的中断与一般的中断不同，这里应该叫UART事件。中断触发后读取的中断源被当做事件添加到队列中，使用FreeRTOS的一个线程进行读取，处理，得到像中断的效果。 使用事件处理需要在安装驱动时开启事件队列。 1234#include \"driver/uart.h\"static QueueHandle_t uart0_queue;uart_driver_install(UART_NUM_0,1024,512,20,&amp;uart0_queue,0);//队列长度为20 UART 默认的事件处理 没有使用esp_event.h中的事件循环(EventLoop)。而是使用队列传输事件对象（一个uart_event_t类型的结构体）这个结构体包含了事件类型和UART_DATA事件携带的数据。 123456789/** * @brief Event structure used in UART event queue */typedef struct { uart_event_type_t type; /*!&lt; UART 事件类型 */ size_t size; /*!&lt; UART 数据长度(仅UART_DATA 事件)*/ bool timeout_flag; /*!&lt; UART 超时标志(仅UART_DATA 事件)*/ /*!&lt; If the event is caused by FIFO-full interrupt, then there will be no event with the timeout flag before the next byte coming.*/} uart_event_t; 其中，uart_event_type_t包含以下事件： 1234567891011121314151617/** * @brief UART event types used in the ring buffer */typedef enum { UART_DATA, /*!&lt; UART data event UART数据事件*/ UART_BREAK, /*!&lt; UART break event UART中断事件*/ UART_BUFFER_FULL, /*!&lt; UART RX buffer full event UART RX缓冲区满事件*/ UART_FIFO_OVF, /*!&lt; UART FIFO overflow event UART FIFO溢出事件*/ UART_FRAME_ERR, /*!&lt; UART RX frame error event UART RX帧错误事件*/ UART_PARITY_ERR, /*!&lt; UART RX parity event UART奇偶检查错误*/ UART_DATA_BREAK, /*!&lt; UART TX data and break event UART TX数据和中断事件*/ UART_PATTERN_DET, /*!&lt; UART pattern detected UART 输入样式检测事件*/#if SOC_UART_SUPPORT_WAKEUP_INT UART_WAKEUP, /*!&lt; UART wakeup event */#endif UART_EVENT_MAX, /*!&lt; UART event max index*/} uart_event_type_t; 其中，最后一个事件UART_PATTERN_DET是使用uart_enable_pattern_det_baud_intr()启用pattern detect后的触发事件，用于解析特定格式的数据如AT+CGMI。 安装完驱动后，当有事件发生时，会自动向队列中填充信息，一般使用一个任务来进行及时处理。 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"driver/uart.h\"static QueueHandle_t uart0_queue;...static void uart_event_task(void *pv){ uart_event_t event; uint8_t d; while(1) { if(xQueueReceive(uart0_queue, (void * )&amp;event, (TickType_t)portMAX_DELAY)) { ESP_LOGI(TAG,\"A event in\"); switch (event.type) { case UART_DATA: uart_read_bytes(UART_NUM_0,&amp;d,1,(TickType_t)portMAX_DELAY); uart_write_bytes(UART_NUM_0, &amp;d, 1); break; case UART_BREAK: break; case ...: break; ... default: //ESP_LOGI(TAG, \"uart event type: %d\", event.type); break; } } }}...void app_main(void){ ... uart_driver_install(UART_NUM_0,1024,512,20,&amp;uart0_queue,0); ... xTaskCreate(uart_event_task, \"uart_event_task\", 2048, NULL, 12, NULL);} 删除驱动1esp_err_t uart_driver_delete(uart_port_t uart_num); 使用该函数释放资源。 三，高级用法其他模式UART 控制器支持多种通信模式，使用函数 uart_set_mode()可以选择模式。选择特定模式后，UART 驱动程序将处理已连接 UART 设备的相应行为。 1esp_err_t uart_set_mode(uart_port_t uart_num, uart_mode_t mode); 参数： mode使用的模式 该函数必须在uart_driver_install()之后使用。 支持的参数如下： 参数 模式 UART_MODE_UART 普通UART UART_MODE_RS485_HALF_DUPLEX half duplex RS485 UART mode control by RTS pin UART_MODE_IRDA 类似于红外协议的模式 UART_MODE_RS485_COLLISION_DETECT RS485 collision detection UART mode (used for test purposes) UART_MODE_RS485_APP_CTRL application control RS485 UART mode (used for test purposes) 具体使用参考官方文档 pattern_detect在检测到重复接收/发送同一字符的“模式”时触发中断。例如，模式检测可用于检测命令字符串末尾是否存在特定数量的相同字符（“模式”）。 配置并启用此中断：调用 uart_enable_pattern_det_baud_intr() 禁用中断：调用 uart_disable_pattern_det_intr() 用法参见peripherals/uart/uart_events 自定义UART中断如果不想使用默认的 UART 中断（如上文的 UART 事件 Queue 等高级API）或者自己另有别的绝妙之用，可以注册自己的UART中断。 使用 uart_isr_register() 注册中断 使用 uart_isr_free() 释放注册的中断 写的中断 ISR 程序需要尽可能简短，不要忘了在处理中断前后调用uart_clear_intr_status()清除中断标志。 一些宏12345678910111213141516171819202122232425UART_GPIO43_DIRECT_CHANNELUART_NUM_0_TXD_DIRECT_GPIO_NUMUART_GPIO44_DIRECT_CHANNELUART_NUM_0_RXD_DIRECT_GPIO_NUMUART_GPIO16_DIRECT_CHANNELUART_NUM_0_CTS_DIRECT_GPIO_NUMUART_GPIO15_DIRECT_CHANNELUART_NUM_0_RTS_DIRECT_GPIO_NUMUART_TXD_GPIO43_DIRECT_CHANNELUART_RXD_GPIO44_DIRECT_CHANNELUART_CTS_GPIO16_DIRECT_CHANNELUART_RTS_GPIO15_DIRECT_CHANNELUART_GPIO17_DIRECT_CHANNELUART_NUM_1_TXD_DIRECT_GPIO_NUMUART_GPIO18_DIRECT_CHANNELUART_NUM_1_RXD_DIRECT_GPIO_NUMUART_GPIO20_DIRECT_CHANNELUART_NUM_1_CTS_DIRECT_GPIO_NUMUART_GPIO19_DIRECT_CHANNELUART_NUM_1_RTS_DIRECT_GPIO_NUMUART_TXD_GPIO17_DIRECT_CHANNELUART_RXD_GPIO18_DIRECT_CHANNELUART_CTS_GPIO20_DIRECT_CHANNELUART_RTS_GPIO19_DIRECT_CHANNEL","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-工程结构","slug":"ESP-IDF学习笔记-工程结构","date":"2023-04-23T08:46:54.000Z","updated":"2023-05-29T15:37:47.754Z","comments":true,"path":"post/42346/","link":"","permalink":"https://lostacnet.top/post/42346/","excerpt":"ESP-IDF学习笔记-工程结构学习ESP-IDF的使用，首先得要学习一个IDF工程的结构。ESP-IDF的工程是以Cmake组织的，并使用了Ninja作为构建工具，这里只简单给出如何使用这套系统。","text":"ESP-IDF学习笔记-工程结构学习ESP-IDF的使用，首先得要学习一个IDF工程的结构。ESP-IDF的工程是以Cmake组织的，并使用了Ninja作为构建工具，这里只简单给出如何使用这套系统。 官方文档 参考于 一，目录结构一个IDF工程一般有以下结构的目录： 123456789101112131415- myProject/ - CMakeLists.txt - sdkconfig - components/ - component1/ - CMakeLists.txt - Kconfig - src1.c - component2/ - CMakeLists.txt - Kconfig - src1.c - include/ - component2.h - main/ - CMakeLists.txt - src1.c - src2.c - build/ 顶层目录的CMakeList.txt：这是整个项目的CMake文件，其中引入了/tools/cmake/project.cmake用来构建其他部分。同时设置了工程名。 sdkconfig：项目配置文件，使用idf.py menuconfig配置在IDE中对应设置按钮出现的菜单。在菜单中的配置以宏定义的方式出现在源码中。 main：特殊的目录，包含项目本身的源码，被认为是mian组件。 build：编译结果 components：（可选）组件，即各种库。 项目CMakeLists该文件配置整个项目，通常十分小。最小情况如下: 123cmake_minimum_required(VERSION 3.16)include($ENV{IDF_PATH}/tools/cmake/project.cmake)project(myProject) cmake_minimum_required(VERSION 3.16) 必须放在 CMakeLists.txt 文件的第一行，它会告诉 CMake 构建该项目所需要的最小版本号。ESP-IDF 支持 CMake 3.16 或更高的版本。 include($ENV{IDF_PATH}/tools/cmake/project.cmake) 会导入 CMake 的其余功能来完成配置项目、检索组件等任务。 project(myProject) 会创建项目本身，并指定项目名称。该名称会作为最终输出的二进制文件的名字，即 myProject.elf 和 myProject.bin。每个 CMakeLists 文件只能定义一个项目。 同时该文件可以配置一些全局变量用来修改默认值自定义构建系统： COMPONENT_DIRS：组件的搜索目录，默认为 IDF_PATH/components、 PROJECT_DIR/components、和 EXTRA_COMPONENT_DIRS。如果您不想在这些位置搜索组件，请覆盖此变量。 EXTRA_COMPONENT_DIRS：用于搜索组件的其它可选目录列表。路径可以是相对于项目目录的相对路径，也可以是绝对路径。 COMPONENTS：要构建进项目中的组件名称列表，默认为 COMPONENT_DIRS 目录下检索到的所有组件。使用此变量可以“精简”项目以缩短构建时间。请注意，如果一个组件通过 COMPONENT_REQUIRES 指定了它依赖的另一个组件，则会自动将其添加到 COMPONENTS 中，所以 COMPONENTS 列表可能会非常短。 使用 cmake 中的 set 命令 来设置这些变量，如 set(VARIABLE \"VALUE\")。请注意，set() 命令需放在include(...)之前，cmake_minimum(...) 之后。 组件CMakeList.txt组件是 COMPONENT_DIRS 列表中的任何包含CMakeList.txt目录。IDF按以下顺序搜索组件，如果有多个同名组件，以最后一个为准。 搜索 ESP-IDF 内部组件（$ENV{IDF_PATH}/components） 搜索 EXTRA_COMPONENT_DIRS 中的组件 搜索项目组件（$ENV{PROJECT_DIR}/components） 组件最小CMakeList如下： 1234idf_component_register( SRCS \"foo.c\" \"cplus.cpp\" INCLUDE_DIRS \"include\") SRCS：源文件列表 INCLUDE_DIRS：组件的include目录，会被添加到头文件搜索目录中 除此之外，还有一些非必须的变量： REQUIRES：申明组件的共用依赖，一般就是头文件中include的其他组件 PRIV_REQUIRES：申明组件的私有依赖，一般是源文件中include的其他组件 …. 其中main也是一个组件，但其默认依赖所有组件。 二，配置菜单IDF中将组件的配置以宏定义的形式移出代码，放进idf的meunconfig中进行配置。在项目的任意位置，都可以使用#include \"sdkconfig.h“进行访问。 配置文件种类 文件名 位置 作用 Kconfig 组件(手动创建) 在menuconfig中的菜单中创建Component Configuration子菜单 Kconfig.projbuild 组件(手动创建) 在menuconfig中创建顶层菜单 sdkconfig 工程(自动生成) 保持配置 sdkconfig.h 工程编译文件(自动生成) 配置的访问接口 sdkconfig.default 工程(手动创建) 配置的默认值 sdkconfig.old 工程(自动生成) 备份 sdkconfig.ci 用于单元测试 sdkconfig.rename 用于重命名弃用的配置名，方便旧配置文件快速用于新配置，兼容 sdkconfig.default可为不同设备添加默认配置,如:sdkconfig.default.esp32s3 创建菜单官方文档 创建菜单在Kconfig或者Kconfig.projbuild中按照特定语法进行创建。 具体语法可以参考这篇文章 这里直接给出该文章的中的例子： 123456789101112131415161718192021222324252627282930313233343536menu \"My menu\" # bool 是勾选框 config MY_TEST_BOOL bool \"bool_test\" help This is a bool test. # int 是输入整数 config MY_TEST_INT int \"int_test\" default 12345 help This is an int test. # hex 是输入16进制数 config MY_TEST_HEX hex \"hex_test\" default 0x7FFF help This is a hex test. # tristate 在 ESP-IDF构建系统中会被当做 bool 处理 config MY_TEST_TRISTATE tristate \"tristate_test\" help This is a tristate test. # string 表示一个字符串 config MY_TEST_STRING string \"string_test\" help This is a string test.endmenu 生成的宏定义是： 1234#define CONFIG_MY_TEST_BOOL 1#define CONFIG_MY_TEST_INT 12345#define CONFIG_MY_TEST_HEX 0x7FFF#define CONFIG_MY_TEST_STRING \"ESP32 YYDS\" 宏定义的结构是:CONFIG_+配置名 创建选项菜单: 12345678910111213141516171819202122232425menu \"My Menu\" choice MY_TEST_CHOICE prompt \"My Test Choice\" default MY_CHOICE_OPTION1 help This is a help. config MY_CHOICE_OPTION1 bool \"option1\" help help for option1 config MY_CHOICE_OPTION2 bool \"option2\" help help for option2 config MY_CHOICE_OPTION3 bool \"option3\" help help for option3 endchoiceendmenu 生成的宏定义： 1#define CONFIG_MY_CHOICE_OPTION_1","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-错误处理","slug":"ESP-IDF学习笔记-错误处理","date":"2023-04-20T17:18:45.000Z","updated":"2024-02-09T14:14:37.341Z","comments":true,"path":"post/42118/","link":"","permalink":"https://lostacnet.top/post/42118/","excerpt":"ESP-IDF学习笔记-错误处理同STM32HAL库的各种错误状态码一样，ESP-IDF中也有不同的错误码以及相应的错误处理方法，这给出基本的使用。","text":"ESP-IDF学习笔记-错误处理同STM32HAL库的各种错误状态码一样，ESP-IDF中也有不同的错误码以及相应的错误处理方法，这给出基本的使用。 首先放上官方文档 一，错误的分类ESP32中主要有两类错误： 可恢复错误 可用错误状态码表示，使用 throw 关键字抛出的 C++ 异常。 不可恢复（严重）错误 断言失败：（使用 assert 宏或者其它类似方法，可参考 Assertions）或者直接调用 abort() 函数造成的错误 CPU 异常：访问受保护的内存区域、非法指令等 系统级检查：看门狗超时、缓存访问错误、堆栈溢出、堆栈粉碎、堆栈损坏等 二，错误码与错误消息在ESP-IDF中，错误码的类型是esp_err_t，本质是带符号整型。其中表示没有错误的定义是：ESP_OK具体定义为0。 对于一个具体的错误，错误码常常以ESP_ERR_XXX形式呈现，常见的错误码在esp_err.h中已经定义好了，各个组件也可以自定义。 得到整型的错误码可以使用esp_err_to_name()或者esp_err_to_name_r()函数(esp_err.h)将其转换为字符串(返回值是const char *)，这两个函数的区别主要在于当没有匹配的错误时，是否用 标准 POSIX 错误代码 进行解释。 三，常用宏 ESP_ERROR_CHECK 该宏定义在esp_err.h中。功能与assert相似，但是会检测错误值并打印错误信息，最后调用abort()。 通常错误信息如下: 1234567ESP_ERROR_CHECK failed: esp_err_t 0x107 (ESP_ERR_TIMEOUT) at 0x400d1fdffile: \"/Users/user/esp/example/main/main.c\" line 20func: app_mainexpression: sdmmc_card_init(host, &amp;card)Backtrace: 0x40086e7c:0x3ffb4ff0 0x40087328:0x3ffb5010 0x400d1fdf:0x3ffb5030 0x400d0816:0x3ffb5050 ESP_ERROR_CHECK_WITHOUT_ABORT 该宏定义在esp_err.h中。功能与ESP_ERROR_CHECK一样，但不会调用abort()。 以下宏定义在esp_check.h ESP_RETURN_ON_ERROR 宏 ESP_RETURN_ON_ERROR 用于错误码检查, 如果错误码不等于 ESP_OK, 该宏会打印错误信息，并使原函数立刻返回。 ESP_GOTO_ON_ERROR 宏 ESP_GOTO_ON_ERROR 用于错误码检查, 如果错误码不等于 ESP_OK, 该宏会打印错误信息，将局部变量 ret 赋值为该错误码, 并使原函数跳转至给定的 goto_tag. ESP_RETURN_ON_FALSE 宏 ESP_RETURN_ON_FALSE 用于条件检查, 如果给定条件不等于 true, 该宏会打印错误信息，并使原函数立刻返回，返回值为给定的 err_code. ESP_GOTO_ON_FALSE 宏 ESP_GOTO_ON_FALSE 用于条件检查, 如果给定条件不等于 true, 该宏会打印错误信息，将局部变量 ret 赋值为给定的 err_code, 并使原函数跳转至给定的 goto_tag. ESP_RETURN_xx 和 ESP_GOTO_xx 宏不可以在中断服务程序里被调用。 使用例: 1234567891011121314151617static const char* TAG = \"Test\";esp_err_t test_func(void){ esp_err_t ret = ESP_OK; ESP_ERROR_CHECK(x); // err message printed if `x` is not `ESP_OK`, and then `abort()`. ESP_ERROR_CHECK_WITHOUT_ABORT(x); // err message printed if `x` is not `ESP_OK`, without `abort()`. ESP_RETURN_ON_ERROR(x, TAG, \"fail reason 1\"); // err message printed if `x` is not `ESP_OK`, and then function returns with code `x`. ESP_GOTO_ON_ERROR(x, err, TAG, \"fail reason 2\"); // err message printed if `x` is not `ESP_OK`, `ret` is set to `x`, and then jumps to `err`. ESP_RETURN_ON_FALSE(a, err_code, TAG, \"fail reason 3\"); // err message printed if `a` is not `true`, and then function returns with code `err_code`. ESP_GOTO_ON_FALSE(a, err_code, err, TAG, \"fail reason 4\"); // err message printed if `a` is not `true`, `ret` is set to `err_code`, and then jumps to `err`.err: // clean up return ret;} 如果 Kconfig 中的 CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT 选项被打开, CHECK 宏将不会打印错误信息，其他功能不变。 四，错误处理根据错误码恢复用变量储存错误码，在代码中判断错误码类型，根据类型不同尝试恢复。或者使用上面用到的CHECK宏。 转化为不可恢复错误使用ESP_ERROR_CHECK处理返回值。 1ESP_ERROR_CHECK(spi_bus_initialize(host, bus_config, dma_chan)); 五，严重错误以下情况为不可恢复的严重错误，程序会中断重启。 CPU 异常：非法指令，加载/存储时的内存对齐错误，加载/存储时的访问权限错误，双重异常。 系统级检查错误： 中断看门狗 超时 任务看门狗 超时（只有开启 CONFIG_ESP_TASK_WDT_PANIC 后才会触发严重错误） 高速缓存访问错误 内存保护故障 掉电检测事件 堆栈溢出 堆栈粉碎保护检查 堆完整性检查 未定义行为清理器 (UBSAN) 检查 使用 assert、configASSERT 等类似的宏断言失败。 官方文档给出了参考解决，这里先待补，等以后接触后继续。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-调试等级打印","slug":"ESP-IDF学习笔记-调试等级打印","date":"2023-04-20T14:56:23.000Z","updated":"2023-05-29T15:37:15.930Z","comments":true,"path":"post/42056/","link":"","permalink":"https://lostacnet.top/post/42056/","excerpt":"ESP-IDF学习笔记-调试等级打印ESP32IDF中提供了一个LOG库，根据不同调试等级打印信息，这里记录一下简单用法。","text":"ESP-IDF学习笔记-调试等级打印ESP32IDF中提供了一个LOG库，根据不同调试等级打印信息，这里记录一下简单用法。 官方的LOG库文档 官方给的库用法很多还有一些高级用法，但是我们只需要使用简单的就行了。 一，调试级别ESP32LOG库定义的如下调试级别(按等级高低从低到高排列)： ESP_LOGE - error (lowest) ESP_LOGW - warning ESP_LOGI - info ESP_LOGD - debug ESP_LOGV - verbose (highest) 对应的在IDF中的调试级别设置如图: 对应的设置选项为： CONFIG_LOG_DEFAULT_LEVEL:默认调试级别 CONFIG_LOG_MAXIMUM_LEVEL:最高调试级别 高于默认调试级别的调试信息不会打印。 CONFIG_LOG_MAXIMUM_LEVEL用来设置esp_log_level_set() 可以设置的最高级别的调试等级(代码中动态调整调试等级)。 剩下一个设置项用来设置调试时间戳的来源，可以设置为来自于FreeRTos的时基，从系统重启后到现在的ms；或者为实际时间，来自RTC外设（可通过SNTP在重启置0后校准）。 二，API函数常用函数如下： 123456789101112131415//打印调试信息ESP_LOGE();//error (lowest)ESP_LOGW();//warningESP_LOGI();//infoESP_LOGD();//debugESP_LOGV();//verbose (highest)//设置调试等级void esp_log_level_set(const char *tag, esp_log_level_t level);//设置TAG的调试等级esp_log_level_t esp_log_level_get(const char *tag);//获得TAG的调试等级 使用方法： 定义TAG 123static const char* TAG = \"MyModule\";//others#define TAG \"MyModule\" 调用打印函数 1ESP_LOGW(TAG, \"Baud rate error %.1f%%. Requested: %d baud, actual: %d baud\", error * 100, baud_req, baud_real); 通过在esp_log.h前定义LOG_LOCAL_LEVEL来重新设置默认调试等级: 12#define LOG_LOCAL_LEVEL ESP_LOG_VERBOSE#include \"esp_log.h\" 对于组件(component)可以在CMakeLists中设置来重设: 1target_compile_definitions(${COMPONENT_LIB} PUBLIC \"-DLOG_LOCAL_LEVEL=ESP_LOG_VERBOSE\") 可以通过``在运行时设置各个TAG的调试等级： 123esp_log_level_set(\"*\", ESP_LOG_ERROR); // set all components to ERROR levelesp_log_level_set(\"wifi\", ESP_LOG_WARN); // enable WARN logs from WiFi stackesp_log_level_set(\"dhcpc\", ESP_LOG_INFO); // enable INFO logs from DHCP client 三，高级用法输出端口默认情况下，日志输出到串口，使用类vsprintf函数。 通过调用以下函数，可以将输出定向到JATG： 1esp_log_set_vprintf(esp_apptrace_vprintf); 如果想重新设置回UART： 1esp_log_set_vprintf(vprintf); 其他输出API1ESP_EARLY_LOGx() 在系统早期启动过程使用：在堆分配前和系统调用前使用 1ESP_DRAM_LOGx() 在中断被关闭或者Flash缓存无法访问时使用，由于对系统性能考虑，应尽可能少使用。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"对带通采样定理的理解","slug":"对带通采样定理的理解","date":"2023-04-01T08:29:57.000Z","updated":"2024-03-26T15:37:42.132Z","comments":true,"path":"post/4129/","link":"","permalink":"https://lostacnet.top/post/4129/","excerpt":"对带通采样定理的理解奈奎斯特采样定理要求采样频率必须大于信号频率的2倍，不然会发生频谱混叠。但是对于高频信号，ADC难以达到所需要的采样率。实际上，我们进行频谱分析时，只需要让我们需要信号的频率不发生频谱混叠就行了，由此就出现了带通采样定理。","text":"对带通采样定理的理解奈奎斯特采样定理要求采样频率必须大于信号频率的2倍，不然会发生频谱混叠。但是对于高频信号，ADC难以达到所需要的采样率。实际上，我们进行频谱分析时，只需要让我们需要信号的频率不发生频谱混叠就行了，由此就出现了带通采样定理。 本文参考于带通采样定理及其公式推导 一，奈奎斯特采样定理和带通采样定理奈奎斯特采样定理奈奎斯特采样定理又称低通采样定理。其“低通”的含义是从0频率到信号中角频率最大的分量都能复原，不发生频谱混叠。这样就要求以0为中心2*w宽度的频段都必须没有重叠： 这就是所谓低通。 但这样会导致两个中心频率相距至少要2*w以上，即采样频率为原信号的两倍，对采样率要求极为苛刻。 更多信息可见我的另外一篇博客:对Nyquist-Shannon采样定理的直观理解 带通采样定理很多时候，我们的关注的信号频率主要集中于高频段，对低频信号不关心。如图，我们只关心高频很窄的一段信号： 这就是所谓带通。 二，带通采样定理理解什么是带通后，我们对其进行分析。 对于奈奎斯特采样定理，我们要求采样频率在我们关心的频率范围内（0-最大频率分量）不发生频谱叠加。因此对于带通采样，我们同样只要求在我们需要的频率内不发生频谱叠加。 随着采样率的增加，采样信号频谱周期延拓的周期越来越大，在这个过程中，我们只需要取带通的频谱不重叠的采样频率就行了。 （偷一下氧离子大佬的图） 红色的是原信号，绿色和蓝色是采样导致的周期延拓出来的信号。 可以看到，我们只需要保证绿色和蓝色的频谱不和红色的频谱重合，就不会发生频谱重叠，我们依然可以得到想要的信号。 将上面的要求用数学公式表达出来：那么就可以得出采样频率的要求是：显然，存在条件是：方框代表向下整，为整数可见，当m=0，就是奈奎斯特采样定理。 三，一个例子假设一个信号的频率在45-55MHz的范围，那么对采样率的要求是 那么可以得到： 最小采样率被降低到了原来的二分之一左右。","categories":[{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"}],"tags":[{"name":"带通采样","slug":"带通采样","permalink":"https://lostacnet.top/tags/%E5%B8%A6%E9%80%9A%E9%87%87%E6%A0%B7/"}]},{"title":"对Nyquist-Shannon采样定理的直观理解","slug":"对Nyquist-Shannon采样定理的直观理解","date":"2023-04-01T02:54:53.000Z","updated":"2024-03-26T15:37:18.581Z","comments":true,"path":"post/4154/","link":"","permalink":"https://lostacnet.top/post/4154/","excerpt":"对Nyquist-Shannon采样定理的直观理解奈奎斯特(香农)采样定理是信号采样中需要遵守的重要定理，即采样频率至少为信号频率的两倍，才能还原原信号。这里给出对其原理的直观理解。","text":"对Nyquist-Shannon采样定理的直观理解奈奎斯特(香农)采样定理是信号采样中需要遵守的重要定理，即采样频率至少为信号频率的两倍，才能还原原信号。这里给出对其原理的直观理解。 一，时域与频域的联系在讨论具体的采样定理前，首先需要一点基础。 在信号与系统中我们学到，对一个冲激信号，其在频域上是1。而对于1，频域上是一个冲激。如果将1视为周期无限小的冲激信号，但冲激信号的周期从无限小到无限大时，频域上的最开始周期无限大的周期信号也逐渐变成周期无限小的周期信号，最终变成1。 那么从这个过程我们可以得到直观的结论： 时域连续，频域离散，反之亦然。 采样后的信号频谱是原始信号频谱的周期延拓，延拓周期就是采样角频率。 对于第二个结论，这里有着科学的证明：采样定理推导(The Nyquist–Shannon sampling theorem)（本文章的图也来自于这里） 二，采样定理知道采样信号的频谱是原信号的周期延拓后，我们就可以直接理解采样定理了。 如果一个信号的频谱为下图这样： 图中的w是该信号中频率最大的信号分量，这个区间内的信号就原信号的全部频谱。 那么对该信号进行采样后，频谱就会变成该信号的周期延拓: Wo就是采样的角频率，在上图情况中，采样频率小于信号频率的两倍，导致频谱间相互叠加，原信号无法复原。 当采样频率大于信号频率的两倍时，频谱就不会叠加了。这时可以得到原来的信号。","categories":[{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"}],"tags":[{"name":"奈奎斯特(香农)采样定理","slug":"奈奎斯特-香农-采样定理","permalink":"https://lostacnet.top/tags/%E5%A5%88%E5%A5%8E%E6%96%AF%E7%89%B9-%E9%A6%99%E5%86%9C-%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86/"}]},{"title":"频谱泄露与窗函数","slug":"频谱泄露与窗函数","date":"2023-03-29T15:52:30.000Z","updated":"2024-03-26T15:37:57.208Z","comments":true,"path":"post/32952/","link":"","permalink":"https://lostacnet.top/post/32952/","excerpt":"频谱泄露与窗函数在FFT(傅里叶变换)分析信号时，常常会提到频谱泄露现象，即某频率谱线的幅值分布到其他频段。这样会严重影响信号频率和幅度的判断，为了减轻这种现象，使用窗函数进行截取，即加窗。","text":"频谱泄露与窗函数在FFT(傅里叶变换)分析信号时，常常会提到频谱泄露现象，即某频率谱线的幅值分布到其他频段。这样会严重影响信号频率和幅度的判断，为了减轻这种现象，使用窗函数进行截取，即加窗。 一，频谱泄露现象对原信号做非周期截断后进行FFT，得到的频率谱线会出现旁瓣，即出现原信号频率之外的的频谱，同时原信号幅度降低，可视为原信号的能量泄露到附近频点上。 非周期截断： 做FFT后有频谱泄露： 二，周期截断与非周期截断信号截断由于实际信号处理时，我们不可能将整个原始信号进行FFT，只能截取信号的一部分进行处理，这个过程就叫信号截断。 根据截取信号的长度与周期的关系，可以分为周期截断和非周期截断。 周期截断如果截取信号的长度为原信号周期的整数倍，则截断后的信号依然为周期信号，可以重构为原始信号，进行FFT后的频谱频率成分为原信号频率，100%幅度。 假设原始信号的频率为f Hz，则周期为1/f s，截取信号的时间长度为T=k/f。则频率分辨率为1/T=f/k。那么原信号频率成分为f=k*1/T，即有一条谱线正好是原信号频率成分。 非周期截断如果截取信号的长度不是原信号周期的整数倍，则截断后的信号不是周期信号，重构出来的信号不连续，出现跳跃。 对这种信号进行FFT后，频谱会分散，原信号频率成分的幅值不再是100%。反而原信号周围谱线出现幅值，即泄露到了周围频谱。 非周期截断中，没有一条谱线与原信号完全相同。 三，FFT变换根据傅里叶变换的推导，我们可以知道周期信号可以用傅里叶级数表示，即使用频谱中的一些离散点表示。而对非周期信号，只能用连续的频谱去无限逼近，因此非周期截断会出现泄露。 四，窗函数引入窗函数前，先来直观理解一下什么是窗。我们对信号进行截断，就好像在信号上面套了一个窗户，我们只能看见窗户里面的信号，用这里面的信号去分析原信号。这就是加窗的直观理解。 为什么要使用窗函数窗函数就是给窗内信号的每个点都加上一个权值，使窗内信号的起始和截止幅度都为0，让窗里面的信号变成周期信号，从而减少频谱泄露(不能消除)。 常见窗函数各种窗函数频谱特征的主要差别在于：主瓣宽度（也称为有效噪声带宽，ENBW）、幅值失真度、最高旁瓣高度和旁瓣衰减速率等参数。不同的窗函数具有不同的频谱特征。 主瓣宽度主要影响信号能量分布和频率分辨能力。频率的实际分辨能力为有效噪声带宽乘以频率分辨率，因此，主瓣越宽，有效噪声带宽越宽，在频率分辨率相同的情况下，频率的分辨能力越差。 旁瓣高低及其衰减率影响能量泄漏程度（频谱拖尾效应）。旁瓣越高，说明能量泄漏越严重，衰减越慢，频谱拖尾越严重。 矩形窗如果直接对信号截断，则窗内的信号权重都为1，这种窗称为矩形窗。 这种窗的优点是主瓣比较集中，缺点是旁瓣较高，而且可能伴有负旁瓣，频谱泄漏 现象会较为严重. 特点就是可以保证测量时的频率较为精确，但是不能保证幅值测量的精确性. 三角窗三角窗使用渐进的权重，让边界处的信号为0，这种窗其主瓣宽度比矩形窗宽约一倍，旁瓣 相比于矩形窗非常小，测幅度会准一些但测频率就差。 汉宁窗汉宁窗会增加主瓣宽度，导致频率分辨率下降。 汉明窗汉明窗和汉宁窗基本一致，不一致的只有一个参数。 凯泽窗 其中 N 为序列的长度，I0 的零阶的第一类修正贝塞尔函数，α 是任意非负实数，用于调整凯 泽窗的外形，由使用者根据实际情况给定。 平顶窗 常见窗函数参数 根据此表可以估计窗函数性能，帮助选择。 窗函数选择加窗函数时，应使窗函数频谱的主瓣宽度应尽量窄，以获得高的频率分辨能力；旁瓣衰减应尽量大，以减少频谱拖尾，但通常都不能同时满足这两个要求。因此需要根据实际需求选择合适窗函数。 这里给出一个参考： 如果截断的信号仍为周期信号，则不存在泄漏，无须加窗，相当于加矩形窗。 如果信号是随机信号或者未知信号，或者有多个频率分量，测试关注的是频率点而非能量大小，建议选择汉宁窗。 对于校准目的，则要求幅值精确，平顶窗是个不错的选择。 如果同时要求幅值精度和频率精度，可选择凯塞窗。 如果检测两个频率相近、幅值不同的信号，建议用布莱克曼窗。 锤击法试验力信号加力窗，响应可加指数窗。","categories":[{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"}],"tags":[{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"https://lostacnet.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"加窗","slug":"加窗","permalink":"https://lostacnet.top/tags/%E5%8A%A0%E7%AA%97/"}]},{"title":"对傅里叶变换的一些理解","slug":"对傅里叶变换的一些理解","date":"2023-03-29T15:02:20.000Z","updated":"2024-03-26T15:37:42.140Z","comments":true,"path":"post/32902/","link":"","permalink":"https://lostacnet.top/post/32902/","excerpt":"对傅里叶变换的一些理解傅里叶变换将时域信号变成频域信号，能对信号进行频域上的分析，是分析信号的重要手段。这里我记录一下我对傅里叶变换的过程理解。","text":"对傅里叶变换的一些理解傅里叶变换将时域信号变成频域信号，能对信号进行频域上的分析，是分析信号的重要手段。这里我记录一下我对傅里叶变换的过程理解。 一，基本知识这里不加证明的给出几条基本知识： 任何周期信号都能够用傅里叶级数表示，即写成 形式。 是傅里叶级数系数，也称频率谱线，表示一个频率所占信号成分的的多少，其表达式为。 二，非周期函数的傅里叶变换周期函数的傅里叶变换就是将其写成傅里叶级数的形式，便可得到频谱。而对于不能写成傅里叶级数形式的非周期函数，可以将其视为的特殊情况，无限逼近。 对周期函数有：当时，可以得到：无限大，周期函数变非周期函数 无限小，变成微分 无限小，可以代表任何值，变成连续变量 变成连续的函数 那么定义一个X(jw)：则X(jw)是一个连续的频谱，值与**意义相同**。 现在再次看到周期函数的傅里叶变换，可以看到傅里叶级数是X(jw)的一系列离散点，而非周期函数是整个连续的频谱。 三，逆傅里叶变换周期函数的逆傅里叶变换就是傅里叶级数的形式：非周期函数的逆傅里叶变换则是将离散变连续:","categories":[{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"}],"tags":[{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"https://lostacnet.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"}]},{"title":"MSP432E4学习笔记:工程创建","slug":"MSP432E4学习笔记-工程创建","date":"2023-03-25T08:50:15.000Z","updated":"2023-05-29T15:40:48.253Z","comments":true,"path":"post/32550/","link":"","permalink":"https://lostacnet.top/post/32550/","excerpt":"MSP432E4学习笔记:工程创建由于Ti是电赛的大金主，在比赛中使用Ti的片子会带来优势。正好手头有一块MSP432E401Y(官板真是好看)，所以打算趁着周六强制考勤时间去入门一下。","text":"MSP432E4学习笔记:工程创建由于Ti是电赛的大金主，在比赛中使用Ti的片子会带来优势。正好手头有一块MSP432E401Y(官板真是好看)，所以打算趁着周六强制考勤时间去入门一下。 一，下载必要软件包Ti为MSP430E4提供了SDK。但是Ti官网的命名让人十分迷惑，关于MSP432可以在Ti官网找到两个包：MSP432WARE,SIMPLELINK-MSP432E4-SDK.经过实测，其中SIMPLELINK-MSP432E4-SDK是MSP432E4的SDK，另外一个是MSP432P的SDK(SBTi)。 下载后直接安装，安装完成后会自动打开版本手册和快速开始指导，其中快速指导中写了如何创建新的工程，包括使用CCS，IAR，Keil。我们这里使用Keil进行开发。 Download and Install Keil uVision 5.23 Install the TexasInstruments::MSP432E4xx_DFP pack Install the ARM::CMSIS pack 可以看到，我们还需要下载MSP432E4的keil PACK。 打开keil，进入Pack Installer。 在Devices中找到Ti的MSP432E4。 点击后，在右侧可以看见pack包，可以选择直接在软件中安装(很慢)，也可以选择自己到网页上下载。 这里为了快速下载，我们点击Device中芯片型号后面的蓝色链接打开keil官网，如下图，点击Download按钮直接下载Pack，下载完成后点击安装。 完成上述步骤后开发环境就配置好了，打开SDK安装目录下的点灯例程:examples\\nortos\\MSP_EXP432E401Y\\driverlib\\blinky,打开工程，编译。 将MSPE401Y开发板连接上电脑，这时电脑应该会自动配置驱动，配置完成后点击下载程序，就可以看见灯闪了。 二，创建新的工程（一）通过空工程创建在Quick_Start中，Ti告诉我们不要使用Keil自带的创建工程新建新的工程，要求基于其中的例程进行创建，也就是直接使用Ti给你创建好的工程进行开发。 Do not use the New Project Creation Wizard Start with one of the example projects or empty project template shipped inside the SDK. Each software component in the SDK comes with its own set of examples. If your project depends on multiple TI provided software libraries, start from the empty template then add the necessary components into your projects. Import one of the empty project template shown below to your IDE and start your application from there. All the necessary include paths and SDK specific defines if any are already part of the Empty Project Template 因此，直接打开:examples\\nortos\\MSP_EXP432E401Y\\driverlib\\empty空工程进行就可以进行开发了。 （二）使用Keil创建工程由于之前刚刚学会了如何脱离Cube创建STM32的工程，现在想自己实践一下亲自创建，所以打算手动创建一下Keil工程(浑身反骨)。 我们先打开编译过的blinky工程，首先看一下它的目录结构： 其中Blinky.c是类似于STM32中**main.c文件**，由用户创建。 打开system_msp432e401y,c观察，发现是和时钟频率有关的函数，很像STM32中的文件。 其他四个文件夹分别对应四种不同的开发环境，这里我们打开keil文件夹： 红框中的文件时打开keil编译后产生的，不用管。 .uvoptx结尾的文件是keil的工程，创建工程时建立。 .sct工程是Ti提供的链接文件，具体用途可以百度，但是我们发现Objects中也有一个sct文件，这是keil编译时自动生成的，上图目录中的sct文件其实没用（但是为了保证工程的正确性，最好还是使用Ti提供的sct文件）。 startup_msp432e401y_uvision.s就不用说了吧，经典的启动文件。 那么工程文件结构就看完了，是不是发现少了什么？对，各种奇怪的头文件不见了，然后还没有库函数文件。这些东西在哪呢？ 我们先打开工程文件，看一下keil的配置： 工程目录中可以看到之前在目录中看见的文件，这里多出来一个.a文件，经过查找，发现在simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4\\driverlib\\lib\\keil\\m4f中。 再查看头文件，发现在simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4 以及simplelink_msp432e4_sdk_4_20_00_12\\source\\third_party\\CMSIS\\Include 可以找到 那么到这里就可以知道了，主要的库文件都在E:\\TI\\simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4下面，接下来就可以开始创建工程了。 1，创建工程打开keil，点击新建工程，选择芯片为：MSP432E401Y。 新建完成后，我们将SDK安装目录\\source\\ti\\devices\\msp432e4打开，准备复制文件。 2，复制启动文件首先点开startup_system_files文件夹，将system_msp432e401y.c和keil文件夹中的startup_msp432e401y_uvision.s复制到工程目录下（我复制到了目录中的startup文件夹下） 3，复制连接文件点开linker_files\\keil文件夹，将MSP432E401Y.sct文件复制到工程目录。 4，复制头文件打开simplelink_msp432e4_sdk_4_20_00_12\\source文件夹，可以看到如下文件夹: ti：包含了Ti的各种文件，包括寄存器地址，基本驱动函数库 third_party:第三方的各种文件，包括ARM核的相关操作函数，fatfs文件系统,DSP等库 这里我们需要添加这两个文件夹的东西。 首先是ARM内核和编译器的文件: 打开simplelink_msp432e4_sdk_4_20_00_12\\source\\third_party\\CMSIS\\Include，根据我们使用的芯片(M4内核),以及编译器(gcc)选择添加头文件： cmsis_armcc.h cmsis_compiler.h cmsis_version.h core_cm4.h mpu_armv7.h 然后是Ti的库和启动函数文件： 打开simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4\\inc 将inc文件夹复制到工程目录。 其实不必全部复制，msp.h和msp432.h文件其实都是根据芯片选型定向到msp432e4xx.h。但是为了程序兼容性，还是一起复制。 5，复制driverlib文件点开driverlib文件夹，里面东西很多，都是基本的驱动库。 inc定义了基本的寄存器基地址，MASK等等 xxx.h/xxx.c则是基本驱动库 lib包含了已经编译好的上述基本驱动库 这里可以选择通过源码添加(直接添加源文件)，也可以添加已经编译好的文件(这样在调试时就不好看寄存器操作了)，为了方便就直接添加lib。 首先将这个文件夹的头文件复制到工程目录(不包括inc中的文件)，然后复制lib中相应的.a文件到工程目录。 6，设置keil点开keil的工程设置，选择C/C++选项，添加Include路径: 工程中的inc文件 driverlib中的inc文件 然后选择Link选项，添加sct文件。 之后选择Debug选项，将调试器改为CMSIS-DAP: 然后添加工程文件: 然后修改文件中头文件的路径，让引用指向本地工程文件夹中的文件。 .a文件需要设置为库文件： 7，编译，下载将点灯工程的代码复制到我们新建的工程中，编译下载，可以看见成功运行。 三，后记相比于CubeMX创建工程，这个创建是真的麻烦，比STM32不用Cube创建都要麻烦。所以还是听官方的话吧，乖乖直接复制空工程开发。 但是这样麻烦还是有回报的：Ti的库文件基本都在本地工程中，可以随意修改而不怕影响到其他工程。不然全部工程共用一个库，肯定会有一堆问题。 其实Ti提供的东西还挺多的，SDK包含了DSP，文件系统，GUI等一堆东西，还有例程，但是这些东西藏的好深，没什么说明。","categories":[{"name":"MSP学习笔记","slug":"MSP学习笔记","permalink":"https://lostacnet.top/categories/MSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MSP432E4","slug":"MSP432E4","permalink":"https://lostacnet.top/tags/MSP432E4/"}]},{"title":"Typora与hexo的优雅结合:公式和图片","slug":"Typora与hexo的优雅结合-公式和图片","date":"2023-02-21T07:12:17.000Z","updated":"2024-03-26T15:36:21.058Z","comments":true,"path":"post/22112/","link":"","permalink":"https://lostacnet.top/post/22112/","excerpt":"Typora与hexo的优雅结合:公式和图片Typora是一款十分好用的Markdown编写软件，用它写文章可以大大提升工作效率。但是当我想将它用于博客编写时出现了一些问题：1，图片无法正常显示。2，latex公式无法显示。在这里我给出我的解决方法。","text":"Typora与hexo的优雅结合:公式和图片Typora是一款十分好用的Markdown编写软件，用它写文章可以大大提升工作效率。但是当我想将它用于博客编写时出现了一些问题：1，图片无法正常显示。2，latex公式无法显示。在这里我给出我的解决方法。 一，解决公式的显示由于学习方向的特殊性，有时我需要插入一些简单的公式。但是hexo自带的渲染器不支持渲染公式，因此需要引入渲染引擎。 网上常见的方法是使用hexo-math插件支持KaTex和MathJax引擎进行渲染，但是它的用法是这样的： 123{% mathjax %}\\frac{1}{x^2-1}{% endmathjax %} 非常的不优雅:D 因此需要配合其他插件使用(变的麻烦起来了)。对于我这种公式轻度使用者来说麻烦。 但是在hexo-math插件的github界面的最下面推荐了另一款轻量的hexo-filter-mathjax hexo-filter-mathjax: A MathJax plugin developed by @stevenjoezhang, who is also a Hexo developer. It enables you to write LaTeX in-line within your post without using a tag {% %}. hexo-math uses tag plugin approach due to minor incompatibility between LaTeX and marked, the default markdown renderer of Hexo (via hexo-renderer-marked). 可以直接用$来引入公式，和Typora的用法一样，十分的Nice。 根据插件的说明，我们需要卸载一些东西一避免冲突： 删除所有的hexo math plugins–npm uninstall 停止主题的公式渲染–一般在主题设置里面 删除关于公式渲染的插件 Tips:我在使用npm uninstall时发现一直删不掉，最后是先把package.json的无关插件依赖删掉，然后删除node_modules文件夹，然后直接重新npm 使用以下命令安装: 12npm install hexo-filter-mathjax --save //使用--save是将这个插件添加到package.json的依赖列表 然后使用hexo clean清除之前渲染的界面。 打开_config.yml，在文件末尾添加设置选项: 1234567891011mathjax: tags: none # or 'ams' or 'all' single_dollars: true # enable single dollar signs as in-line math delimiters cjk_width: 0.9 # relative CJK char width normal_width: 0.6 # relative normal (monospace) width append_css: true # add CSS to pages rendered by MathJax every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter packages: # extra packages to load extension_options: {} # you can put your extension options here # see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail 之后在文章的Front-matter中添加mathjax: true即可开启当前文章的公式渲染。（如果开启了配置中的every_page即可在每一页默认开启） 使用演示： 123$$THD={\\sqrt{x}}$$ 当然，出现复杂的公式就会出现问题： 123456789101112131415$$A = \\begin{bmatrix}a_{11} &amp; a_{12} &amp; ... &amp; a_{1n}\\\\a_{21} &amp; a_{22} &amp; ... &amp; a_{2n}\\\\a_{31} &amp; a_{22} &amp; ... &amp; a_{3n}\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\a_{n1} &amp; a_{n2} &amp; ... &amp; a_{nn}\\\\\\end{bmatrix} , b = \\begin{bmatrix}b_{1} \\\\b_{2} \\\\b_{3} \\\\\\vdots \\\\b_{n} \\\\\\end{bmatrix}$$ 但我一般用不到，就不管了。 二，解决图片的显示在文章中使用Markdown语法插入图片要面对Markdown语法转换问题，以及图片储存问题，还要考虑如何与Typora优雅的兼容。 1，使用本地储存图片第一种方法将图片储存在本地，在推送时一起上传到托管服务器。 这种方式有很多的插件，包括更换Markdown渲染器，以及图片插入插件来支持markdown的图片插入语法。但是根据hexo的官方文档，在最新版本的默认渲染器hexo-renderer-marked中，已经支持了这种插入方式。 启用方式： 打开_config.yml修改post_asset_folder:true，打开此项后会在使用hexo new命令时，在文章目录下新建同名的文件夹用来储存图片。 在_config.yml中添加： 123marked: prependRoot: true postAsset: true 启用后在文章中使用！[](image.jpg)将会自动解析到上述文件夹中的图片。 （但是这样会导致在本地浏览md文件时无法显示图片） 上述设置之后，打开Typora软件，在文件-&gt;偏好设置-&gt;图片中如下设置: 这样，在Typora中插入图片时，就会自动将图片复制到上面说的同名文件夹了。 然后，当我们写完文章时，注意进行全局替换：将图片路径中的文件夹路径删掉，只保留图片文件名称，这样hexo才能正常渲染。 这时推送后，图片文件会随着网页一起推送到托管网站。 但是这样又不优雅了，本地浏览看不见图片，推送到网站占用有限的空间，如果遇到github这种网站，图片半天加载不出。这时，就要使用图床。 2，使用图床如果使用图床保存图片的话，那么上面的hexo就不用设置。同时，Typora也提供了非常方便的上传设置，可以使用picgo或者自定义脚本进行上传。 首先，我们需要一个稳定的图床：这里我选择了路过图床。但是路过图床关闭了上传图片的API同时picgo也没有支持它的插件，因此需要自己去抓包写一个上传的脚本。 好在，有人已经写出来了(基于python)：up2b。 使用方法（首先确认已经安装python）： 安装up2b包: 1pip isntall up2b 使用以下命令设置路过图床 1up2b -c 1 设置账号 1up2b -l username password 此时就可以使用up2b命令上传图片了。 打开typora，进行如下设置： 点击验证看是否正常运行。 此时，向typora插入图片，会自动上传到图床，并且将图片连接换成网络链接。 这样，就可以在网页上和本地同时看到图片了。 up2b还提供了压缩图片和添加水印的功能，可以到它的主页查看用法。如果无法使用请到github上提issue。 这下看起来好像就万无一失了，但是图床的使用有一个大问题：不稳定。可能哪天你的图片就全部不见了，因此需要图片先存到本地再上传到图床。 3，本地储存+图床这里就不需要设置hexo了，保持默认就行。我们对Typora进行如下设置： 这样在插入图片时，会自动复制到本地文件夹中，当写好文章需要推送时，只需要点击格式-&gt;图像-&gt;上传全部本地图像，这样Typora就会自动上传所有本地图像到图床并且替换图片地址。保证了本地备份和使用图床。 优雅，太优雅了。","categories":[{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lostacnet.top/tags/hexo/"},{"name":"Typora","slug":"Typora","permalink":"https://lostacnet.top/tags/Typora/"}]},{"title":"第一篇博客","slug":"第一篇博客","date":"2023-02-18T17:11:55.000Z","updated":"2024-03-26T15:38:14.435Z","comments":true,"path":"post/21911/","link":"","permalink":"https://lostacnet.top/post/21911/","excerpt":"LO_StacNet的第一篇博客这里是LO_StacNet的第一篇博客，LO的学习之路将从这里开始.","text":"LO_StacNet的第一篇博客这里是LO_StacNet的第一篇博客，LO的学习之路将从这里开始. The Next In psot","categories":[{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"}],"tags":[{"name":"begin","slug":"begin","permalink":"https://lostacnet.top/tags/begin/"}]}],"categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"ZYNQ学习笔记","slug":"ZYNQ学习笔记","permalink":"https://lostacnet.top/categories/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"others","slug":"others","permalink":"https://lostacnet.top/categories/others/"},{"name":"STM32学习笔记","slug":"STM32学习笔记","permalink":"https://lostacnet.top/categories/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"CMake学习笔记","slug":"CMake学习笔记","permalink":"https://lostacnet.top/categories/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"树莓派Pico学习笔记","slug":"树莓派Pico学习笔记","permalink":"https://lostacnet.top/categories/%E6%A0%91%E8%8E%93%E6%B4%BEPico%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"51单片机学习笔记","permalink":"https://lostacnet.top/categories/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"c语言学习笔记","slug":"c语言学习笔记","permalink":"https://lostacnet.top/categories/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"CH32V307学习笔记","slug":"CH32V307学习笔记","permalink":"https://lostacnet.top/categories/CH32V307%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"FreeRTOS学习笔记","slug":"FreeRTOS学习笔记","permalink":"https://lostacnet.top/categories/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"LVGL学习笔记","slug":"LVGL学习笔记","permalink":"https://lostacnet.top/categories/LVGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MSP学习笔记","slug":"MSP学习笔记","permalink":"https://lostacnet.top/categories/MSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://lostacnet.top/tags/ZYNQ/"},{"name":"Linux","slug":"Linux","permalink":"https://lostacnet.top/tags/Linux/"},{"name":"IIC","slug":"IIC","permalink":"https://lostacnet.top/tags/IIC/"},{"name":"WSL","slug":"WSL","permalink":"https://lostacnet.top/tags/WSL/"},{"name":"Latex","slug":"Latex","permalink":"https://lostacnet.top/tags/Latex/"},{"name":"RMT","slug":"RMT","permalink":"https://lostacnet.top/tags/RMT/"},{"name":"中断","slug":"中断","permalink":"https://lostacnet.top/tags/%E4%B8%AD%E6%96%AD/"},{"name":"堆栈","slug":"堆栈","permalink":"https://lostacnet.top/tags/%E5%A0%86%E6%A0%88/"},{"name":"STM32","slug":"STM32","permalink":"https://lostacnet.top/tags/STM32/"},{"name":"网络","slug":"网络","permalink":"https://lostacnet.top/tags/%E7%BD%91%E7%BB%9C/"},{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"},{"name":"Clion","slug":"Clion","permalink":"https://lostacnet.top/tags/Clion/"},{"name":"rp2040","slug":"rp2040","permalink":"https://lostacnet.top/tags/rp2040/"},{"name":"OpenOCD","slug":"OpenOCD","permalink":"https://lostacnet.top/tags/OpenOCD/"},{"name":"vscode","slug":"vscode","permalink":"https://lostacnet.top/tags/vscode/"},{"name":"Arduino","slug":"Arduino","permalink":"https://lostacnet.top/tags/Arduino/"},{"name":"PlatformIO","slug":"PlatformIO","permalink":"https://lostacnet.top/tags/PlatformIO/"},{"name":"Cmake","slug":"Cmake","permalink":"https://lostacnet.top/tags/Cmake/"},{"name":"FLASH","slug":"FLASH","permalink":"https://lostacnet.top/tags/FLASH/"},{"name":"Chrome","slug":"Chrome","permalink":"https://lostacnet.top/tags/Chrome/"},{"name":"浏览器插件","slug":"浏览器插件","permalink":"https://lostacnet.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"},{"name":"STC89C52","slug":"STC89C52","permalink":"https://lostacnet.top/tags/STC89C52/"},{"name":"寻址空间","slug":"寻址空间","permalink":"https://lostacnet.top/tags/%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4/"},{"name":"CH32V307","slug":"CH32V307","permalink":"https://lostacnet.top/tags/CH32V307/"},{"name":"ld链接文件","slug":"ld链接文件","permalink":"https://lostacnet.top/tags/ld%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6/"},{"name":"内存分区","slug":"内存分区","permalink":"https://lostacnet.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"},{"name":"malloc","slug":"malloc","permalink":"https://lostacnet.top/tags/malloc/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://lostacnet.top/tags/RISC-V/"},{"name":"matlab","slug":"matlab","permalink":"https://lostacnet.top/tags/matlab/"},{"name":"图像处理","slug":"图像处理","permalink":"https://lostacnet.top/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"lvgl","slug":"lvgl","permalink":"https://lostacnet.top/tags/lvgl/"},{"name":"SDL","slug":"SDL","permalink":"https://lostacnet.top/tags/SDL/"},{"name":"MQTT","slug":"MQTT","permalink":"https://lostacnet.top/tags/MQTT/"},{"name":"带通采样","slug":"带通采样","permalink":"https://lostacnet.top/tags/%E5%B8%A6%E9%80%9A%E9%87%87%E6%A0%B7/"},{"name":"奈奎斯特(香农)采样定理","slug":"奈奎斯特-香农-采样定理","permalink":"https://lostacnet.top/tags/%E5%A5%88%E5%A5%8E%E6%96%AF%E7%89%B9-%E9%A6%99%E5%86%9C-%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86/"},{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"https://lostacnet.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"加窗","slug":"加窗","permalink":"https://lostacnet.top/tags/%E5%8A%A0%E7%AA%97/"},{"name":"MSP432E4","slug":"MSP432E4","permalink":"https://lostacnet.top/tags/MSP432E4/"},{"name":"hexo","slug":"hexo","permalink":"https://lostacnet.top/tags/hexo/"},{"name":"Typora","slug":"Typora","permalink":"https://lostacnet.top/tags/Typora/"},{"name":"begin","slug":"begin","permalink":"https://lostacnet.top/tags/begin/"}]}