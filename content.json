{"meta":{"title":"LO_StacNet的火柴盒","subtitle":"","description":"LO_StacNet的个人博客","author":"LO_StacNet","url":"https://lostacnet.top","root":"/"},"pages":[{"title":"About","date":"2023-02-19T07:34:05.646Z","updated":"2023-02-19T07:34:05.646Z","comments":false,"path":"about/index.html","permalink":"https://lostacnet.top/about/","excerpt":"","text":"Hello World!这是学习代码最开始的一句，也可以是学习的代码的最终。"},{"title":"Categories","date":"2023-02-18T16:20:28.686Z","updated":"2023-02-18T16:20:28.686Z","comments":false,"path":"categories/index.html","permalink":"https://lostacnet.top/categories/","excerpt":"","text":""},{"title":"Links","date":"2023-02-19T07:32:46.372Z","updated":"2023-02-19T07:32:46.372Z","comments":true,"path":"links/index.html","permalink":"https://lostacnet.top/links/","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-18T16:21:37.660Z","updated":"2023-02-18T16:21:37.660Z","comments":false,"path":"repository/index.html","permalink":"https://lostacnet.top/repository/","excerpt":"","text":""},{"title":"Tags","date":"2023-02-18T16:22:13.563Z","updated":"2023-02-18T16:22:13.563Z","comments":false,"path":"tags/index.html","permalink":"https://lostacnet.top/tags/","excerpt":"","text":""}],"posts":[{"title":"中兴F412在23端口禁用下使用telnet获取超级账户","slug":"中兴F412在23端口禁用下使用telnet获取超级账户","date":"2024-02-09T14:11:17.000Z","updated":"2024-02-09T14:22:28.258Z","comments":true,"path":"post/2911/","link":"","permalink":"https://lostacnet.top/post/2911/","excerpt":"中兴F412在23端口禁用下使用telnet获取超级账户常规情况下，可以直接使用telnet 192.168.1.1来进入光猫后台进行获取密码，但是现在会出现23端口被禁用问题，这里给出解决方法。","text":"中兴F412在23端口禁用下使用telnet获取超级账户常规情况下，可以直接使用telnet 192.168.1.1来进入光猫后台进行获取密码，但是现在会出现23端口被禁用问题，这里给出解决方法。 连接打开两个终端，其中一个输入： 1ping 192.168.1.1 -l 128 -t 另外一个负责telnet连接，输入： 1telnet 192.168.1.1 10128 输入账号密码： 12账号：root密码：Zte521 获取信息输入命令： 1sendcmd 1 DB p UserInfo 如果无效则: 1sendcmd 1 DB p DevAuthInfo Level用户组权限，1是超级管理员，2是普通用户 一般账户为telecomadmin，密码为telecomadminXXXXXXXX 如果输出太长看不到，可以使用grep命令: 1sendcmd 1 DB p DevAuthInfo | grep telecomadmin","categories":[{"name":"技巧","slug":"技巧","permalink":"https://lostacnet.top/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://lostacnet.top/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"CMake学习笔记-The C Compiler is not able to compile a simple test program","slug":"CMake学习笔记-The-C-Compiler-is-not-able-to-compile-a-simple-test-program","date":"2024-02-07T11:20:09.000Z","updated":"2024-02-07T11:35:50.251Z","comments":true,"path":"post/2720/","link":"","permalink":"https://lostacnet.top/post/2720/","excerpt":"The C Compiler is not able to compile a simple test program问题在使用arm-none-eabi-gcc.exe进行交叉编译时，cmake提示报错。此时编译器路径正确，构建器选择正确。但是还是报错not able to compile a simple test program。","text":"The C Compiler is not able to compile a simple test program问题在使用arm-none-eabi-gcc.exe进行交叉编译时，cmake提示报错。此时编译器路径正确，构建器选择正确。但是还是报错not able to compile a simple test program。 问题分析这是由于Cmake会对编译器进行自检来测试编译器能否使用，但是其默认标准是编译一个可执行文件并运行是否正确。但是在交叉编译的情况下，我们编译的结果是不能直接运行的，因此需要想办法跳过检查。 解决方法常规解决方法是在使用project()前调用set(CMAKE_TRY_COMPILE_TARGET_TYPE \"STATIC_LIBRARY\")。这样就不会去编译一个可执行文件。 参考回答CMake: The C Compiler is not able to compile a simple test program","categories":[{"name":"CMake学习笔记","slug":"CMake学习笔记","permalink":"https://lostacnet.top/categories/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"}]},{"title":"树莓派Pico学习笔记-Win下Clion环境搭建","slug":"树莓派Pico学习笔记-Win下Clion环境搭建","date":"2024-02-07T08:00:10.000Z","updated":"2024-02-07T13:14:19.755Z","comments":true,"path":"post/2700/","link":"","permalink":"https://lostacnet.top/post/2700/","excerpt":"树莓派Pico学习笔记-Win下Clion环境搭建最近掏出了吃灰已久的合宙RP2040，打算先搭建好环境，借助它学习一下win下交叉编译与调试环境的搭建，以及CMake与Clion的使用。","text":"树莓派Pico学习笔记-Win下Clion环境搭建最近掏出了吃灰已久的合宙RP2040，打算先搭建好环境，借助它学习一下win下交叉编译与调试环境的搭建，以及CMake与Clion的使用。 下载安装首先完成以下软件的安装： Clion CMake——C语言生成器(Clion自带) ninja——C语言构建器(同make，nmake功能)(Clion自带) git——主要用于从github下载代码 arm-gcc工具链——编译代码 mingw——win上的gcc，用来编译elf2uf2工具(Clion自带) OpenOCD——调试工具 Pico-SDK 注意添加到环境变量。 基于Clion创建工程目录将SDK/external目录下的pico_sdk_import.cmake复制到工程目录。 添加程序代码文件main.c： 1234567891011121314151617181920212223/** * Copyright (c) 2020 Raspberry Pi (Trading) Ltd. * * SPDX-License-Identifier: BSD-3-Clause */#include \"pico/stdlib.h\"int main() {#ifndef PICO_DEFAULT_LED_PIN#warning blink example requires a board with a regular LED#else const uint LED_PIN = PICO_DEFAULT_LED_PIN; gpio_init(LED_PIN); gpio_set_dir(LED_PIN, GPIO_OUT); while (true) { gpio_put(LED_PIN, 1); sleep_ms(250); gpio_put(LED_PIN, 0); sleep_ms(250); }#endif} 添加CMakeLists.txt: 1234567891011121314151617cmake_minimum_required(VERSION 3.13)# initialize the SDK directlyinclude(pico_sdk_import.cmake)project(picotest)# initialize the Raspberry Pi Pico SDKpico_sdk_init()add_executable(blink main.c)# pull in common dependenciestarget_link_libraries(blink pico_stdlib)# create map/bin/hex/uf2 file etc.pico_add_extra_outputs(blink) 添加工具链这里基本与STM32环境的搭建过程一样。 在Clion的设置中构建、部署、执行-&gt;工具链添加新工具链ARM-GCC。 CMake自带，构建工具使用自带的Ninja。选择编译器和调试器为上面安装的ARM工具链中的。 其实无所谓，树莓派Pico的SDK已经指定好了，只需要将编译器添加到环境变量就可以直接用了，搞的我还以为mingw可以交叉编译了 之后点击CMake，选择工具链为刚刚创建的ARM-GCC，在下面的环境中添加PICO_SDK_PATH环境变量。 编译下载调试编译后在build中就会有uf2文件可以直接下载，或者使用调试器下载调试。 配置调试也与stm32相似，只需要注意一下配置文件的写法： 1234#pico.cfgsource [find interface/picoprobe.cfg]source [find target/rp2040.cfg] 基于命令行的搭建——接触底层添加环境变量 将PicoSDK目录添加到环境变量PICO_SDK_PATH。 或者在使用CMake命令时使用-DPICO_SDK_PATH=参数传递。 或者在txt中使用SET设置。 创建工程文件夹将SDK/external目录下的pico_sdk_import.cmake复制到工程目录。 添加程序代码文件main.c： 1234567891011121314151617181920212223/** * Copyright (c) 2020 Raspberry Pi (Trading) Ltd. * * SPDX-License-Identifier: BSD-3-Clause */#include \"pico/stdlib.h\"int main() {#ifndef PICO_DEFAULT_LED_PIN#warning blink example requires a board with a regular LED#else const uint LED_PIN = PICO_DEFAULT_LED_PIN; gpio_init(LED_PIN); gpio_set_dir(LED_PIN, GPIO_OUT); while (true) { gpio_put(LED_PIN, 1); sleep_ms(250); gpio_put(LED_PIN, 0); sleep_ms(250); }#endif} 添加CMakeLists.txt: 12345678910111213141516171819cmake_minimum_required(VERSION 3.13)# initialize the SDK directlyinclude(pico_sdk_import.cmake)#这句对交叉编译很重要，跳过编译器检查set(CMAKE_TRY_COMPILE_TARGET_TYPE \"STATIC_LIBRARY\")project(picotest)# initialize the Raspberry Pi Pico SDKpico_sdk_init()add_executable(blink main.c)# pull in common dependenciestarget_link_libraries(blink pico_stdlib)# create map/bin/hex/uf2 file etc.pico_add_extra_outputs(blink) 构建编译工程创建build文件夹，进入，在该文件夹下执行命令： 1cmake .. -G Ninja -G Ninja是为了生成Ninja使用的文件。否则，在Windos下，会优先使用VS的nmake。这里没有装vs，会提示nmake找不到。 当然也可以使用mingw自带的msys2，修改-G的参数即可。 也可以在这里传入PICO_SDK_PATH。 构建完成后，执行命令: 1cmake --build . 这里需要注意安装一个c语言编译器，因为这里会编译elf2uf2工具。 之后就可以在目录下看见uf2文件了。 下载elf文件并调试详见参考文章。 这里注意，openocd的配置文件已经在其目录下了，可以自行查看支持种类。 使用GDB远程调试功能连接到OpenOCD进行调试。 参考文章使用 DAPLink 调试烧录树莓派 Picohexo","categories":[{"name":"树莓派Pico学习笔记","slug":"树莓派Pico学习笔记","permalink":"https://lostacnet.top/categories/%E6%A0%91%E8%8E%93%E6%B4%BEPico%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"},{"name":"Clion","slug":"Clion","permalink":"https://lostacnet.top/tags/Clion/"},{"name":"rp2040","slug":"rp2040","permalink":"https://lostacnet.top/tags/rp2040/"},{"name":"OpenOCD","slug":"OpenOCD","permalink":"https://lostacnet.top/tags/OpenOCD/"}]},{"title":"CMake学习笔记-常用指令","slug":"CMake学习笔记-常用指令","date":"2024-02-04T06:12:29.000Z","updated":"2024-02-04T11:38:24.102Z","comments":true,"path":"post/2412/","link":"","permalink":"https://lostacnet.top/post/2412/","excerpt":"CMake学习笔记-常用指令CMake是使用C语言绕不开的坎，这里记录一下CMake常用的命令以供查阅。","text":"CMake学习笔记-常用指令CMake是使用C语言绕不开的坎，这里记录一下CMake常用的命令以供查阅。 一个最基本的CMakeLists.txt工程目录文件:main.cpp,CMakeLists.txt CMakeLists.txt: 123456# CMakeLists.txt# 关键字可小写PROJECT(HELLO)MESSAGE(STATUS \"This is BINARY dir\" ${PROJECT_BINART_DIR})MESSAGE(STATUS \"This is SOURCE dir\" ${PROJECT_SOURCE_DIR})ADD_EXECUTABLE(HELLO main.cpp) 使用以下命令编译： 12cmake .cmake --build . 语法基本原则 变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名 指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 指令是大小写无关的，参数和变量是大小写相关的。 SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号 内部构建与外部构建内部构建就是直接在CMakeLists.txt文件所在目录cmake .。这样生成的临时文件都在根目录，比较乱。 外部构建。在其他文件夹使用cmake project_dir。其中project_dir是工程路径。这样就不会在工程文件夹下生成临时文件了。 两个变量： PROJECT_SOURCE_DIR 工程路径 PROJECT_BINARY_DIR 编译路径，使用cmake的路径。 编译Debug版本默认编译为Release版本。 编译Debug(可供调试版本)： 1cmake .. -DCMAKE_BUILD_TYPE=debug 相关环境变量可以通过修改环境变量实现生产环境。比如在linux的bash中： 1export CMAKE_INCLUDE_PATH=/usr/include/hello CMAKE_INCLUDE_PATH，头文件路径。 CMAKE_LIBRARY_PATH，库文件路径。 PROJECT——指定工程名和语言project可以用来指定工程的名字和支持的语言，默认支持所有语言。 PROJECT (HELLO) 指定了工程的名字，并且支持所有语言—建议 PROJECT (HELLO CXX) 指定了工程的名字，并且支持语言是C++ PROJECT (HELLO C CXX) 指定了工程的名字，并且支持语言是C和C++ SET——指定变量用来显示的指定变量。 SET(SRC_LIST main.cpp t1.cpp t2.cpp)SRC_LIST就包含了后面三个。 MESSAGE——输出终端信息向终端输出用户信息。主要包括三种： SEND_ERROR产生错误，生成过程被跳过 STATUS输出信息 FATAL_ERROR立即终止所有cmake过程 ADD_EXECUTABLE——生成可执行文件用来指定生成可执行文件。 ADD_EXECUTABLE(hello ${SRC_LIST}) 生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容。 工程名(PROJECT指定)与生成可执行文件hello没有任何关系。 ADD_SUBDIRECTORY ——指定源文件子目录1ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 该指令用来向当前工程添加存放源文件的子目录(source_dir)，并可以指定中间二进制和目标二进制的存放位置(binary_dir)。 EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example。 使用例子： 工程树： 123456.├── build├── CMakeLists.txt└── src ├── CMakeLists.txt └── main.cpp 外层CMakeLists.txt 12PROJECT(HELLO)ADD_SUBDIRECTORY(src bin) src下的CMakeLists.txt 1ADD_EXECUTABLE(hello main.cpp) 对于ADD_SUBDIRECTORY(src bin)： 将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为build/bin 目录。如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录。 如果想要将最终编译结果放到外面而不是子文件夹： 在SRC目录下的CMakeLists.txt(哪里要改变目标存放路径，就在哪里加入上述的定义)中添加： 1234# 编译可执行文件的输出路径--放到了build下SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR})# 编译库文件的输出路径--放到了build/lib下SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) ADD_LIBRARY——构建库1ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) 和ADD_EXECUTABLE()一样。 hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so SHARED，动态库 STATIC，静态库 ${LIBHELLO_SRC} ：源文件 SET_TARGET_PROPERTIES——设置输出对象的参数123456#对hello_static的重名为helloSET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME \"hello\")#cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a，这里设置为不清理SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)#设置版本号，VERSION 指代动态库版本，SOVERSION 指代 API 版本。SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) INCLUDE_DIRECTORIES——添加头文件路径添加头文件路径，首先可以直接在代码中使用绝对路径。 或者使用关键字添加头文件搜索目录。 1INCLUDE_DIRECTORIES(/usr/include/hello) INCLUDE_DIRECTORIES 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割 LINK_DIRECTORIES——添加第三方共享库路径1LINK_DIRECTORIES(/home/myproject/libs) LINK_DIRECTORIES 添加非标准的共享库搜索路径。 或者直接添加共享库文件。 TARGET_LINK_LIBRARIES——添加需要链接的共享库1TARGET_LINK_LIBRARIES(main libhello.a)` TARGET_LINK_LIBRARIES 添加需要链接的共享库。 INSTALL——安装INSTALL可以安装：二进制，动态库，静态库，文件，脚本。 相关变量CMAKE_INSTALL_PREFIX。 安装文件1INSTALL(FILES file1 file2 DESTINATION path) FILES：文件 DESTINATION： 1、写绝对路径 2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION 定义的路径&gt; cmake -DCMAKE_INSTALL_PREFIX=/usr 在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径。 安装脚本1INSTALL(PROGRAMS runhello.sh DESTINATION bin) PROGRAMS：非目标文件的可执行程序安装(比如脚本之类) 安装文件夹中文件 在相应文件夹下创建CMakeLists.txt，其中使用INSTALL。 在工程目录通过DIRECTORY指定。 1INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake) DIRECTORY 后面连接的是所在 Source 目录的相对路径 注意：abc 和 abc/有很大的区别 目录名不以/结尾：这个目录将被安装为目标路径下的 目录名以/结尾：将这个目录中的内容安装到目标路径 安装共享库和头文件123456789#本例将hello共享库安装到&lt;prefix&gt;/lib下#hello.h安装到&lt;prefix&gt;/include/hello#文件放到该目录下INSTALL(FILES hello.h DESTINATION include/hello)#二进制，静态库，动态库安装都用TARGETS#ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。#hello是add_library添加的动态库对象，hello_static是静态INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib) 参考从零开始详细介绍CMake","categories":[{"name":"CMake学习笔记","slug":"CMake学习笔记","permalink":"https://lostacnet.top/categories/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"}]},{"title":"同时搭建Clion与Vscode的Platformio环境","slug":"同时搭建Clion与Vscode的Platformio环境","date":"2023-09-23T07:44:42.000Z","updated":"2023-09-23T08:50:59.102Z","comments":true,"path":"post/92344/","link":"","permalink":"https://lostacnet.top/post/92344/","excerpt":"同时搭建Clion与Vscode的Platformio环境众所周知，Arduino虽然库很多，但是它的编译速度实在是太慢了。按下编译，拿一杯茶品一下，品完还没编译完。为了同时享受Arduino的库(延长寿命)，同时享受更快的速度，我选择使用PlatformIO。","text":"同时搭建Clion与Vscode的Platformio环境众所周知，Arduino虽然库很多，但是它的编译速度实在是太慢了。按下编译，拿一杯茶品一下，品完还没编译完。为了同时享受Arduino的库(延长寿命)，同时享受更快的速度，我选择使用PlatformIO。 下载PlotformIO到官网查看PlatformIO。官网的版本有两个，一个是Core一个是IDE。其中IDE是基于Vscode，并且包含Core。 Clion要求使用CLI，即Core，但是由于IDE包含，我们只需要安装IDE就行。 打开Vscode插件市场，搜索PlatformIO，安装。等待一段时间，Vscode会自动安装Core组件。 安装完成后，重启Vscode，可以在侧栏中找到PIO的标志点开，找到PlatformIO Core CLI，在终端输入pio system info查看信息。 框中显示的信息是我修改过的，默认应该在C盘。 重新设置PIO的目录PIO CORE的安装目录默认都在C盘，但是我C盘实在是太满了，如果再加上一堆库，就要炸了，因此我需要重新定义一下PIO的位置。 首先在其他盘创建一个文件夹用来存放PIO的文件，这里我创建的是D:\\PlatformIO_Core\\。 然后设置环境变量，中添加上面创建的目录路径，命名为PLATFORMIO_CORE_DIR。 然后，将上面查到的路径里面的文件复制到我们创建的新目录下，然后删除源文件夹。 重启Vscode，再次查看目录位置，看是否为新目录。 将PIO CORE关联到命令行不要这么做，这个文件夹中有python，会导致Python无法正常运行 上面说到了，IDE是自带CORE，可以使用CLI，但是由于CLI程序的环境变量没有设置，因此暂时无法使用。这里我们在环境变量的PATH中添加D:\\PlatformIO_Core\\penv\\Scripts即platformio.exe所在位置。 完成后打开命令行窗口，输入pio命令查询能否正常运行。 配置CLION环境刚刚在上面我们将IDE的Core关联到了命令行，那么这时候在CLion中可以直接安装PlatformIO插件就可以使用了，路径可以留空(因为已经添加到环境变量中去了)。这里我不再多说，网上有很多。 打开设置，在platformio中输入我们创建的地址: 这里说一下，采用上面设置之后，就可以Vscode和Clion使用同一套工具开发platformio的工程了。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://lostacnet.top/tags/vscode/"},{"name":"Clion","slug":"Clion","permalink":"https://lostacnet.top/tags/Clion/"},{"name":"Arduino","slug":"Arduino","permalink":"https://lostacnet.top/tags/Arduino/"},{"name":"PlatformIO","slug":"PlatformIO","permalink":"https://lostacnet.top/tags/PlatformIO/"}]},{"title":"使用CLion搭建ESP32-IDF开发环境","slug":"使用CLion搭建ESP32-IDF开发环境","date":"2023-09-16T16:45:23.000Z","updated":"2023-09-22T18:28:57.389Z","comments":true,"path":"post/91745/","link":"","permalink":"https://lostacnet.top/post/91745/","excerpt":"使用CLion搭建ESP32-IDF开发环境ESP-IDFv4.0后，使用了CMake构建工程，而Clion也是使用CMake进行工程的构建的，理论上是可以使用CLion开发IDF的。为了能够在开发ESP32时使用上喷气机家族非常好用的代码补全系统，这里记录环境配置的过程。","text":"使用CLion搭建ESP32-IDF开发环境ESP-IDFv4.0后，使用了CMake构建工程，而Clion也是使用CMake进行工程的构建的，理论上是可以使用CLion开发IDF的。为了能够在开发ESP32时使用上喷气机家族非常好用的代码补全系统，这里记录环境配置的过程。 前置环境搭建前，需要先搭建好以下一些环境： 完整的ESP-IDF环境，可以进行正常开发。 可以正常使用的Clion。 添加工具链首先，我们需要将IDF使用工具链加入到CLion，包括虚拟python环境，idf.py，编译器等，这里IDF实际上已经做好了，在安装目录xxx\\Espressif下，有一个idf_cmd_init.bat文件，该脚本将所有的工具链都添加了进来，只需要在CLion选择它即可。 打开CLion设置，在构建、执行、部署-&gt;工具链中点击加号添加新工具链。命名为ESP-IDF，展开添加环境，选择环境文件，在弹窗中选择上面提到的idf_cmd_init.bat文件，点击应用。 更改工程CMake设置打开一个IDF工程(可以从IDF的example文件夹中复制)，打开设置，在构建、执行、部署-&gt;CMake中选择配置，将工具链修改为上面创建的ESP-IDF。 添加IDF_PATH环境变量在工程的CMakeLists中有这样一段代码: 1include($ENV{IDF_PATH}/tools/cmake/project.cmake) 从环境变量IDF_PATH路径得到IDF的cmake应用文件。 这个环境变量默认是没有的，因此需要我们进行添加IDF_PATH为安装目录xxx\\Espressif的环境变量，这里有三种添加方法，我只使用一种： 在每个工程中添加局部的环境变量这个在上面修改Cmake的地方有一个环境属性可以修改。 修改工具链的配置文件在工具链的配置文件的开头，加上设置环境变量的语句set IDF_PATH=xxx\\Espressif。 修改系统的环境变量本次使用的方法，在系统的环境变量中添加一条IDF_PATH。 添加其他编译参数完成上面步骤后，CLion会自动重新加载Cmake，完成后，我们就可以编译了。在右上角选择Cmake应用，按下编译按钮就可以编译。 但是我们还需要设置一些其他参数。 目标芯片 我们使用的ESP32S3芯片，因此我们需要在环境变量中添加IDF_TARGET=esp32s3.添加的位置如图所示： 添加menuconfig运行脚本到现在CLion还不能进行menuconfig等设置，这里我们可以使用Clion自带的终端进行操作。 首先。我们知道CLion默认的终端是powershell终端，在桌面上的idf启动文件实际上就是启动了一个终端，并且运行了IDF安装目录下面的Initialize-Idf.ps1脚本进行环境配置，因此我们只需要运行这个脚本就行。 在Clion界面点击右上角，点击编辑配置。 在弹出的窗口中，点击添加配置，添加脚本，选择脚本文本。在文本中填写以下内容： 点击确定保存。 之后可以在配置中选择menucofig运行，即可进行设置。由于不知道为什么方向键用不了，这里使用j,k建上下移动。 同理，可以用这种方式执行其他idf指令。 遇到的问题编译时，提示IDF_TARGET错误123IDF_TARGET in CMake cache does not match IDF_TARGET environment variable.To change the target, clear the build directory and sdkconfig file, andbuild the project again 这是环境变量中的IDF_TARGET(我们设置的)与工程中已有的Cmake变量(上次编译生成)不一样。 这时候，我们需要重新加载Cmake,选择重置缓存并重新加载CMake项目即可。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"Cmake","slug":"Cmake","permalink":"https://lostacnet.top/tags/Cmake/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"},{"name":"Clion","slug":"Clion","permalink":"https://lostacnet.top/tags/Clion/"}]},{"title":"ESP32下载FLASH模式配置","slug":"ESP32下载FLASH模式配置","date":"2023-09-16T09:10:55.000Z","updated":"2023-09-16T12:54:24.300Z","comments":true,"path":"post/91610/","link":"","permalink":"https://lostacnet.top/post/91610/","excerpt":"ESP32下载FLASH模式配置众所周知，ESP32的程序是下在外部的FLASH芯片中的，由于FLASH芯片的不同，下载使用的模式不同，需要根据芯片配置不同的FLASH下载模式。这里介绍一下不同的FLASH区别于配置。","text":"ESP32下载FLASH模式配置众所周知，ESP32的程序是下在外部的FLASH芯片中的，由于FLASH芯片的不同，下载使用的模式不同，需要根据芯片配置不同的FLASH下载模式。这里介绍一下不同的FLASH区别于配置。 FLASH工作模式的分类Flash常用的工作模式有以下4种： DUAL SPI 双线串行spi DOUT:地址为 1 线模式输入，数据为 2 线模式输出 DIO:地址为 2 线模式输入，数据为 2 线模式输出 Quad SPI 四线SPI QOUT:地址为 1 线模式输入，数据为 4 线模式输出 QIO:地址为 4 线模式输入，数据为 4 线模式输出 如何选择FLASH模式选择FLASH模式需要根据板子上实际的芯片进行设置，这就需要查找开发板的原理图或者模组的资料。 对于乐鑫的模组乐鑫的模组上会标NxRx，比如N8R2表示8MFlash与2Mpsram。 具体的模组使用的Flash，可以在相应模组的DATASHEET中找到。如在这里第三页，给出了相应的模块使用的Flash类型(Quad SPI)，在下载时注意要改成相应的Flash类型。 对于其他的开发板(以合宙为例)在开发板的资料中会给出。以合宙的ESP32-C3中，使用的Flash是W25Qxxx，是DUAL SPI 双线串行spi。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"},{"name":"FLASH","slug":"FLASH","permalink":"https://lostacnet.top/tags/FLASH/"}]},{"title":"谷歌浏览器crx无法拖拽安装","slug":"谷歌浏览器crx无法拖拽安装","date":"2023-09-11T17:03:53.000Z","updated":"2023-09-16T08:18:56.740Z","comments":true,"path":"post/91203/","link":"","permalink":"https://lostacnet.top/post/91203/","excerpt":"谷歌浏览器crx无法拖拽安装最近换用了谷歌浏览器，因为没有装插件导致不能IDM不能接管下载，发现crx拖拽无法安装，解决问题留档。","text":"谷歌浏览器crx无法拖拽安装最近换用了谷歌浏览器，因为没有装插件导致不能IDM不能接管下载，发现crx拖拽无法安装，解决问题留档。 问题描述将crx拖入插件界面后没有弹出安装框，而是弹出另存为窗口，打开开发者模式也没用。 解决方法这是浏览器的安全策略导致的。在浏览器地址栏输入: 1chrome://flags/#extensions-on-chrome-urls 将Extensions on chrome:// URLs项设为enable，重启后即可安装。","categories":[{"name":"技巧","slug":"技巧","permalink":"https://lostacnet.top/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://lostacnet.top/tags/Chrome/"},{"name":"浏览器插件","slug":"浏览器插件","permalink":"https://lostacnet.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"}]},{"title":"STC52单片机的地址空间","slug":"STC52单片机的地址空间","date":"2023-09-06T17:28:48.000Z","updated":"2023-09-06T17:52:26.789Z","comments":true,"path":"post/9728/","link":"","permalink":"https://lostacnet.top/post/9728/","excerpt":"","text":"STC52单片机的地址空间51单片机的地址空间与STM32有着十分巨大的区别，在这里记录一下关于这方面的问题。本文的环境是Keil C51环境，使用STC89C52单片机。 栈空间SP指针与指向范围同其他单片机一样，51也有一个SP栈指针，但是**SP是向上增长的(与STM32不同)，并且SP只能指向内部RAM区(256B)**，即data(128B)和idata(128B)，是非常小的，在这之后是外部扩展的RAM区(xdata)，STC89C52单片机中这部分区域是”逻辑上扩展，物理上一体”，其实就是把储存芯片放到了封装内部吧。 硬件栈存在的问题我们都知道51资源少的可怜。 问题来了：当SP指向外部区后，会发送错误，重启。而内部空间在small模式下默认为变量优先存放区，但keil C51默认栈最小留1字节，当变量太多，留给栈的空间就十分的少。最后可能连进中断都会寄(进入中断需要16byte保存现场-地址和寄存器)。 模拟栈为了减少系统栈(SP的硬件栈)的使用，Keil C51默认所有函数都是不可重入的，局部变量使用固定的内存区，和static一样(正常都是存在栈里面的)。 当需要函数可重入时，使用 reentrant关键字标志，此时函数的局部变量储存在一个模拟栈，该栈由编译器维护，与SP无关，因此可以存在xdata区，可以很大，后果是访问速度可能慢了(具体看这个模拟栈所在区域)。","categories":[{"name":"51单片机学习笔记","slug":"51单片机学习笔记","permalink":"https://lostacnet.top/categories/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STC89C52","slug":"STC89C52","permalink":"https://lostacnet.top/tags/STC89C52/"},{"name":"堆栈","slug":"堆栈","permalink":"https://lostacnet.top/tags/%E5%A0%86%E6%A0%88/"},{"name":"寻址空间","slug":"寻址空间","permalink":"https://lostacnet.top/tags/%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4/"}]},{"title":"可重入函数与不可重入函数","slug":"可重入函数与不可重入函数","date":"2023-09-01T04:58:04.000Z","updated":"2023-09-16T08:18:46.741Z","comments":true,"path":"post/9158/","link":"","permalink":"https://lostacnet.top/post/9158/","excerpt":"可重入函数与不可重入函数今天在看51单片机的时候遇到一个名词:不可重入函数。听起来比较怪，故写一篇记录。","text":"可重入函数与不可重入函数今天在看51单片机的时候遇到一个名词:不可重入函数。听起来比较怪，故写一篇记录。 什么是不可重入函数不可重入函数就是执行过程中不能被中断的函数，该函数在被中断后重新再进入执行可能会发生问题，因此叫不可重入。反之，在这个函数执行的任何时刻可以中断进入其他代码，而返回时不会出现任何错误的函数就是可重入函数。 更加通俗一点，就是这个函数是不能被共享的，同一时间只能有一个任务在使用。 什么样的函数不可重入但一个函数满足一下条件时，是不可重入的： 函数内使用了静态(static)或全局变量 函数内调用了malloc()/free() 函数内调用了标准I/O函数 可见当函数内部使用了全局静态类型的东西时，就是不可重入。 为什么函数不可重入在多任务系统下，中断可能在任务执行的任何时间发生；如果一个函数的执行期间被中断后，到重新恢复到断点进行执行的过程中，函数所依赖的环境没有发生改变，那么这个函数就是可重入的，否则就不可重入。 而进入中断后，这些全局类型的东西可能在中断期间发生改变，那么当函数回到断点继续执行时，其结果就不可预料了。 如何预防 在函数体内不访问那些全局变量； 如果必须访问全局变量，记住利用互斥信号量来保护全局变量。或者调用该函数前关中断，调用后再开中断； 不使用静态局部变量； 不能调用任何不可重入的函数； 总之就是注意防止运行中静态/全局变量的改变。 在C51中的体现现在回到上面的问题。在C51中，由于没有硬件栈（？），为了提高程序的运行效率，所有局部变量存储在内存的固定位置(就像加了static)，因此所有函数都是不可重入函数。为了实现可重入，需要用一个模拟栈(运行效率低)来储存局部变量，因此需要使用reentrant来标出需要重入的函数。 1234int fun(char a,char b) reentrant//这样就是可重入的了{ return a+b;}","categories":[{"name":"c语言学习笔记","slug":"c语言学习笔记","permalink":"https://lostacnet.top/categories/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"},{"name":"中断","slug":"中断","permalink":"https://lostacnet.top/tags/%E4%B8%AD%E6%96%AD/"}]},{"title":"基于matlab的快速定位限速标志牌算法","slug":"基于matlab的快速定位限速标志牌算法","date":"2023-05-29T15:22:04.000Z","updated":"2023-05-30T03:18:38.675Z","comments":true,"path":"post/52922/","link":"","permalink":"https://lostacnet.top/post/52922/","excerpt":"基于matlab的快速定位限速标志牌算法数学实验的综合实验设计，要求使用matlab建立模型和算法，能够快速从图片中取出含有限速标志的图片区域。并截取保存为图片文件。 要求算法能够自动提取红色圆形图框区域。","text":"基于matlab的快速定位限速标志牌算法数学实验的综合实验设计，要求使用matlab建立模型和算法，能够快速从图片中取出含有限速标志的图片区域。并截取保存为图片文件。 要求算法能够自动提取红色圆形图框区域。 一，题目分析要定位限速标志，首先需要明白标志的特征，一个典型的限速标志如下： 该图像为一圈红色圆形区域中间包含黑色数字的形式组成，题目上要求能够自动提取红色圆形图框区域，那我们只需要想办法把这个圆弄出来。 那么基本思想如下： 提取出图像中的红色像素区域 找到这些像素区域中的圆 根据圆的位置对原图进行截图 对截取到的图片进行进一步判别 二，具体步骤首先亮出例程图： 图片的读取与转化首先需要对图片进行读取和转化。 使用imread(file)读取图像，该函数会返回RGB图像数组: 1image=imread('pic/include-80.png'); 由于RGB图像不易处理，这里需先转换为HSV图像。 关于RGB,HSV,HSL：三分钟带你快速学习RGB、HSV和HSL颜色空间 使用rgb2hsv(img)进行转化，该函数会返回一个MxNx3的数组，对应图像的H，S，V分量。 1234hsvImg=rgb2hsv(image);%转换到HSV空间h1=hsvImg(:,:,1);%H分量s1=hsvImg(:,:,2);%S分量v1=hsvImg(:,:,3);%V分量 之后，需要提取出其中的红色像素点。该步骤可以使用matlab数组运算和逻辑运算，判断HSV三个域中的每个像素点是否在红色像素点数值范围，是为1，否为0，最后将三个域的数组相与运算，就得到了只有红色像素位置信息图片，顺便还进行了图像的二值化。 12hsvReg1=((h1&lt;=0.056&amp;h1&gt;=0)|(h1&gt;=0.740&amp;h1&lt;=1.0)) &amp; s1&gt;=0.169&amp; s1&lt;=1.0 &amp;v1&gt;=0.180&amp;v1&lt;=1.0;%提取红色分量 figure;imshow(hsvReg1);title('原图hsv检测图像'); 得到的结果如下: 图像的降噪处理可以看到，此时图像已经可以十分清楚的看到圆环了。 之后需要对图像进行降噪处理，消除图像中像素点的很少的无效区域，便于之后对图像进行处理。 使用bwareaopen(BW,P)删除二值化图像BW中像素量少于P的所有连通分量。可以将像素少于P的色块区域删除。 12hsvReg1=bwareaopen(hsvReg1,110);%110为去除像素点阙值figure;imshow(hsvReg1);title('图像降噪结果'); 其中P的值需要根据实际情况进行选择，太大可能导致较小的图像被直接删没了，太大图像就会有很多杂点。 运行结果: 可以看到少了很多杂点。 填充平滑图像现在我们得到了包含各种色块的图像，由于我们使用圆度进行检测，因此需要让目标色块尽可能平滑饱满，跟圆长得更加接近，减少以下情况对识别的干扰： 首先需要填充图像内部的小黑点。这里使用闭运算imclose(I,SE)，使用结构元素 SE 对灰度或二值图像 I 执行形态学闭运算。形态学闭运算是先膨胀后腐蚀，这两种运算使用相同的结构元素。 这里补充一下关于图像开闭运算的知识： 膨胀：求局部最大值的操作 腐蚀：求局部最小值的操作 开运算imopen()：先腐蚀后膨胀称为开 (Open) 局部的区域大小和形状由SE指定。原图经过开运算后，去除孤立的小点，毛刺和小桥（即连通两块区域的小点），而总的位置和形状不变。 闭运算imclose()：先膨胀后腐蚀称为闭 (Close) 局部的区域大小和形状由SE指定。原图经过闭运算后，能够填平小湖（即小孔），弥合小缝隙，而总的位置和形状不变。 参考文章:开闭运算 imopen imclose SE可由函数strel()生成，该函数可以生成很多类型的平面元素结构，我们只需要使用SE = strel(\"disk\",r)盘型结构，其他结构可以参考官方文档。 对图像进行闭运算： 1234se=strel('disk',2);%半径为2hsvReg1=imclose(hsvReg1,se);hsvReg1=imfill(hsvReg1,'holes');figure;imshow(hsvReg1);title('图像填充平滑后结果'); 其中imfill(hsvReg1,'holes')填充了图像中的孔，即无法通过从图像边缘填充背景来到达的一组背景像素。结果是圆环变成圆。 划分连通区域该步骤将上图中的图块分别标记编号并求其边缘点。 使用函数[B,L]=bwboundaries(hsvReg1,'noholes')，该函数将图像上的连通域分别标记并记录边界点在cell类型的B中，在L中储存标记后的区域。 其中指定参数noholes将不会将hole作为新对象，而是将包括hole的整体作为一个整体。 1234567[B,L]=bwboundaries(hsvReg1,'noholes');figure;imshow(label2rgb(L,@jet,[.5 .5 .5]));%5hold on;for k=1:length(B) boundary=B{k}; plot(boundary(:,2),boundary(:,1),'w','LineWidth',2);end 处理结果： 区分了每个连通域及其边界。 计算连通域特性获得了不同连通域后，我们需要计算不同连通域的特性。 使用regionprops(BW,properties)进行计算，根据properties字符串计算标记好连通域的BW中不同连通域的不同特性，并返回结构体数组。 在该题中，我们依据图形的圆度判断是否为圆，因此我们需要求: Centroid:区域的质心，对应圆心 Area:实际的像素数，对应面积 Circularity:圆度，由(4*Area *pi)/(Perimeter^2)计算，由于matlab2017没有，因此直接求Perimeter Perimeter:围绕区域的边界，如果图像包含不连续区域，regionprops 将返回意外结果。(所以先填充平滑) 1stats=regionprops(L,'Area','Centroid','Perimeter'); 提取图形中的圆在该步骤中，我们遍历每一个连通域，求其圆度，保持圆度大于阈值threshold的连通域的圆心，半径(由周长计算)。 123456789101112131415threshold=0.88;%圆度的阈值cents={};%圆心rs=[];%周长stats=regionprops(L,'Area','Centroid','Perimeter');for k=1:length(B) area=stats(k).Area; perimeter=stats(k).Perimeter; Circularity=4*pi*area/perimeter^2;%计算圆度 if Circularity&gt;threshold cents{end+1}=stats(k).Centroid; r=perimeter/(2*pi); rs(end+1)=r; endend 裁剪图像获得圆心和半径后，我们可以计算出圆所在图像区域，使用imcrop(I,rect)进行裁剪。 rect是一个四元素数组，第一二个元素为矩形的左上角坐标，第三个元素是矩形的长，第四个是宽。 12345for i=1:length(cents) rect=[cents{i}(1)-rs(i) cents{i}(2)-rs(i) 2*rs(i) 2*rs(i)]; result=imcrop(image,rect); figure;imshow(result);title('图像裁剪结果');end 结果如下： 三，结论本方法使用提取红色像素进行二值化，通过对二值化图像找圆的方式找到原图中的红色圆形区域，以定位限速牌。由于使用圆度进行判断，判断方法较为单一，当阈值过大，会导致变形的限速牌无法识别，当阈值过小，一些图像则会被误识别，因此还需要进行改进，以获得更加准确的方案。 目前，可以考虑对裁剪后的图像进行文字识别OCR，如果有限速的数字则可以更为准确的判断。 四，代码附录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849image=imread('pic/include-80.png');% image=imread('pic/include-120-100.png');% image=imread('pic/1.png');threshold=0.95;%圆度的阈值%======= HSV颜色分割图像 =======%hsvImg=rgb2hsv(image);%转换到HSV空间h1=hsvImg(:,:,1);%H分量s1=hsvImg(:,:,2);%S分量v1=hsvImg(:,:,3);%V分量 hsvReg1=((h1&lt;=0.056&amp;h1&gt;=0)|(h1&gt;=0.740&amp;h1&lt;=1.0)) &amp; s1&gt;=0.169&amp; s1&lt;=1.0 &amp;v1&gt;=0.180&amp;v1&lt;=1.0;%提取红色分量 % figure;imshow(hsvReg1);title('原图hsv检测图像');%======= 降噪 =======%hsvReg1=bwareaopen(hsvReg1,110);%110为去除像素点阙值% figure;imshow(hsvReg1);title('图像降噪结果');%======= 填充平滑图像 =======%se=strel('disk',2);hsvReg1=imclose(hsvReg1,se);hsvReg1=imfill(hsvReg1,'holes');% figure;imshow(hsvReg1);title('图像填充平滑后结果');%======= 划分连通域 =======%[B,L]=bwboundaries(hsvReg1,'noholes');% figure;imshow(label2rgb(L,@jet,[.5 .5 .5]));%5% hold on;% for k=1:length(B)% boundary=B{k};% plot(boundary(:,2),boundary(:,1),'w','LineWidth',2);% end%======= 计算连通域特性 =======%cents={};%圆心rs=[];%周长stats=regionprops(L,'Area','Centroid','Perimeter');for k=1:length(B) area=stats(k).Area; perimeter=stats(k).Perimeter; Circularity=4*pi*area/perimeter^2;%计算圆度 if Circularity&gt;threshold cents{end+1}=stats(k).Centroid; r=perimeter/(2*pi); rs(end+1)=r; endend%======= 剪切保存图像 =======%for i=1:length(cents) rect=[cents{i}(1)-rs(i) cents{i}(2)-rs(i) 2*rs(i) 2*rs(i)]; result=imcrop(image,rect); figure;imshow(result);title('图像裁剪结果');end","categories":[{"name":"课程设计","slug":"课程设计","permalink":"https://lostacnet.top/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://lostacnet.top/tags/matlab/"},{"name":"图像处理","slug":"图像处理","permalink":"https://lostacnet.top/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"FreeRTOS头文件引用顺序问题","slug":"FreeRTOS头文件引用顺序问题","date":"2023-05-25T17:45:45.000Z","updated":"2023-05-29T15:39:32.711Z","comments":true,"path":"post/52645/","link":"","permalink":"https://lostacnet.top/post/52645/","excerpt":"FreeRTOS头文件引用顺序问题今天在调ESPIDF时候遇到一个非常奇怪的问题。最后发现是关于FreeRTOS头文件的引用顺序导致的。困扰了好几个小时，这里记录。","text":"FreeRTOS头文件引用顺序问题今天在调ESPIDF时候遇到一个非常奇怪的问题。最后发现是关于FreeRTOS头文件的引用顺序导致的。困扰了好几个小时，这里记录。 问题描述今天在写ESP32IDF工程时，发现自己的头文件引用一直有问题，具体表现为交换两个头文件引用顺序会导致出现一大堆报错： 1234//错误的引用顺序#include \"my_event.h\"#include \"lvgl_port.h\" my_event.h 123456789101112#ifndef _MY_EVENT_H#define _MY_EVENT_H#include \"freertos/semphr.h\"//信号量#include \"freertos/FreeRTOS.h\"#include \"freertos/task.h\"extern SemaphoreHandle_t xGuiSemaphore;//GUI信号量防止多线程操作GUI#endif lvgl_port.h 12345678910111213141516#ifndef _LVGL_PORT_H#define _LVGL_PORT_H......#define LVGL_TICK_PERIOD_MS 2#include \"freertos/FreeRTOS.h\"#include \"esp_lcd_panel_io.h\" //IO口和电平定义设置#include \"hx8369.h\"//hx8369面板的创建......#endif //_LVGL_PORT_H 以这样的顺序引用会导致疯狂的报错： 6,直接蒙了。 结果是，工程里到处都是红标，完全无法定位错误在哪里。 问题解决经过我一点一点加改头文件，终于发现把那两个头文件引用顺序换一下就可以编译了（？？？？？什么玄学解决方法，我不服啊） 经过再深入查看所有引用的头文件，终于定位了问题： FreeRTOS.h 12345#ifndef INC_FREERTOS_H#define INC_FREERTOS_H.....#endif semphr.h 123#ifndef INC_FREERTOS_H #error \"include FreeRTOS.h\" must appear in source files before \"include semphr.h\"#endif 这个#error直接导致sempher.h必须要在FreeRTOS.h之后引用。 对于上面的问题，是因为在lvgl_port.h中已经包含了FreeRTOS.h所以能让后面不报错。 这个ERROR直接淹没在报错的汪洋大海中，根本定位不到！！！ 所以只要注意，使用FreeRTOS其他组件时，头文件必须在 FreeRTOS.h后引用。 后续为了弄明白为什么会有如此奇怪的设计，头文件都要按依赖顺序来引用，而不是顺便引用或者自动include依赖的头文件，我到官网找了一下发现如下回答： It is to make it more obvious what is going on - I have a personal preference not to include one header file from inside another because you can get yourself tied up on knots - but besides my preference formal coding standards (such as those for safety or security certifications) normally forbid nesting headers. In FreeRTOS there is one place where it can’t be avoided because you have to get the configuration file, portable header, and then the checks to see which configuration items are left undefined, all in the correct order. 原来是大佬的洁癖啊。 现在凌晨2点了，害。","categories":[{"name":"FreeRTOS学习笔记","slug":"FreeRTOS学习笔记","permalink":"https://lostacnet.top/categories/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"}]},{"title":"Clion移植LVGL模拟器","slug":"Clion移植LVGL模拟器","date":"2023-05-24T14:39:46.000Z","updated":"2023-09-16T16:46:59.380Z","comments":true,"path":"post/52439/","link":"","permalink":"https://lostacnet.top/post/52439/","excerpt":"Clion移植LVGL模拟器LVGL官方提供的模拟器方案是在Win上使用codeblock，但是其推荐的Linux上使用的vscode等一些项目是使用Cmake构建的，而Clion这这个超级好用而且学生免费的IDE又正好是使用Cmake作为构建工具的，理论是可以运行所有Cmake工程的。所以打算尝试将模拟器移植到Clion下。","text":"Clion移植LVGL模拟器LVGL官方提供的模拟器方案是在Win上使用codeblock，但是其推荐的Linux上使用的vscode等一些项目是使用Cmake构建的，而Clion这这个超级好用而且学生免费的IDE又正好是使用Cmake作为构建工具的，理论是可以运行所有Cmake工程的。所以打算尝试将模拟器移植到Clion下。 本文需要准备的环境： Clion：喷气机的C语言IDE，使用学生邮箱免费使用。已配置好Mingw的C语言环境。 SDL：一个C语言图形库，lvgl模拟器的依赖。官网，请自行下载SDL2-devel-xxx-mingw版本的压缩包。 lvgl：图形库仓库，这里使用v8.2版本。 lv_port_pc_eclipse：一个基于Cmake的模拟器仓库，本文的移植对象。 lv_drivers：lvgl在pc上的驱动库。 一，SDL库的安装由于pc的lvgl依赖于SDL库运行，这里需要先在Clion中添加SDL库。 解压SDL将下载的SDL库解压到一个文件夹，我下载的是SDL2-devel-2.26.5-mingw.zip，将压缩包解压，随便放一个地方。由于我们使用Cmake直接添加库文件，因此不需要设置环境变量之类（网上大都将SDL目录复制到了MinGW目录下，这样虽然方便添加，但会污染MinGW目录，不是很好）。记住x86_64-w64-mingw32目录的位置。 该目录如下： bin包含Dll动态链接库 include包含了头文件 lib包含了静态库文件 Tip：以下内容仅供学习，如需快速移植请直接到第二节 设置Cmake新建一个Clion工程，打开CMakeLists.txt,添加以下内容。 12345678910111213141516# 以下为工程设置，每个人不一样cmake_minimum_required(VERSION 3.22)project(test C)set(CMAKE_C_STANDARD 99)# 这里设置了一个变量，将上面要记住的目录保存到SDL2_DIRset(SDL2_DIR E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32)# 添加头文件地址include_directories(${SDL2_DIR}/include)# 添加库文件夹地址，添加dll文件夹和lib文件夹link_directories(${SDL2_DIR}/bin ${SDL2_DIR}/lib)add_executable(test main.c)# 设置test编译项目需要连接的库，注意顺序target_link_libraries(test mingw32 SDL2 SDL2main ) 在上面的代码中，需要使用link_directories()同时添加bin和lib这两个库文件搜索路径。 按道理说dll应该只需要在运行时在引用，在编译时不需要，只需要静态库文件，但这里如果不加bin就会在编译时报错，不知道为什么。 使用target_link_libraries()添加项目要使用的库文件，注意添加顺序，被依赖的库放在依赖它的库的后面，被优先编译。 这里需要注意，因为SDL2在引用头文件时，将用户的main重定义为了SDLmain进行了接管，因此如果把mingw放最先编译，可能直接找不到WinMain报错。 运行测试代码main.c 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include \"SDL2/SDL.h\"int main(int argc, char *argv[]) { // 初始化SDL SDL_Init(SDL_INIT_VIDEO); // 创建SDL窗口指针 SDL_Window *window = SDL_CreateWindow( \"SDL2Test\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 640, 480, 0 ); // 创建渲染器 SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE); // 设置渲染器 SDL_SetRenderDrawColor(renderer, 0, 0, 0, SDL_ALPHA_OPAQUE); SDL_RenderClear(renderer); // 渲染 SDL_RenderPresent(renderer); // 等待3000ms SDL_Delay(3000); // 销毁窗口&amp;退出 SDL_DestroyWindow(window); SDL_Quit(); return 0;} 测试效果为出现黑色窗口，几秒后结束。 可能的报错： 12345678910E:/Code_R/test/main.c: In function 'SDL_main':E:/Code_R/test/main.c:4:1: error: number of arguments doesn't match prototype 4 | int main() { | ^~~In file included from E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32/include/SDL2/SDL.h:32, from E:/Code_R/test/main.c:2:E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32/include/SDL2/SDL_main.h:155:29: error: prototype declaration 155 | extern SDLMAIN_DECLSPEC int SDL_main(int argc, char *argv[]); | ^~~~~~~~ninja: build stopped: subcommand failed. 这是由于SDL的接管机制，将main()如下重定义： 12#define main SDL_mainextern SDLMAIN_DECLSPEC int SDL_main(int argc, char *argv[]); 因此main函数必须为以下形式： 1int main(int argc, char *argv[]){} 可能的报错： 1undefined reference to `WinMain' 同样是SDL接管机制导致找不到main函数，这里是因为链接顺序问题导致包含真正main的SDL没有先编译。注意target_link_libraries()的顺序。 可能的报错： 12345678E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: /Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:73: undefined reference to `SDL_memcpy'E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: /Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:74: undefined reference to `SDL_free'E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: /Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:64: undefined reference to `SDL_wcslen'E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: /Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:64: undefined reference to `SDL_iconv_string'E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32/lib/libSDL2main.a(SDL_windows_main.o): in function `OutOfMemory':/Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:26: undefined reference to `SDL_ShowSimpleMessageBox'E:\\CLion 2022.1.2\\bin\\mingw\\bin/ld.exe: E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32/lib/libSDL2main.a(SDL_windows_main.o): in function `main_getcmdline':/Users/valve/release/SDL2/SDL2-2.26.5-source/foo-x64/../src/main/windows/SDL_windows_main.c:79: undefined reference to `SDL_SetMainReady' 没有添加bin路径或者link_directories中lib与bin顺序的问题（这个顺序是什么玄学问题）。 可能的问题： 1cannot find -lSDL2main link_directories没有添加lib. 可能成功编译但是运行失败，这是因为缺少dll库，将bin文件夹下的dll复制到exe目录下即可。 其他安装方法： 使用SDL库中.cmake文件，使用find_package(SDL2 REQUIRED SDL2) LVGL项目中使用这种方法。 二，移植lvgl模拟器将下载的lvgl库和lv_drivers分别放到lv_port_pc_eclipse中的相应文件夹，使用Clion打开项目。 此时应该会报错： 12345678910111213141516CMake Error at CMakeLists.txt:10 (find_package): By not providing \"FindSDL2.cmake\" in CMAKE_MODULE_PATH this project has asked CMake to find a package configuration file provided by \"SDL2\", but CMake did not find one. Could not find a package configuration file provided by \"SDL2\" with any of the following names: SDL2Config.cmake sdl2-config.cmake Add the installation prefix of \"SDL2\" to CMAKE_PREFIX_PATH or set \"SDL2_DIR\" to a directory containing one of the above files. If \"SDL2\" provides a separate development package or SDK, be sure it has been installed. 这是需要设置SDL2中SDL2Config.cmake和 sdl2-config.cmake文件所在目录。添加： 1SET(SDL2_DIR E:/C_Lib/SDL2-2.26.5/x86_64-w64-mingw32/lib/cmake/SDL2) 可能报错： 1undefined reference to `SDL_main' 这是删除了SDL接管导致的，参考main.c的13行，注释掉这个行： 1#define SDL_MAIN_HANDLED /*To fix SDL's \"undefined reference to WinMain\" issue*/ 加了这个修复反而报错了，估计是linux与win的不同导致的。 之后将dll复制到生成的exe相同目录下。 直接运行就行了。 这里涉及到很多关于C语言编译过程的问题，需要补习很多知识。","categories":[{"name":"LVGL学习笔记","slug":"LVGL学习笔记","permalink":"https://lostacnet.top/categories/LVGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"lvgl","slug":"lvgl","permalink":"https://lostacnet.top/tags/lvgl/"},{"name":"SDL","slug":"SDL","permalink":"https://lostacnet.top/tags/SDL/"},{"name":"Clion","slug":"Clion","permalink":"https://lostacnet.top/tags/Clion/"}]},{"title":"ESP32-IDF组件找不到头文件而mian可以找到情况解决","slug":"ESP32-IDF组件找不到头文件而mian可以找到情况解决","date":"2023-05-14T12:14:59.000Z","updated":"2023-05-29T15:32:56.942Z","comments":true,"path":"post/51414/","link":"","permalink":"https://lostacnet.top/post/51414/","excerpt":"ESP32-IDF组件找不到头文件而mian可以找到情况解决今天学习IDF时出现了一个怪现象，明明一个头文件（库），在main.c中都可以引用并编译成功，而在组件中就找不到头文件，甚至在组件中可以点开打开该头文件，而编译时就是找不到。这里记录解决方法。","text":"ESP32-IDF组件找不到头文件而mian可以找到情况解决今天学习IDF时出现了一个怪现象，明明一个头文件（库），在main.c中都可以引用并编译成功，而在组件中就找不到头文件，甚至在组件中可以点开打开该头文件，而编译时就是找不到。这里记录解决方法。 问题分析这其实是组件依赖问题，引用该头文件确没有依赖这个库，自然就找不到头文件。而main组件在构建过程中自动依赖所有其他组件，因此可以直接使用，而其他组件只包含了通用组件依赖，因此就需要添加依赖了。 通用组件依赖。一下组件在使用时不需要添加依赖： cxx、newlib、freertos、esp_hw_support、heap、log、soc、hal、esp_rom、esp_common、esp_system。 添加依赖在idf_component_register()中的REQUIRES或者PRIV_REQUIRES中添加依赖。 如，要使用lcd，i2c，gpio，lvgl，esp_timer，就需要这样写: 1234idf_component_register(SRCS \"hx8369.c\" \"lvgl_port.c\" \"gt911.c\" INCLUDE_DIRS \"./include\" REQUIRES esp_lcd driver lvgl esp_timer)#i2c和GPIO包含在driver中","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"}]},{"title":"ESP32-IDF编译时出现undefined reference to function()","slug":"ESP32-IDF编译时出现undefined-reference-to-function","date":"2023-05-14T11:39:05.000Z","updated":"2023-05-29T15:32:19.594Z","comments":true,"path":"post/51439/","link":"","permalink":"https://lostacnet.top/post/51439/","excerpt":"ESP32-IDF编译时出现undefined reference to function()在编译ESP32项目时出现了奇怪的错误，在Link CXX executable test.elf时失败，并报错undefined reference to 'lv_demo_music'。是编译报错。这里记录解决方法。","text":"ESP32-IDF编译时出现undefined reference to function()在编译ESP32项目时出现了奇怪的错误，在Link CXX executable test.elf时失败，并报错undefined reference to 'lv_demo_music'。是编译报错。这里记录解决方法。 原因分析上面的报错意思很简单，其实就是虽然声明了这个函数(有头文件)，没有报错undeclare，但是由于**没有编译这个函数(没编译.c文件)**，导致编译器在链接的时候找不到。 这其实是CMake文件没有写好编译范围，导致没有将目标文件编译的原因。 解决方法解决方法也很简单，参考官方文档的构建系统。该文档中说明，可以使用SRCS SRC_DIRS指定要编译的文件，文件夹。 添加编译单个文件： 12idf_component_register(SRCS library/a.c library/b.c platform/platform.c ...) 添加编译包含多个文件的文件夹： 12idf_component_register(SRC_DIRS library platform ...) 后台会使用通配符在指定的目录中查找源文件。但是请注意，在使用这种方法的时候，如果组件中添加了一个新的源文件，CMake 并不知道重新运行配置，最终该文件也没有被加入构建中。这在使用命令行单步编译时需要注意。 问题解决我是在移植lvgl时出现的BUG，由于ESP公司是LVGl的合作伙伴，lvgl对ESP-IDF做了专门的适配，其直接克隆的仓库就可以做为一个组件使用。在项目CMakeList.txt中，可以看到这一行： 1include(${CMAKE_CURRENT_LIST_DIR}/env_support/cmake/esp.cmake)c 引用了env_support目录下的cmake文件,打开该文件。 123456789101112131415161718192021222324252627282930313233file(GLOB_RECURSE SOURCES ${LVGL_ROOT_DIR}/src/*.c)# ${LVGL_ROOT_DIR}/demos/*.c)idf_build_get_property(LV_MICROPYTHON LV_MICROPYTHON)if(LV_MICROPYTHON) idf_component_register( SRCS ${SOURCES} INCLUDE_DIRS ${LVGL_ROOT_DIR} ${LVGL_ROOT_DIR}/src ${LVGL_ROOT_DIR}/../ REQUIRES main) target_compile_definitions(${COMPONENT_LIB} INTERFACE \"-DLV_CONF_INCLUDE_SIMPLE\") if(CONFIG_LV_ATTRIBUTE_FAST_MEM_USE_IRAM) target_compile_definitions(${COMPONENT_LIB} INTERFACE \"-DLV_ATTRIBUTE_FAST_MEM=IRAM_ATTR\") endif()else() idf_component_register(SRCS ${SOURCES} INCLUDE_DIRS ${LVGL_ROOT_DIR} ${LVGL_ROOT_DIR}/src ${LVGL_ROOT_DIR}/../) target_compile_definitions(${COMPONENT_LIB} PUBLIC \"-DLV_CONF_INCLUDE_SIMPLE\") if(CONFIG_LV_ATTRIBUTE_FAST_MEM_USE_IRAM) target_compile_definitions(${COMPONENT_LIB} PUBLIC \"-DLV_ATTRIBUTE_FAST_MEM=IRAM_ATTR\") endif()endif() 可以看到，两次idf_component_register()使用的源文件为${SOURCES}，而该变量定义在： 1file(GLOB_RECURSE SOURCES ${LVGL_ROOT_DIR}/src/*.c) 可以看到，只编译了src文件夹，我们使用的函数在demos文件夹下，因此可以直接修改为 1file(GLOB_RECURSE SOURCES ${LVGL_ROOT_DIR}/src/*.c ${LVGL_ROOT_DIR}/demos/*.c) 重新编译，问题解决。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"c语言函数-containerof()","slug":"c语言函数-containerof","date":"2023-05-12T02:00:41.000Z","updated":"2023-05-29T15:30:57.014Z","comments":true,"path":"post/51200/","link":"","permalink":"https://lostacnet.top/post/51200/","excerpt":"c语言函数-containerof()今天在看ESP32库的源码时，发现了一个神奇的函数：__containerof()。可以从结构体成员的地址获得该结构体的地址，实现一种类似于找father的方法，故记录。","text":"c语言函数-containerof()今天在看ESP32库的源码时，发现了一个神奇的函数：__containerof()。可以从结构体成员的地址获得该结构体的地址，实现一种类似于找father的方法，故记录。 函数原型123#define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) 1#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) 函数作用函数实现的功能也很简单，用来已知成员的地址和名称以及该结构体的类型，求该结构体的地址。 分析该函数的核心步骤是： 1type的起始地址 = ptr - size (这里需要都转换为char *，因为它为单位字节) 其中的核心是size的获得。 1#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) 这里使用了0地址的用法。当一个0地址被强转为TYPE结构体的地址，那么它成员的地址就会变成该成员相对于结构体地址的偏移。(TYPE *)0)-&gt;MEMBER指向了成员，(size_t) &amp;((TYPE *)0)-&gt;MEMBER取了这个成员的地址并强转为size_t。 然后是这一看起来没有用的一行。 1const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); 这一行是用来提供警告的，如果传入的参数参数类型不一样（可能是传错了），这就会产生一个警告，帮助排查错误。 最后，有一个宏函数的返回问题。 123456789#define kaddr(addr)\\({\\int tmp = addr;\\if (addr &gt; 5) \\ tmp = 2;\\else\\ tmp = 3;\\(addr+tmp);\\})\\ 上述函数在最后一句不是一个完整的句子，而只有右值。该右值就会作为返回值返回。","categories":[{"name":"c语言学习笔记","slug":"c语言学习笔记","permalink":"https://lostacnet.top/categories/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"}]},{"title":"ESP-IDF在Vscode中Monitor出现乱码的解决","slug":"ESP-IDF在Vscode中Monitor出现乱码的解决","date":"2023-05-09T16:29:49.000Z","updated":"2023-05-29T15:38:26.932Z","comments":true,"path":"post/51029/","link":"","permalink":"https://lostacnet.top/post/51029/","excerpt":"ESP-IDF在Vscode中Monitor出现乱码的解决ESP-IDF的vscode插件在更新到v1.6.2后Monitor窗口出现乱码，无法监控程序的log，这里给出临时解决方法。","text":"ESP-IDF在Vscode中Monitor出现乱码的解决ESP-IDF的vscode插件在更新到v1.6.2后Monitor窗口出现乱码，无法监控程序的log，这里给出临时解决方法。 问题描述今天打开Vscode准备学学ESP32，然后发现下载烧录进去后Monitor窗口直接给我蹦出一大堆乱码。好家伙，我代码可是一点都没改啊。 查找问题像这种一看就是波特率出现了问题，我打开串口助手使用115200波特率可以正常收到信息，而Monitor打开串口的波特率设置是460800，那么这种一定板子上的波特率设置问题。 但是我找遍了SDK的菜单也没看见设置波特率的选项。无奈放弃。但是今天刷B站，大数据居然给我推了出现这个BUG的视频（该死的大数据），打开评论区，发现有人说github已经有issue了。我赶紧去看，果然有人遇到了和我一样的bug。并且已经有人给出了解决方法。 果然出现问题后第一步就应该去github下看看有没有issue。 解决方法issue 问题原因波特率不匹配问题。 ESP上设置的是115200，而监控器设置的是460800，因此出现问题。 这是由于v1.6.2设置了错误的初始波特率。 解决方案打开./.vscode/settings.json，在json中添加下列新键值对 1\"idf.monitorBaudRate\": \"115200\", 开发者已经回应，将在v1.6.3的插件中解决这个问题。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"vscode","slug":"vscode","permalink":"https://lostacnet.top/tags/vscode/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-并口LCD","slug":"ESP-IDF学习笔记-并口LCD","date":"2023-05-09T09:14:26.000Z","updated":"2023-05-29T15:35:56.387Z","comments":true,"path":"post/5914/","link":"","permalink":"https://lostacnet.top/post/5914/","excerpt":"ESP-IDF学习笔记-并口LCDESP32S3中提供了一堆外设，其中就包括LCD外设。该外设可以直接驱动屏幕，支持SPI，I2C，8080，RGB接口的屏幕。这与STM32不同（需要基于FSMC或者SPI写驱动），硬件完成了大部分操作。这里记录使用8080并口屏的方法，以及使用触摸作为输入。","text":"ESP-IDF学习笔记-并口LCDESP32S3中提供了一堆外设，其中就包括LCD外设。该外设可以直接驱动屏幕，支持SPI，I2C，8080，RGB接口的屏幕。这与STM32不同（需要基于FSMC或者SPI写驱动），硬件完成了大部分操作。这里记录使用8080并口屏的方法，以及使用触摸作为输入。 官方文档 一，配置步骤概览以8080总线驱动的HX8369A屏幕为例，ESP32中提供的API结构大概如下： 初始化总线1esp_lcd_new_i80_bus(); 使用该函数定义时钟源，D/C引脚，WR引脚，总线宽度(8/16)，数据引脚，单次最大传输数据量，DMA对齐参数。是对仅对8080总线的定义。 定义一个i80panel的IO1esp_lcd_new_panel_io_i80(); 在LCD驱动中，使用panel处理一个需要驱动的屏幕，需要我们去设置这个panel的io口。这个IO口是包含i80在内的片选等一个屏幕的io的合集。同时还定义了io口电平的含义(命令数据是高电平还是低电平等)，定义了屏幕的数据时钟速度，是否交换颜色数据字节，刷新完成回调(用于GUI)，命令长度和参数长度等定义。 创建一个panel1esp_lcd_new_panel_st7789() 在这一步创建一个面板句柄，绑定了特定的屏幕驱动芯片，设置reset脚，色域深度等。 初始化屏幕123esp_lcd_panel_reset(panel_handle);//在init前必须resetesp_lcd_panel_init(panel_handle); 这一步将初始化屏幕。 设置其他参数设置屏幕间隙，是否交换x/y轴等。 二，配置步骤这里使用HX8369A驱动的480*800屏幕，利用8线8080数据线驱动的屏幕。 初始化总线1esp_err_t esp_lcd_new_i80_bus(const esp_lcd_i80_bus_config_t *bus_config, esp_lcd_i80_bus_handle_t *ret_bus) 该函数创建了一个i80句柄(ret_bus)。输入参数： esp_lcd_i80_bus_config_t 12345678910typedef struct { int dc_gpio_num; //D/C线 int wr_gpio_num; //WR线 lcd_clock_source_t clk_src; //选择时钟源 int data_gpio_nums[SOC_LCD_I80_BUS_WIDTH]; //数据线数组 size_t bus_width; //设定数据线宽度, 8 or 16 size_t max_transfer_bytes; //最大传输长度，这里决定了内部DMA的传输长度 size_t psram_trans_align; //PSRAM中的数据，DMA使用的数据对齐长度 size_t sram_trans_align; //SRAM中的数据，DMA使用的数据对齐长度} esp_lcd_i80_bus_config_t; 其中： clk_src 时钟源选择。一般选择LCD_CLK_SRC_DEFAULT(LCD_CLK_SRC_PLL160M)。还可以选择LCD_CLK_SRC_PLL240M,LCD_CLK_SRC_XTAL。 max_transfer_bytes 决定了内部DMA的传输长度，一般为行的整数倍:EXAMPLE_LCD_H_RES * 100 * sizeof(uint16_t) psram_trans_align PRAM中使用的数据对齐，支持16，32，64。 Supported alignment: 16, 32, 64. A higher alignment can enables higher burst transfer size, thus a higher i80 bus throughput. sram_trans_align 一般为4 这个DMA对齐我还没搞明白，但应该是和STM32DMA设置中的字半字之类有关吧。 使用例： 12345678910111213141516171819202122232425262728293031 esp_lcd_i80_bus_handle_t i80_bus = NULL; esp_lcd_i80_bus_config_t bus_config = { .clk_src = LCD_CLK_SRC_DEFAULT, .dc_gpio_num = EXAMPLE_PIN_NUM_DC, .wr_gpio_num = EXAMPLE_PIN_NUM_PCLK, .data_gpio_nums = { EXAMPLE_PIN_NUM_DATA0, EXAMPLE_PIN_NUM_DATA1, EXAMPLE_PIN_NUM_DATA2, EXAMPLE_PIN_NUM_DATA3, EXAMPLE_PIN_NUM_DATA4, EXAMPLE_PIN_NUM_DATA5, EXAMPLE_PIN_NUM_DATA6, EXAMPLE_PIN_NUM_DATA7,#if CONFIG_EXAMPLE_LCD_I80_BUS_WIDTH &gt; 8 EXAMPLE_PIN_NUM_DATA8, EXAMPLE_PIN_NUM_DATA9, EXAMPLE_PIN_NUM_DATA10, EXAMPLE_PIN_NUM_DATA11, EXAMPLE_PIN_NUM_DATA12, EXAMPLE_PIN_NUM_DATA13, EXAMPLE_PIN_NUM_DATA14, EXAMPLE_PIN_NUM_DATA15,#endif }, .bus_width = CONFIG_EXAMPLE_LCD_I80_BUS_WIDTH, .max_transfer_bytes = 480 * 100 * sizeof(uint16_t), .psram_trans_align = 64, .sram_trans_align = 4, }; ESP_ERROR_CHECK(esp_lcd_new_i80_bus(&amp;bus_config, &amp;i80_bus)); 创建IO设备句柄1esp_err_t esp_lcd_new_panel_io_i80(esp_lcd_i80_bus_handle_t bus, const esp_lcd_panel_io_i80_config_t *io_config, esp_lcd_panel_io_handle_t *ret_io) 在i80总线的基础上创建IO句柄。 参数： bus esp_lcd_new_i80_bus()创建的句柄 ret_io 创建出来的句柄 io_config 12345678910111213141516171819202122typedef struct { int cs_gpio_num; /*!&lt; 片选线，设为-1不使用*/ uint32_t pclk_hz; /*!&lt; 像素时钟频率 */100ns size_t trans_queue_depth; /*!&lt; 传输队列长度，越大数据吞吐量越大 */ esp_lcd_panel_io_color_trans_done_cb_t on_color_trans_done; /*!&lt; 数据传输完成回调，用于GUI */ void *user_ctx; /*!&lt; 用户参数，传递给回调 on_color_trans_done's user_ctx */ int lcd_cmd_bits; /*!&lt; 命令的位数 */ int lcd_param_bits; /*!&lt; 参数的位数 */ struct { unsigned int dc_idle_level: 1; /*!&lt; 空闲时D/C的电平 */ unsigned int dc_cmd_level: 1; /*!&lt; 命令时D/C的电平 */ unsigned int dc_dummy_level: 1; /*!&lt; Level of DC line in DUMMY phase */ unsigned int dc_data_level: 1; /*!&lt; 数据时D/C的电平 */ } dc_levels; /*!&lt; 为每个8080定义自己的逻辑电平 */ struct { unsigned int cs_active_high: 1; /*!&lt; 片选有效电平 */ unsigned int reverse_color_bits: 1; /*!&lt; 是否反转bit, D[N:0] -&gt; D[0:N] */ unsigned int swap_color_bytes: 1; /*!&lt; 交换两个颜色字节 */ unsigned int pclk_active_neg: 1; /*!&lt; 是否使用wr下降沿传输数据 */ unsigned int pclk_idle_low: 1; /*!&lt; 空闲时wr的电平 */ } flags; /*!&lt; Panel IO config flags */} esp_lcd_panel_io_i80_config_t; 其中回调函数的模板： 12345678910typedef bool (*esp_lcd_panel_io_color_trans_done_cb_t)(esp_lcd_panel_io_handle_t panel_io, esp_lcd_panel_io_event_data_t *edata, void *user_ctx);//examplestatic bool example_notify_lvgl_flush_ready(esp_lcd_panel_io_handle_t panel_io, esp_lcd_panel_io_event_data_t *edata, void *user_ctx){ lv_disp_drv_t *disp_driver = (lv_disp_drv_t *)user_ctx; lv_disp_flush_ready(disp_driver); return false;} 例子： 12345678910111213141516171819202122#include \"esp_lcd_panel_io.h\"esp_lcd_panel_io_handle_t io_handle = NULL; esp_lcd_panel_io_i80_config_t io_config = { .cs_gpio_num = EXAMPLE_PIN_NUM_CS, .pclk_hz = EXAMPLE_LCD_PIXEL_CLOCK_HZ, .trans_queue_depth = 10, .dc_levels = { .dc_idle_level = 0, .dc_cmd_level = 0, .dc_dummy_level = 0, .dc_data_level = 1, }, .flags = { .swap_color_bytes = !LV_COLOR_16_SWAP, // Swap can be done in LvGL (default) or DMA }, .on_color_trans_done = example_notify_lvgl_flush_ready, .user_ctx = &amp;disp_drv, .lcd_cmd_bits = EXAMPLE_LCD_CMD_BITS, .lcd_param_bits = EXAMPLE_LCD_PARAM_BITS, }; ESP_ERROR_CHECK(esp_lcd_new_panel_io_i80(i80_bus, &amp;io_config, &amp;io_handle)); 创建panel句柄创建完IO句柄后，驱动知道了怎么发数据，但是还不知道发什么数据/命令。因此，需要一层驱动层。 使用如下命令创建面板。 1esp_err_t esp_lcd_new_panel_st7789(const esp_lcd_panel_io_handle_t io, const esp_lcd_panel_dev_config_t *panel_dev_config, esp_lcd_panel_handle_t *ret_panel) 创建了一个基于st7789的面板句柄。 io 上面创建的io句柄 ret_panel 创建出来的句柄 panel_dev_config 设置结构体 1234567891011121314#include \"esp_lcd_panel_vendor.h\"typedef struct { int reset_gpio_num; /*!&lt; reset引脚，使用-1为不使用 */ union { lcd_color_rgb_endian_t color_space; /*!&lt; @弃用 Set RGB color space, please use rgb_endian instead */ lcd_color_rgb_endian_t rgb_endian; /*!&lt; 颜色顺序，RGB或者BGR */ }; unsigned int bits_per_pixel; /*!&lt; 颜色深度, in bpp(bits per pixel) */ struct { unsigned int reset_active_high: 1; /*!&lt; 设置reset有效电平 */ } flags; /*!&lt; LCD panel config flags */ void *vendor_config; /*!&lt; vendor specific configuration, optional, left as NULL if not used */} esp_lcd_panel_dev_config_t; 其中： rgb_endian:LCD_RGB_ENDIAN_RGB/LCD_RGB_ENDIAN_BGR 例子: 12345678esp_lcd_panel_handle_t panel_handle = NULL;ESP_LOGI(TAG, \"Install LCD driver of st7789\");esp_lcd_panel_dev_config_t panel_config = { .reset_gpio_num = EXAMPLE_PIN_NUM_RST, .rgb_endian = LCD_RGB_ENDIAN_RGB, .bits_per_pixel = 16,};ESP_ERROR_CHECK(esp_lcd_new_panel_st7789(io_handle, &amp;panel_config, &amp;panel_handle)); 然而，这是ST7789的驱动，我这个sb开发板是hx8369A驱动的，这个在官方的库中没支持。（虽然官方也只支持了ST7789，nt35510,ssd1306），在esp的组件库中也没有。但是在例程中给的库lvgl_esp32_drivers中有这个芯片，在该库中实现了一个hx8396a的panel生成，我这个开发板的店家也是直接用的那里面的驱动，然后好像改成了8080发送数据。然后我问店家怎么移植，他直接说用这个，然后说他们不教这个？？？ 关于如果需要其他IC驱动的芯片（冷门的导致ESP官方没有支持的），需要自己添加驱动层代码，我会在另一篇文章细说。 调用函数初始化以下函数都实际在上面的panel中实现的。 1esp_err_t esp_lcd_panel_reset(esp_lcd_panel_handle_t panel); 重置屏幕，该函数需要在使用esp_lcd_panel_init()前被调用。 1esp_err_t esp_lcd_panel_init(esp_lcd_panel_handle_t panel); 初始化屏幕。 1esp_err_t esp_lcd_panel_mirror(esp_lcd_panel_handle_t panel, bool mirror_x, bool mirror_y); 在某个轴镜像屏幕。与esp_lcd_panel_swap_xy()协同使用。 1esp_err_t esp_lcd_panel_swap_xy(esp_lcd_panel_handle_t panel, bool swap_axes); 交换x/y轴。与esp_lcd_panel_mirror()协同使用。 1esp_err_t esp_lcd_panel_set_gap(esp_lcd_panel_handle_t panel, int x_gap, int y_gap) 设置x/y上的间隙（到边框的距离）。间隙是指液晶面板的左/顶部两侧分别与实际显示的第一行/列之间的空间（像素）。 当定位或对准比LCD小的框架时，设置间隙是很有用的。 1esp_err_t esp_lcd_panel_invert_color(esp_lcd_panel_handle_t panel, bool invert_color_data) 颜色反转。 1esp_err_t esp_lcd_panel_disp_on_off(esp_lcd_panel_handle_t panel, bool on_off) 打开或者关闭显示。 例子: 123456789#include \"esp_lcd_panel_ops.h\" esp_lcd_panel_reset(panel_handle); esp_lcd_panel_init(panel_handle); // Set inversion, x/y coordinate order, x/y mirror according to your LCD module spec // the gap is LCD panel specific, even panels with the same driver IC, can have different gap value esp_lcd_panel_invert_color(panel_handle, true); esp_lcd_panel_set_gap(panel_handle, 0, 20); 三，使用屏幕ESP库提供了最基础的画点函数。 1esp_err_t esp_lcd_panel_draw_bitmap(esp_lcd_panel_handle_t panel, int x_start, int y_start, int x_end, int y_end, const void *color_data) 一个窗口中绘制像素点。 Tips:start点被包含而end点没有被包含。 当初始化化完IO句柄后，其实已经可以实现发送和接收数据来驱动屏幕了，后面不过是封装了特定的驱动。 1esp_err_t esp_lcd_panel_io_rx_param(esp_lcd_panel_io_handle_t io, int lcd_cmd, void *param, size_t param_size) 发送命令并接收参数。 1esp_err_t esp_lcd_panel_io_tx_param(esp_lcd_panel_io_handle_t io, int lcd_cmd, const void *param, size_t param_size) 发送命令和参数。 1esp_err_t esp_lcd_panel_io_tx_color(esp_lcd_panel_io_handle_t io, int lcd_cmd, const void *color, size_t color_size) 发送颜色数据。 这个函数将要发送的数据加入到后台队列，由DMA+中断发送。 由于有缓存时间存在，因此需要回调处理数据的生命周期。 四，SDKconfig中的设置在LCD and Touch Panel---&gt;LCD Peripheral Configuration中，需要注意这样一个设置LCD panel io foramt buffer size。该参数的值与io层单次最大发送数据量param_size有关，如果该值设置过小，会导致发送时报错。 在本人移植驱动过程中，由于没有设置该值，导致在初始化时在下面函数中报错 1esp_lcd_panel_io_tx_param(io, 0x2D, cmd_192,192); 192超过了默认值大小，导致报错。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-MQTT客户端","slug":"ESP-IDF学习笔记-MQTT客户端","date":"2023-05-03T07:49:05.000Z","updated":"2023-05-29T15:34:17.208Z","comments":true,"path":"post/5349/","link":"","permalink":"https://lostacnet.top/post/5349/","excerpt":"","text":"先上官方文档 参考文献 一，MQTT协议的简介网上很多这里不作讲解，参考这篇文章 二，ESP_MQTT的配置过程ESP_MQTT实现了MQTT客户端的功能，支持多种协议，这里仅以TCp为例。基本步骤如下; 使用esp_mqtt_client_init()配置mqtt。 使用esp_mqtt_client_register_event()注册事件处理函数。 使用esp_mqtt_client_start()开启mqtt客户端。 MQTT的运行与WiFi类似，都是基于事件进行处理。但是，WiFi库是基于ESP_EVENT库而MQTT库则是使用的内建的事件处理循环。 初始化MQTT1esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config); 使用该函数初始化MQTT客户端，并创建MQTT客户端句柄。 esp_mqtt_client_config_t 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110typedef struct esp_mqtt_client_config_t { /** * Broker 相关设置 */ struct broker_t { /** * Broker address * * - uri 优先于其他字段 * - 如果uri没有设置，至少hostname, transport and port 应该被设置. */ struct address_t { const char *uri; /*!&lt; 完整的 *MQTT* broker URI */ const char *hostname; /*!&lt; Hostname, to set ipv4 pass it as string) */ esp_mqtt_transport_t transport; /*!&lt; 选择协议类型*/ const char *path; /*!&lt; Path in the URI*/ uint32_t port; /*!&lt; *MQTT* server port */ } address; /*!&lt; Broker地址设置 */ /** * Broker 的身份验证 * * 如果不设置这部分，将不会验证Broker的身份，为安全考虑建议设置验证 */ struct verification_t { bool use_global_ca_store; /*!&lt; 是否使用全局 ca_store, 详见 esp-tls文档*/ esp_err_t (*crt_bundle_attach)(void *conf); /*!&lt; Pointer to ESP x509 Certificate Bundle attach function for the usage of certificate bundles. */ const char *certificate; /*!&lt; 证书数据，默认为NULL，验证服务器时不需要. */ size_t certificate_len; /*!&lt; 证书数据长度 */ const struct psk_key_hint *psk_hint_key; /*!&lt; 指向esp_tls.h中定义的PSK结构的指针，以启用PSK 认证（作为证书验证的替代）. 只有当没有其他验证方式时启用*/ bool skip_cert_common_name_check; /*!&lt; 跳过对服务器证书CN字段的任何验证，这降低了TLS的安全性，使*MQTT*客户端容易受到MITM攻击 */ const char **alpn_protos; /*!&lt; 用于ALPN的以NULL为结尾的支持应用协议列表 */ } verification; /*!&lt; broker的身份验证 */ } broker; /*!&lt; Broker 地址和验证信息 */ /** * Client related credentials for authentication. */ struct credentials_t { const char *username; /*!&lt; *MQTT* 用户名*/ const char *client_id; /*!&lt; 设置 *MQTT* 客户端ID. 如果 set_null_client_id == true 忽略. 如果是NULL则为默认设置. Default client id is ``ESP32_%CHIPID%`` where `%CHIPID%` are last 3 bytes of MAC address in hex format */ bool set_null_client_id; /*!&lt; 用户ID是否为NULL */ /** * 客户端验证 * * 对于使用TLS的相互认证，用户可以选择证书和密钥, * 安全认证信息（如果设置了）. * */ struct authentication_t { const char *password; /*!&lt; *MQTT* 密码 */ const char *certificate; /*!&lt; ssl认证的证书, 需要与key一起提供.如果没有验证则不需要*/ size_t certificate_len; /*!&lt; 证书的长度.*/ const char *key; /*!&lt; ssl认证的私钥，需要与证书一起提供，如果没有验证则不需要*/ size_t key_len; /*!&lt; key的长度.*/ const char *key_password; /*!&lt; 客户端密钥解密密码，不是PEM也不是DER, 如果提供，len也必须正确提供. */ int key_password_len; /*!&lt; `key_password`的长度 */ bool use_secure_element; /*!&lt; 启用安全元素，在ESP32-ROOM-32SE中可用，用于SSL连接。 */ void *ds_data; /*!&lt; 数字签名，数字签名外设在一些Espressif设备中是可用的。 */ } authentication; /*!&lt; 用户验证信息 */ } credentials; /*!&lt; 用户验证信息 */ /** * *MQTT* 会话相关设置 */ struct session_t { /** * 遗嘱设置. */ struct last_will_t { const char *topic; /*!&lt; 遗嘱消息的主题 */ const char *msg; /*!&lt; 遗嘱消息，以NULL空字符结尾*/ int msg_len; /*!&lt; 遗嘱长度，如果msg不以NULL结尾，需要设置正确长度 */ int qos; /*!&lt; 遗嘱消息质量 */ int retain; /*!&lt; 遗嘱保留标志 */ } last_will; /*!&lt; 遗嘱设置 */ bool disable_clean_session; /*!&lt; *MQTT* 持久会话设置， */ int keepalive; /*!&lt; *MQTT* keepalive时间, 默认 120 seconds */ bool disable_keepalive; /*!&lt; 设置 `disable_keepalive=true` 来关闭 keep-alive, keepalive 默认开启. Note: 设置keepalive为0不会关闭keepalive，而是使用默认的时间长度 */ esp_mqtt_protocol_ver_t protocol_ver; /*!&lt; *MQTT* 使用的协议版本.*/ int message_retransmit_timeout; /*!&lt; 重传超时时间 */ } session; /*!&lt; *MQTT* 会话设置. */ /** * 网络相关设置 */ struct network_t { int reconnect_timeout_ms; /*!&lt; 断开连接后重新自动连接到broker间隔的时间，默认为10s*/ int timeout_ms; /*!&lt; 网络操作超时时间，默认10s. */ int refresh_connection_after_ms; /*!&lt; 刷新连接事件间隔 */ bool disable_auto_reconnect; /*!&lt; 设置为true关闭自动重连 */ } network; /*!&lt; 网络设置 */ /** * 客户端任务设置 */ struct task_t { int priority; /*!&lt; *MQTT* 任务优先级*/ int stack_size; /*!&lt; *MQTT* 任务栈大小*/ } task; /*!&lt; FreeRTOS 任务设置.*/ /** * Client 用户缓冲区大小设置 * * Client 有两个缓冲区：输入和输出缓冲区 */ struct buffer_t { int size; /*!&lt; size of *MQTT* send/receive buffer*/ int out_size; /*!&lt; size of *MQTT* output buffer. If not defined, defaults to the size defined by ``buffer_size`` */ } buffer; /*!&lt; Buffer size configuration.*/} esp_mqtt_client_config_t; 使用 uri 字段的格式为 scheme://hostname:port/path 当前支持 mqtt、mqtts、ws 和 wss 协议 基于 TCP 的 MQTT 示例： mqtt://mqtt.eclipseprojects.io：基于 TCP 的 MQTT，默认端口 1883 mqtt://mqtt.eclipseprojects.io:1884：基于 TCP 的 MQTT，端口 1884 mqtt://username:password@mqtt.eclipseprojects.io:1884：基于 TCP 的 MQTT， 端口 1884，带有用户名和密码 基于 SSL 的 MQTT 示例： mqtts://mqtt.eclipseprojects.io：基于 SSL 的 MQTT，端口 8883 mqtts://mqtt.eclipseprojects.io:8884：基于 SSL 的 MQTT，端口 8884 基于 WebSocket 的 MQTT 示例： ws://mqtt.eclipseprojects.io:80/mqtt 基于 WebSocket Secure 的 MQTT 示例： wss://mqtt.eclipseprojects.io:443/mqtt 客户端凭据 credentials 字段下包含所有客户端相关凭据。 username：指向用于连接服务器用户名的指针，也可通过 URI 设置 client_id：指向客户端 ID 的指针，默认为 ESP32_%CHIPID%，其中 %CHIPID% 是十六进制 MAC 地址的最后 3 个字节 认证 可以通过 authentication 字段设置认证参数。客户端支持以下认证方式： password：使用密码 certificate 和 key：进行双向 TLS 身份验证，PEM 或 DER 格式均可 use_secure_element：使用 ESP32-WROOM-32SE 中的安全元素 ds_data：使用某些乐鑫设备的数字签名外设 MQTT 协议中的 Keep Alive 机制 MQTT 协议是承载于 TCP 协议之上的，而 TCP 协议以连接为导向，在连接双方之间，提供稳定、有序的字节流功能。 但是，在部分情况下，TCP 可能出现半连接问题。所谓半连接，是指某一方的连接已经断开或者没有建立，而另外一方的连接却依然维持着。在这种情况下，半连接的一方可能会持续不断地向对端发送数据，而显然这些数据永远到达不了对端。为了避免半连接导致的通信黑洞，MQTT 协议提供了 Keep Alive 机制，使客户端和 MQTT 服务器可以判定当前是否存在半连接问题，从而关闭对应连接。 MQTT持久会话与Clean Session详解 MQTT客户端在发起服务器连接时，可以设置是否创建一个持久会话。但Clean Session为true，指在创建一个新的会话时，在客户端断开连接时会话会自动销毁，为false时，在客户端断开连接时会话仍然保持，直到其重新连接或者会话超时注销。 持久会话可以避免因网络中断导致的重复订阅或者错过离线期间的消息。 注册事件函数1esp_err_t esp_mqtt_client_register_event(esp_mqtt_client_handle_t client, esp_mqtt_event_id_t event, esp_event_handler_t event_handler, void *event_handler_arg) 使用该函数注册事件处理函数。该事件处理的用法与esp_event库相似。 一个标准的事件处理模板为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * @brief Event handler registered to receive MQTT events * * This function is called by the MQTT client event loop. * * @param handler_args user data registered to the event. * @param base Event base for the handler(always MQTT Base in this example). * @param event_id The id for the received event. * @param event_data The data for the event, esp_mqtt_event_handle_t. */static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data){ ESP_LOGD(TAG, \"Event dispatched from event loop base=%s, event_id=%d\", base, event_id); esp_mqtt_event_handle_t event = event_data; esp_mqtt_client_handle_t client = event-&gt;client; int msg_id; switch ((esp_mqtt_event_id_t)event_id) { case MQTT_EVENT_CONNECTED: ESP_LOGI(TAG, \"MQTT_EVENT_CONNECTED\"); msg_id = esp_mqtt_client_publish(client, \"/topic/qos1\", \"data_3\", 0, 1, 0); ESP_LOGI(TAG, \"sent publish successful, msg_id=%d\", msg_id); msg_id = esp_mqtt_client_subscribe(client, \"/topic/qos0\", 0); ESP_LOGI(TAG, \"sent subscribe successful, msg_id=%d\", msg_id); msg_id = esp_mqtt_client_subscribe(client, \"/topic/qos1\", 1); ESP_LOGI(TAG, \"sent subscribe successful, msg_id=%d\", msg_id); msg_id = esp_mqtt_client_unsubscribe(client, \"/topic/qos1\"); ESP_LOGI(TAG, \"sent unsubscribe successful, msg_id=%d\", msg_id); break; case MQTT_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"MQTT_EVENT_DISCONNECTED\"); break; case MQTT_EVENT_SUBSCRIBED: ESP_LOGI(TAG, \"MQTT_EVENT_SUBSCRIBED, msg_id=%d\", event-&gt;msg_id); msg_id = esp_mqtt_client_publish(client, \"/topic/qos0\", \"data\", 0, 0, 0); ESP_LOGI(TAG, \"sent publish successful, msg_id=%d\", msg_id); break; case MQTT_EVENT_UNSUBSCRIBED: ESP_LOGI(TAG, \"MQTT_EVENT_UNSUBSCRIBED, msg_id=%d\", event-&gt;msg_id); break; case MQTT_EVENT_PUBLISHED: ESP_LOGI(TAG, \"MQTT_EVENT_PUBLISHED, msg_id=%d\", event-&gt;msg_id); break; case MQTT_EVENT_DATA: ESP_LOGI(TAG, \"MQTT_EVENT_DATA\"); printf(\"TOPIC=%.*s\\r\\n\", event-&gt;topic_len, event-&gt;topic); printf(\"DATA=%.*s\\r\\n\", event-&gt;data_len, event-&gt;data); break; case MQTT_EVENT_ERROR: ESP_LOGI(TAG, \"MQTT_EVENT_ERROR\"); if (event-&gt;error_handle-&gt;error_type == MQTT_ERROR_TYPE_TCP_TRANSPORT) { log_error_if_nonzero(\"reported from esp-tls\", event-&gt;error_handle-&gt;esp_tls_last_esp_err); log_error_if_nonzero(\"reported from tls stack\", event-&gt;error_handle-&gt;esp_tls_stack_err); log_error_if_nonzero(\"captured as transport's socket errno\", event-&gt;error_handle-&gt;esp_transport_sock_errno); ESP_LOGI(TAG, \"Last errno string (%s)\", strerror(event-&gt;error_handle-&gt;esp_transport_sock_errno)); } break; default: ESP_LOGI(TAG, \"Other event id:%d\", event-&gt;event_id); break; }}//示例注册函数esp_mqtt_client_register_event(client, ESP_EVENT_ANY_ID, mqtt_event_handler, NULL); 开始MQTT客户端1esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client); 开启MQTT客户端服务。 订阅/取消订阅1int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) 将客户端订阅到定义的主题，并定义了QOS。需要在连接服务器后进行。 1int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) 取消订阅。 发布内容ESP提供了两种发布内容的方法，阻塞式和非阻塞。 1int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain); 阻塞式发布一个消息。超时时间为config中的网络超时时间。使用这个API不需要先连接到服务器，此时消息会自动加入后台队列(如果设置了MQTT_SKIP_PUBLISH_IF_DISCONNECTED为true，则不会尝试发送而是直接返回-1) 1int esp_mqtt_client_enqueue(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain, bool store) 将信息排队到outbox，以便稍后发送。通常用于qos&gt;0的消息，但如果store=true，也可用于qos=0的消息。 这个API生成并存储发布消息到内部的outbox中，而实际发送至网络是在mqtt任务中进行的（与esp_mqtt_client_publish()相反，后者在用户任务的任务中立即发送发布消息）。因此，它可以作为esp_mqtt_client_publish()的一个非阻塞版本。 QOS服务质量 QoS0，At most once，至多一次,Sender 发送的一条消息，Receiver 最多能收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，也就算了； QoS1，At least once，至少一次,Sender 发送的一条消息，Receiver 至少能收到一次，也就是说 Sender 向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，但是因为重传的原因，Receiver 有可能会收到重复的消息； QoS2，Exactly once，确保只有一次,Sender 发送的一条消息，Receiver 确保能收到而且只收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，同时保证 Receiver 不会因为消息重传而收到重复的消息。 当我们使用MQTT客户端发布消息（PUBLISH）时，如果将RETAIN标志位设置为true，那么MQTT服务器会将最近收到的一条RETAIN标志位为true的消息保存在服务器端（内存或文件）。特别注意：MQTT服务器只会为每一个Topic保存最近收到的一条RETAIN标志位为true的消息！也就是说，如果MQTT服务器上已经为某个Topic保存了一条Retained消息，当客户端再次发布一条新的Retained消息，那么服务器上原来的那条消息会被覆盖！ 每当MQTT客户端连接到MQTT服务器并订阅了某个topic，如果该topic下有Retained消息，那么MQTT服务器会立即向客户端推送该条Retained消息。 如果客户端想让MQTT服务器删除某个Topic下保存的Retained消息，唯一的方法是向MQTT服务器发布一条RETAIN标志位为true的空消息。空消息即为发布消息（PUBLISH）的时候，Payload中设置0个字节的内容。删除了某个Topic下保存的Retained消息，如果客户端没有再发布Retained消息，则MQTT服务器上对于该Topic就没有了Retained消息。 其他API1esp_err_t esp_mqtt_client_set_uri(esp_mqtt_client_handle_t client, const char *uri); 更新uri。 1esp_err_t esp_mqtt_client_reconnect(esp_mqtt_client_handle_t client); 手动重新连接。 1esp_err_t esp_mqtt_client_disconnect(esp_mqtt_client_handle_t client); 手动断连。 1esp_err_t esp_mqtt_set_config(esp_mqtt_client_handle_t client, const esp_mqtt_client_config_t *config); 更新设置，在MQTT_EVENT_BEFORE_CONNECT前。 三，其他参考事件参考User event handler receives context data in esp_mqtt_event_t structure with client - MQTT client handle various other data depending on event type MQTT_EVENT_ANY MQTT_EVENT_ERROR 在错误事件中，额外的上下文：连接返回代码，来自esp_tls的错误处理（如果支持） MQTT_EVENT_CONNECTED connected event, additional context: session_present flag MQTT_EVENT_DISCONNECTED disconnected event MQTT_EVENT_SUBSCRIBED subscribed event, additional context: msg_id message id error_handle error_type in case subscribing failed data pointer to broker response, check for errors. data_len length of the data for this event MQTT_EVENT_UNSUBSCRIBED unsubscribed event, additional context: msg_id MQTT_EVENT_PUBLISHED published event, additional context: msg_id MQTT_EVENT_DATA data event, additional context: msg_id message id topic pointer to the received topic topic_len length of the topic data pointer to the received data data_len length of the data for this event current_data_offset offset of the current data for this event total_data_len total length of the data received retain retain flag of the message qos QoS level of the message dup dup flag of the message Note: Multiple MQTT_EVENT_DATA could be fired for one message, if it is longer than internal buffer. In that case only first event contains topic pointer and length, other contain data only with current data length and current data offset updating. MQTT_EVENT_BEFORE_CONNECT The event occurs before connecting MQTT_EVENT_DELETED Notification on delete of one message from the internal outbox, if the message couldn’t have been sent and acknowledged before expiring defined in OUTBOX_EXPIRED_TIMEOUT_MS. (events are not posted upon deletion of successfully acknowledged messages) This event id is posted only if MQTT_REPORT_DELETED_MESSAGES==1 Additional context: msg_id (id of the deleted message). MQTT_USER_EVENT Custom event used to queue tasks into mqtt event handler All fields from the esp_mqtt_event_t type could be used to pass an additional context data to the handler.","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"},{"name":"MQTT","slug":"MQTT","permalink":"https://lostacnet.top/tags/MQTT/"}]},{"title":"ESP-IDF学习笔记-WIFI连接","slug":"ESP-IDF学习笔记-WIFI连接","date":"2023-04-29T14:52:41.000Z","updated":"2023-05-29T15:35:27.952Z","comments":true,"path":"post/42952/","link":"","permalink":"https://lostacnet.top/post/42952/","excerpt":"ESP-IDF学习笔记-WIFI连接使用ESP32的WIFI需要使用3个库的API，涉及NVS_FLASH，ESP_NETIF,ESP_WIFI,ESP_EVENT。nvs保存配置，netif提供tcp/ip操作接口，wifi库提供wiif的配置接口。","text":"ESP-IDF学习笔记-WIFI连接使用ESP32的WIFI需要使用3个库的API，涉及NVS_FLASH，ESP_NETIF,ESP_WIFI,ESP_EVENT。nvs保存配置，netif提供tcp/ip操作接口，wifi库提供wiif的配置接口。 首先提供一下官方文档： 非易失存储库 WIFI库 ESP-NETIF ESP_EVENT 还有描述整个WiFi编程结构的指南(非常关键的指南，放在了API指南里，要不是我搜一个函数我还找不到)： WIFI驱动指南 一，配置步骤概览初始化NVS NVS（非易失存储库）是ESP32分区中用来储存少量需要掉电保存的数据的分区（如果数据量很大，需要储存在文件系统的分区中）。在WIFI的配置中，该区存储了WIFI的设置，包扩上次连接的WIFI信息，上次开启的热点信息等配置信息（在设置wifi时自动储存）。因此，为了实现WiFi记忆功能，在使用WIFI前，需要先初始化NVS。如果不初始化，需要在每次运行时重新配置WiFi。 创建ESP-NETIF工作 ESP-NETIF库**提供了tcp/ip操作的相关接口(Lwip)**，与wifi驱动接口绑定后，可以处理tcp/ip的各种事务，包括DHCP等各种操作。为了使我们的WIFI能够正常联网，我们需要创建一个ESP-NETIF工作。 设置WIFI WIFI库提供了操作WIFI的驱动，包括设置站点模式，配置WiFi信息，连接WIFI等操作。 事件循环 事件循环是ESPIDF提供的用于不同组件交流操作的库。一个组件可以创建事件，另外一个组件可以通过注册事件函数响应相应的事件。通过事件循环，各个库可以协同运行。其典型例子就是使用与WIFI库有关的组件时，比如使用DHCP获取IP地址，需要在WIFI库成功连接到WIFI之后，而DHCP的实现是高层库做的，因此就需要通过事件来通知其他组件WIFI已经连接，DHCP库通过将自己的函数注册成相应事件的处理函数，就可以实现协同运行。 二，具体配置流程初始化NVS首先在设置菜单中将WIFI选项中的WiFi NVS flash选中，使能WiFi_NVS_FLASH。让wifi设置能保存在NVS中。 这里直接给出代码，感兴趣可以看官方文档。 123456789#include \"nvs_flash.h\"esp_err_t ret = nvs_flash_init();if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); }ESP_ERROR_CHECK(ret); 初始化ESP-NETIF和创建事件循环首先调用函数初始化netif。 1esp_err_t esp_netif_init(void) 这个函数在应用中需要被调用一次。(This function should be called exactly once from application code, when the application starts up.) 然后创建默认事件循环。 1esp_err_t esp_event_loop_create_default(void); 该函数创建了一个默认参数的事件循环，开始处理各个组件的事件。默认事件循环是一个特殊的，包含了各种系统事件处理（如wifi事件）。默认循环使用的事件注册API与用户的事件循环有一点不同，以下使用的API都是默认循环的API。如果想知道用户API是什么，可以参考官方手册。 创建完成后，需要将netif的处理函数放入对应的事件中，比如在STA开启后自动开启DHCP客户端获取IP。 这里NETIF库已经写好了默认配置，直接调用函数即可。 1esp_netif_t *esp_netif_create_default_wifi_sta(void);//sta模式 同样，如果开启了AP模式，则调用下面的函数。 1esp_netif_t *esp_netif_create_default_wifi_ap(void); sta/ap模式需要同时调用两个函数。 使用例子: 1234567#include \"esp_event.h\"#include \"esp_wifi.h\"... ESP_ERROR_CHECK(esp_netif_init()); ESP_ERROR_CHECK(esp_event_loop_create_default());//创建默认事件处理循环 esp_netif_create_default_wifi_sta(); 注册处理函数在事件循环中加入了netif中默认的处理函数后，我们还需要注册自己的处理函数，用来实现一些功能，比如在启动wifi后开始连接ap，或者在断开连接后进行重连等。 一个事件处理函数的模板如下： 1234567891011/*arg是传入的参数，在注册函数时设置event_base是事件基，表示一个大类的事件event_id是具体的事件event_data是传递的数据，比如在IP_EVENT 下的 IP_EVENT_STA_GOT_IP 事件会把获取到的IP地址传递过来*/static void event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){...} 创建好处理函数后，使用以下函数进行注册： 1esp_err_t esp_event_handler_instance_register(esp_event_base_t event_base, int32_t event_id, esp_event_handler_t event_handler, void *event_handler_arg, esp_event_handler_instance_t *instance); 参数: event_base – [in] 基事件 event_id – [in] 具体事件id event_handler – [in] 要注册的处理函数 event_handler_arg – [in] 要传递参数的指针，该函数不保留备份，因此需要确保其在被使用时有效 instance – [out] 输出的句柄，可以用来删除(unregister)这个事件函数，如果不需要可以填NULL。 同时，如果不需要句柄，调用以下函数即可： 1esp_err_t esp_event_handler_register(esp_event_base_t event_base, int32_t event_id, esp_event_handler_t event_handler, void *event_handler_arg); 上面两个函数在底层都调用了同一个函数进行注册，因此功能是一样的。 注意，对于event_base存在一个ESP_EVENT_ANY_BASE匹配全部的基事件;对于event_id存在ESP_EVENT_ANY_ID对应基事件的全部事件。即，ESP_EVENT_ANY_BASE+ESP_EVENT_ANY_ID==全部事件都响应。 对于同一事件多个处理函数，遵守先注册先调用，后注册后调用原则。(参考) 由于该规则，自己的事件处理函数注册必须要在esp_netif_create_default_wifi_sta()之后。 esp_netif_create_default_wifi_sta()中注册了该组件的事件函数，为保证用户正常上网，该事件函数需在用户函数之前执行。 一部分WiFi相关事件在后文附上，也可以直接参考官方手册 示例，这里来自官方例程的一部分，调用的FreeRTOS的eventGroupAPI通知IP事件的完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include \"esp_wifi.h\"#include \"esp_event.h\"#include \"freertos/event_groups.h\"#define EXAMPLE_ESP_MAXIMUM_RETRY 10static int s_retry_num = 0;static EventGroupHandle_t s_wifi_event_group;static void event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){ if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) { esp_wifi_connect();//STa开启后开始连接wifi } else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) { if (s_retry_num &lt; EXAMPLE_ESP_MAXIMUM_RETRY) { esp_wifi_connect();//连接失败，重新连接 s_retry_num++; ESP_LOGI(TAG, \"retry to connect to the AP\"); } else { xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT); } ESP_LOGI(TAG,\"connect to the AP fail\"); } else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) { ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data; ESP_LOGI(TAG, \"got ip:\" IPSTR, IP2STR(&amp;event-&gt;ip_info.ip)); s_retry_num = 0; xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT); }}void app_main(void){ ... esp_event_handler_instance_t instance_any_id;//创建句柄，用来管理该函数生命周期 esp_event_handler_instance_t instance_got_ip; ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;event_handler, NULL, &amp;instance_any_id)); ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;event_handler, NULL, &amp;instance_got_ip));} 设置WiFi处理好上层要响应的事件后，可以开始配置底层的WiFi驱动。 首先初始化WiFi驱动的资源和参数： 12wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();//获取WIFI默认配置。这样可以给每个值都赋上初值ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));//初始化WIFI 使用WIFI_INIT_CONFIG_DEFAULT()获得每个变量的初值，这样可以防止某个参数忘记或设错导致的初始化失败。 在WiFi库的API被调用之前，esp_wifi_init()必须被调用。 之后设置WiFi的模式和相应模式的配置： 1esp_err_t esp_wifi_set_mode(wifi_mode_t mode);//设置模式 mode有以下几种: WIFI_MODE_STA:sta模式 WIFI_MODE_AP:ap模式 WIFI_MODE_APSTA:sta/ap模式 默认模式是STA。 设置相应模式的参数 1esp_err_t esp_wifi_set_config(wifi_interface_t interface, wifi_config_t *conf); 其中wifi_interface_t如下： 1234typedef enum { WIFI_IF_STA = ESP_IF_WIFI_STA, WIFI_IF_AP = ESP_IF_WIFI_AP,} wifi_interface_t; wifi_config_t结构体定义如下: 1234typedef union { wifi_ap_config_t ap; /**&lt; configuration of AP */ wifi_sta_config_t sta; /**&lt; configuration of STA */} wifi_config_t; 这是一个联合，设置ap和sta时分别设置不同的部分。 对于wifi_sta_config_t需要关注的成员如下: 成员名 类型 作用 ssid[32] uint8_t WiFi的SSID password[64] uint8_t WiFi的密码 scan_method wifi_scan_method_t 选择扫描模式 bssid_set bool 1:检查AP的MAC 0:不检查 bssid uint8_t 目的AP的MAC channel uint8_t 0:通道未知 ;1-13 sort_method wifi_sort_method_t 扫描排序顺序设置 threshold wifi_scan_threshold_t 安全性强于或信号强度强于该设置的AP可被使用 wifi_scan_method_t: WIFI_FAST_SCAN快速扫描模式，找到匹配的SSID后停止 WIFI_ALL_CHANNEL_SCAN扫描完全部通道为止 wifi_sort_method_t: WIFI_CONNECT_AP_BY_SIGNAL按信号强弱整理 WIFI_CONNECT_AP_BY_SECURITY按加密等级整理 wifi_scan_threshold_t: int8_t rssi信号的强度 wifi_auth_mode_t authmode最低信号的认证方式，如果想连接开放WiFi及以上，需设置为WIFI_AUTH_OPEN wifi_auth_mode_t: 12345678910111213typedef enum { WIFI_AUTH_OPEN = 0, /**&lt; authenticate mode : open */ WIFI_AUTH_WEP, /**&lt; authenticate mode : WEP */ WIFI_AUTH_WPA_PSK, /**&lt; authenticate mode : WPA_PSK */ WIFI_AUTH_WPA2_PSK, /**&lt; authenticate mode : WPA2_PSK */ WIFI_AUTH_WPA_WPA2_PSK, /**&lt; authenticate mode : WPA_WPA2_PSK */ WIFI_AUTH_WPA2_ENTERPRISE, /**&lt; authenticate mode : WPA2_ENTERPRISE */ WIFI_AUTH_WPA3_PSK, /**&lt; authenticate mode : WPA3_PSK */ WIFI_AUTH_WPA2_WPA3_PSK, /**&lt; authenticate mode : WPA2_WPA3_PSK */ WIFI_AUTH_WAPI_PSK, /**&lt; authenticate mode : WAPI_PSK */ WIFI_AUTH_OWE, /**&lt; authenticate mode : OWE */ WIFI_AUTH_MAX} wifi_auth_mode_t; 一个最小设置的例子： 12345678wifi_config_t wifi_config = { .sta = { .ssid = \"SSID\", .password = \"PASSWORD\", .threshold.authmode = WIFI_AUTH_WPA_WPA2_PSK, .sae_pwe_h2e = WPA3_SAE_PWE_BOTH,//添加这个是为了兼容最新的认证标准WPA3 }, }; 对于wifi_ap_config_t需要关注的成员如下: 成员 类型 作用 ssid[32] uint8_t SSID password[64] uint8_t 密码 ssid_len uint8_t strlen(WIFI_SSID) channel uint8_t 选择通道 authmode wifi_auth_mode_t 选择认证方式 ssid_hidden uint8_t 是否广播SSID(SSID是否可见) max_connection uint8_t 最大连接数 一个最小的config如下： 12345678910111213wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .channel = EXAMPLE_ESP_WIFI_CHANNEL, .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK, .pmf_cfg = { .required = false,//这里关闭了对pmf的要求，让其能连接更多设备 }, }, }; 如果开启了nvs，esp_wifi_set_config()的设置会被储存在nvs中，下次不用配置，可以使用esp_wifi_get_config()获取设置。 当一切都配置好后，可以开启WiFi： 1esp_err_t esp_wifi_start(void); 开启后，可以在事件循环中使用esp_err_t esp_wifi_connect(void)去连接WiFi，参考上面事件函数中的代码。 对于已经连接的AP，使用以下API获得信息: 1esp_err_t esp_wifi_sta_get_ap_info(wifi_ap_record_t *ap_info); 注意：在获得IP前，禁止一切socket操作。 三，扫描WiFi在通常的应用中，我们不可能将WiFi信息固定。因此，在连接WiFi前先扫描WiFi是十分必要的，扫描仅在sta或sta/ap模式使用。 扫描使用以下API： 1esp_err_t esp_wifi_scan_start(const wifi_scan_config_t *config, bool block); 其中，block用来确定是否阻塞式扫描。如果为1，将会阻塞直到扫描完成。否则，会立刻返回，结果一般在事件循环中处理。 config用来配置扫描设置，具有以下字段： uint8_t *ssid:AP的SSID，如果不为NULL，则仅扫描相同NULL uint8_t *bssid:AP的MAC，如果不为NULL，则仅扫描相同MAC uint8_t channel:如果该字段值为 0，将进行全信道扫描；反之，将针对特定信道进行扫描。 bool show_hidden:如果该字段值为 0，本次扫描将忽略具有隐藏 SSID 的 AP；反之，这些 AP 也会在扫描时被视为正常 AP。 wifi_scan_type_t scan_type:WIFI_SCAN_TYPE_ACTIVE主动扫描； WIFI_SCAN_TYPE_PASSIVE 被动扫描 wifi_scan_time_t scan_time:用来控制扫描时间，不用关心。 将该参数设为NULL则使用默认扫描。 该函数扫描出的结果会储存在内存中，直到调用esp_wifi_scan_get_ap_records()或者esp_err_t esp_wifi_clear_ap_list(void)释放。 主动扫描:通过发送 probe request 进行扫描。该模式为默认的扫描模式。 被动扫描:不发送 probe request。跳至某一特定信道并等待 beacon。应用程序可通过 wifi_scan_config_t 中的 scan_type 字段使能被动扫描。 调用 API sp_wifi_set_config() 可全局配置一些扫描属性，请参阅 station的配置。 如果国家信息有误，调用函数 esp_wifi_set_country() 进行配置。 当全部扫描完成后，会产生WIFI_EVENT_SCAN_DONE事件，在该事件函数中，使用以下API获得扫描得到的AP数量： 1esp_err_t esp_wifi_scan_get_ap_num(uint16_t *number); 获得AP数量后，使用以下API获得具体信息： 1esp_err_t esp_wifi_scan_get_ap_records(uint16_t *number, wifi_ap_record_t *ap_records); 参数： number:该参数是一个输入输出参数。但作为输入参数，它指示了ap_records最多储存的数量。作为输出参数，它则与esp_err_t esp_wifi_scan_get_ap_num(uint16_t *number);输出一样。 ap_records:储存扫描到AP信息的参数 ap_records: 1234567891011121314151617181920typedef struct { uint8_t bssid[6]; /**&lt; MAC address of AP */ uint8_t ssid[33]; /**&lt; SSID of AP */ uint8_t primary; /**&lt; channel of AP */ wifi_second_chan_t second; /**&lt; secondary channel of AP */ int8_t rssi; /**&lt; signal strength of AP */ wifi_auth_mode_t authmode; /**&lt; authmode of AP */ wifi_cipher_type_t pairwise_cipher; /**&lt; pairwise cipher of AP */ wifi_cipher_type_t group_cipher; /**&lt; group cipher of AP */ wifi_ant_t ant; /**&lt; antenna used to receive beacon from AP */ uint32_t phy_11b:1; /**&lt; bit: 0 flag to identify if 11b mode is enabled or not */ uint32_t phy_11g:1; /**&lt; bit: 1 flag to identify if 11g mode is enabled or not */ uint32_t phy_11n:1; /**&lt; bit: 2 flag to identify if 11n mode is enabled or not */ uint32_t phy_lr:1; /**&lt; bit: 3 flag to identify if low rate is enabled or not */ uint32_t wps:1; /**&lt; bit: 4 flag to identify if WPS is supported or not */ uint32_t ftm_responder:1; /**&lt; bit: 5 flag to identify if FTM is supported in responder mode */ uint32_t ftm_initiator:1; /**&lt; bit: 6 flag to identify if FTM is supported in initiator mode */ uint32_t reserved:25; /**&lt; bit: 7..31 reserved */ wifi_country_t country; /**&lt; country information of AP */} wifi_ap_record_t; 一个例子： 1234567891011121314151617181920#include \"esp_wifi.h\"#define DEFAULT_SCAN_LIST_SIZE 10 ... esp_wifi_scan_start(NULL, true); ESP_ERROR_CHECK(esp_wifi_scan_get_ap_records(&amp;number, ap_info)); ESP_ERROR_CHECK(esp_wifi_scan_get_ap_num(&amp;ap_count)); ESP_LOGI(TAG, \"Total APs scanned = %u\", ap_count); for (int i = 0; (i &lt; DEFAULT_SCAN_LIST_SIZE) &amp;&amp; (i &lt; ap_count); i++) { ESP_LOGI(TAG, \"SSID \\t\\t%s\", ap_info[i].ssid); ESP_LOGI(TAG, \"RSSI \\t\\t%d\", ap_info[i].rssi); print_auth_mode(ap_info[i].authmode); if (ap_info[i].authmode != WIFI_AUTH_WEP) { print_cipher_type(ap_info[i].pairwise_cipher, ap_info[i].group_cipher); } ESP_LOGI(TAG, \"Channel \\t\\t%d\\n\", ap_info[i].primary); }... 附录-WiFi事件描述该部分来自官方文档，在这里做参考。以下为具体事件名，头两个单词同时也是基事件名。 WIFI_EVENT_WIFI_READY Wi-Fi 驱动程序永远不会生成此事件，因此，应用程序的事件回调函数可忽略此事件。在未来的版本中，此事件可能会被移除。 WIFI_EVENT_SCAN_DONE 扫描完成事件，由 esp_wifi_scan_start() 函数触发，将在以下情况下产生： 扫描已完成，例如：Wi-Fi 已成功找到目标 AP 或已扫描所有信道。 当前扫描因函数 esp_wifi_scan_stop() 而终止。 在当前扫描完成之前调用了函数 esp_wifi_scan_start()。此时，新的扫描将覆盖当前扫描过程，并生成一个扫描完成事件。 以下情况下将不会产生扫描完成事件： ​ 当前扫描被阻止。 ​ 当前扫描是由函数 esp_wifi_connect() 触发的。 接收到此事件后，事件任务暂不做任何响应。首先，应用程序的事件回调函数需调用 esp_wifi_scan_get_ap_num() 和 esp_wifi_scan_get_ap_records() 获取已扫描的 AP 列表，然后触发 Wi-Fi 驱动程序释放在扫描过程中占用的内存空间（切记该步骤）。 更多详细信息，请参阅 ESP32-S3 Wi-Fi 扫描。 WIFI_EVENT_STA_START 如果调用函数 esp_wifi_start() 后接收到返回值 ESP_OK，且当前 Wi-Fi 处于 station 或 station/AP 共存模式，则将产生此事件。接收到此事件后，事件任务将初始化 LwIP 网络接口 (netif)。通常，应用程序的事件回调函数需调用 esp_wifi_connect() 来连接已配置的 AP。 WIFI_EVENT_STA_STOP 如果调用函数 esp_wifi_stop() 后接收到返回值 ESP_OK，且当前 Wi-Fi 处于 station 或 station/AP 共存模式，则将产生此事件。接收到此事件后，事件任务将进行释放 station IP 地址、终止 DHCP 客户端服务、移除 TCP/UDP 相关连接并清除 LwIP station netif 等动作。此时，应用程序的事件回调函数通常不需做任何响应。 WIFI_EVENT_STA_CONNECTED 如果调用函数 esp_wifi_connect() 后接收到返回值 ESP_OK，且 station 已成功连接目标 AP，则将产生此连接事件。接收到此事件后，事件任务将启动 DHCP 客户端服务并开始获取 IP 地址。此时，Wi-Fi 驱动程序已准备就绪，可发送和接收数据。如果您的应用程序不依赖于 LwIP（即 IP 地址），则此刻便可以开始应用程序开发工作。但是，如果您的应用程序需基于 LwIP 进行，则还需等待 got ip 事件发生后才可开始。 WIFI_EVENT_STA_DISCONNECTED 此事件将在以下情况下产生： ​ 1. 调用了函数 esp_wifi_disconnect() 或 esp_wifi_stop()，且 Wi-Fi station 已成功连接至 AP。 ​ 2. 调用了函数 esp_wifi_connect()，但 Wi-Fi 驱动程序因为某些原因未能成功连接至 AP，例如：未扫描到目标 AP、验证超时等。 或存在多个 SSID 相同的 AP，station 无法连接所有已找到的 AP，也将产生该事件。 ​ 3. Wi-Fi 连接因为某些原因而中断，例如：station 连续多次丢失 N beacon、AP 踢掉 station、AP 认证模式改变等。 接收到此事件后，事件任务的默认动作为： ​ 1. 关闭 station 的 LwIP netif。 ​ 2. 通知 LwIP 任务清除导致所有套接字状态错误的 UDP/TCP 连接。针对基于套接字编写的应用程序，其回调函数可以在接收到此 事件时（如有必要）关闭并重新创建所有套接字。 应用程序处理此事件最常用的方法为：调用函数 esp_wifi_connect() 重新连接 Wi-Fi。但是，如果此事件是由函数 esp_wifi_disconnect() 引发的，则应用程序不应调用 esp_wifi_connect() 来重新连接。应用程序须明确区分此事件的引发原因，因为某些情况下应使用其它更好的方式进行重新连接。请参阅 Wi-Fi 重新连接 和 连接 Wi-Fi 时扫描。 需要注意的另一点是：接收到此事件后，LwIP 的默认动作是终止所有 TCP 套接字连接。大多数情况下，该动作不会造成影响。但对某些特殊应用程序可能除外。例如： 应用程序创建一个了 TCP 连接，以维护每 60 秒发送一次的应用程序级、保持活动状态的数据。 由于某些原因，Wi-Fi 连接被切断并引发了 WIFI_EVENT_STA_DISCONNECTED 事件。根据当前实现，此时所有 TCP 连接都将被移除，且保持活动的套接字将处于错误的状态中。但是，由于应用程序设计者认为网络层 不应 考虑这个 Wi-Fi 层的错误，因此应用程序不会关闭套接字。 5 秒后，因为在应用程序的事件回调函数中调用了 esp_wifi_connect()，Wi-Fi 连接恢复。同时，station 连接至同一个 AP 并获得与之前相同的 IPV4 地址。 60 秒后，当应用程序发送具有保持活动状态的套接字的数据时，套接字将返回错误，应用程序将关闭套接字并在必要时重新创建。 在上述场景中，理想状态下应用程序套接字和网络层将不会受到影响，因为在此过程中 Wi-Fi 连接只是短暂地断开然后快速恢复。应用程序可通过 LwIP menuconfig 启动“IP 改变时保持 TCP 连接”的功能。 IP_EVENT_STA_GOT_IP 当 DHCP 客户端成功从 DHCP 服务器获取 IPV4 地址或 IPV4 地址发生改变时，将引发此事件。此事件意味着应用程序一切就绪，可以开始任务（如：创建套接字）。 IPV4 地址可能由于以下原因而发生改变： ​ 1. DHCP 客户端无法重新获取/绑定 IPV4 地址，且 station 的 IPV4 重置为 0。 ​ 2. DHCP 客户端重新绑定了其它地址。 ​ 3. 静态配置的 IPV4 地址已发生改变。 函数 ip_event_got_ip_t 中的字段 ip_change 说明了 IPV4 地址是否发生改变。 套接字的状态是基于 IPV4 地址的，这意味着，如果 IPV4 地址发生改变，则所有与此 IPV4 相关的套接字都将变为异常。接收到此事件后，应用程序需关闭所有套接字，并在 IPV4 变为有效地址时重新创建应用程序。 IP_EVENT_GOT_IP6 当 IPV6 SLAAC 支持自动为 ESP32-S3 配置一个地址，或 ESP32-S3 地址发生改变时，将引发此事件。此事件意味着应用程序一切就绪，可以开始任务（如：创建套接字）。 IP_EVENT_STA_LOST_IP 当 IPV4 地址失效时，将引发此事件。 此事件不会在 Wi-Fi 断连后立刻出现。Wi-Fi 连接断开后，首先将启动一个 IPV4 地址丢失计时器，如果 station 在该计时器超时之前成功获取了 IPV4 地址，则不会发生此事件。否则，此事件将在计时器超时时发生。 一般来说，应用程序可忽略此事件。这只是一个调试事件，主要使应用程序获知 IPV4 地址已丢失。 WIFI_EVENT_AP_START 与 WIFI_EVENT_STA_START 事件相似。 WIFI_EVENT_AP_STOP 与 WIFI_EVENT_STA_STOP 事件相似。 WIFI_EVENT_AP_STACONNECTED 每当有一个 station 成功连接 ESP32-S3 AP 时，将引发此事件。接收到此事件后，事件任务将不做任何响应，应用程序的回调函数也可忽略这一事件。但是，您可以在此时进行一些操作，例如：获取已连接 station 的信息等。 WIFI_EVENT_AP_STADISCONNECTED 此事件将在以下情况下发生： ​ 1. 应用程序通过调用函数 esp_wifi_disconnect() 或 esp_wifi_deauth_sta() 手动断开 station 连接。 ​ 2. Wi-Fi 驱动程序出于某些原因断开 station 连接，例如：AP 在过去 5 分钟（可通过函数 esp_wifi_set_inactive_time() 修改该时间）内未接收到任何数据包等。 ​ 3. station 断开与 AP 之间的连接。 发生此事件时，事件任务将不做任何响应，但应用程序的事件回调函数需执行一些操作，例如：关闭与此 station 相关的套接字等。 WIFI_EVENT_AP_PROBEREQRECVED 默认情况下，此事件处于禁用状态，应用程序可以通过调用 API esp_wifi_set_event_mask() 启用。 启用后，每当 AP 接收到 probe request 时都将引发此事件。 WIFI_EVENT_STA_BEACON_TIMEOUT 如果 station 在 inactive 时间内未收到所连接 AP 的 beacon，将发生 beacon 超时，将引发此事件。inactive 时间通过调用函数 esp_wifi_set_inactive_time() 设置。 WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START 非连接模块在 Interval 开始时触发此事件。 请参考 非连接模块功耗管理 。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-GPIO的简单使用","slug":"ESP-IDF学习笔记-GPIO的简单使用","date":"2023-04-27T09:35:33.000Z","updated":"2023-05-29T15:33:21.552Z","comments":true,"path":"post/42735/","link":"","permalink":"https://lostacnet.top/post/42735/","excerpt":"ESP-IDF学习笔记-GPIO的简单使用ESP32中的GPIO可以分为简单的GPIO和专用GPIO，这里记录普通GPIO的使用。每个管脚都可用作一个通用 IO，或连接一个内部外设信号。通过 GPIO 交换矩阵、IO MUX 和 RTC IO MUX，可配置外设模块的输入信号来源于任何的 GPIO 管脚，并且外设模块的输出信号也可连接到任意 GPIO 管脚。这些模块共同组成了芯片的输入输出控制。","text":"ESP-IDF学习笔记-GPIO的简单使用ESP32中的GPIO可以分为简单的GPIO和专用GPIO，这里记录普通GPIO的使用。每个管脚都可用作一个通用 IO，或连接一个内部外设信号。通过 GPIO 交换矩阵、IO MUX 和 RTC IO MUX，可配置外设模块的输入信号来源于任何的 GPIO 管脚，并且外设模块的输出信号也可连接到任意 GPIO 管脚。这些模块共同组成了芯片的输入输出控制。 官方文档 参考文章 一，GPIO配置头文件:driver/gpio.h GPIO配置分为结构体配置和函数配置。 结构体配置函数原型: 1esp_err_t gpio_config(const gpio_config_t *pGPIOConfig); 可配置GPIO‘的输入输出模式、上下拉、中断类型、引脚。 使用的gpio_config_t结构体： 成员 类型 作用 典型值 pin_bit_mask uint64_t 选择引脚，以位为单位选择 如(1 &lt;&lt; 18)|(1 &lt;&lt; 19) mode gpio_mode_t 选择输入输出模式 GPIO_MODE_DISABLE pull_up_en gpio_pullup_t 选择是否上拉 GPIO_PULLUP_DISABLE/GPIO_PULLUP_ENABLE pull_down_en gpio_pulldown_t 选择是否下拉 GPIO_PULLDOWN_DISABLE/GPIO_PULLDOWN_ENABLE intr_type gpio_int_type_t 中断触发模式 GPIO_INTR_DISABLE 详细参数解析： gpio_mode_t： GPIO_MODE_DISABLE:失能输入输出 GPIO_MODE_INPUT:输入模式 GPIO_MODE_OUTPUT:输出模式 GPIO_MODE_OUTPUT_OD:开漏输出模式 GPIO_MODE_INPUT_OUTPUT_OD:开漏输入输出模式 GPIO_MODE_INPUT_OUTPUT:输入输出模式 gpio_int_type_t: GPIO_INTR_DISABLE:禁止中断 GPIO_INTR_POSEDGE:上升沿中断 GPIO_INTR_NEGEDGE:下降沿中断 GPIO_INTR_ANYEDGE:边缘中断 GGPIO_INTR_LOW_LEVEL:低电平中断 GPIO_INTR_HIGH_LEVEL:高电平中断 pin_bit_mask: 该参数使用每个bit表示要操作的GPIO口，典型使用值如下: 12345678910// 表示此配置对 GPIO2生效，因为这个64位数的第2位（从零开始）为1pin_bit_mask = 0b0100// 表示此配置对 GPIO0 和 GPIO5 生效，因为第0位和第5位为1pin_bit_mask = 0b100001// 表示此配置对 GPIO16 和 GPIO 18 生效，采用位运算pin_bit_mask = (1ull &lt;&lt; 16) | (1ull &lt;&lt; 18) 使用例: 12345678gpio_config_t gpio={ .pin_bit_mask=1&lt;&lt;GPIO_NUM_3, .mode=GPIO_MODE_OUTPUT, .pull_down_en=0, .pull_up_en=1, .intr_type=GPIO_INTR_DISABLE, }; gpio_config(&amp;gpio); 使用gpio_reset_pin()重置IO口。 ’ 函数配置就是将上面的结构体分成了多个函数进行配置，这里不多讲，请自行参考官方文档。 123456789101112esp_err_t gpio_set_intr_type(gpio_num_t gpio_num, gpio_int_type_t intr_type);esp_err_t gpio_intr_enable(gpio_num_t gpio_num);esp_err_t gpio_intr_disable(gpio_num_t gpio_num);esp_err_t gpio_set_direction(gpio_num_t gpio_num, gpio_mode_t mode);esp_err_t gpio_set_pull_mode(gpio_num_t gpio_num, gpio_pull_mode_t pull);esp_err_t gpio_pullup_en(gpio_num_t gpio_num);esp_err_t gpio_pullup_dis(gpio_num_t gpio_num);esp_err_t gpio_set_drive_capability(gpio_num_t gpio_num, gpio_drive_cap_t strength);//设置IO口驱动能力esp_err_t gpio_get_drive_capability(gpio_num_t gpio_num, gpio_drive_cap_t *strength);esp_err_t gpio_hold_en(gpio_num_t gpio_num);//保持IO口状态esp_err_t gpio_hold_dis(gpio_num_t gpio_num); 二，IO口的使用设置IO口输出： 1esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level); 读取IO口状态： 1int gpio_get_level(gpio_num_t gpio_num); 当IO口没有设置为输入，则读取的值恒为0。 三，中断的使用1，设置中断类型通过结构体配置，或者使用gpio_set_intr_type()函数设置触发中断的条件。 2，创建中断服务函数创建形如以下的中断服务函数 12345678static QueueHandle_t gpio_evt_queue = NULL;...static void IRAM_ATTR gpio_isr_handler(void* arg){ uint32_t gpio_num = (uint32_t) arg; xQueueSendFromISR(gpio_evt_queue, &amp;gpio_num, NULL);} 这里使用的FreeRTOS的消息队列传递中断信息。因为GPIO中断在IRAM中工作，好处是在flash禁用的情况下也可以响应中断。且速度更快，对于这种频繁触发的中断是有利的。但是这个中断也因此无法使用printf等串口打印工作，需要转入其他Task中执行。详见官网API参考—— 中断分配Interrupt Allocation 3，创建中断处理任务函数123456789static void gpio_task_example(void* arg){ uint32_t io_num; for(;;) { if(xQueueReceive(gpio_evt_queue, &amp;io_num, portMAX_DELAY)) { printf(\"GPIO[%\"PRIu32\"] intr, val: %d\\n\", io_num, gpio_get_level(io_num)); } }} 4,安装中断服务1esp_err_t gpio_install_isr_service(int intr_alloc_flags); 参数： intr_alloc_flags – Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. 该函数与gpio_isr_register() 不兼容。gpio_isr_register() 会创建一个中断服务函数处理全部的中断，用户需要在这个处理函数中分辨IO口分别处理。而使用这个函数，会用gpio_isr_register() 创建一个设置好的中断服务函数，分辨IO口的任务已经写好，使用gpio_isr_handler_add()添加每个中断的服务函数。 相应的有移除函数。 1void gpio_uninstall_isr_service(void); 5，为每个IO口添加handle1esp_err_t gpio_isr_handler_add(gpio_num_t gpio_num, gpio_isr_t isr_handler, void *args); 其中**args是上面创建的中断服务函数传入**的参数。 该函数需要在gpio_install_isr_service()后调用。使用该函数添加的服务函数不在需要使用IRAM_ATTR,除非在使用gpio_install_isr_service()时设置了ESP_INTR_FLAG_IRAM 。 删除函数: 1esp_err_t gpio_isr_handler_remove(gpio_num_t gpio_num); 6,开启任务1xTaskCreate(gpio_task_example, \"gpio_task_example\", 2048, NULL, 10, NULL); 注意，上面用到的FreeRTOS的API需要引入相应头文件。 123#include \"freertos/FreeRTOS.h\"#include \"freertos/task.h\"#include \"freertos/queue.h\" 一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include \"freertos/FreeRTOS.h\"#include \"freertos/task.h\"#include \"freertos/queue.h\"#include \"driver/gpio.h\"static QueueHandle_t gpioevent=NULL;static void IRAM_ATTR gpio_intr(void *arg){ uint32_t gpio_num=(uint32_t )arg; xQueueSendFromISR(gpioevent,&amp;gpio_num,NULL);}static void gpio_task(void *arg){ uint32_t io_num; for(;;){ if(xQueueReceive(gpioevent,&amp;io_num,portMAX_DELAY)) { printf(\"GPIO[%\"PRIu32\"] intr, val: %d\\n\", io_num, gpio_get_level(io_num)); } }}void app_main(void){ gpio_config_t gpio; gpio.pull_down_en=0; gpio.mode=GPIO_MODE_INPUT; gpio.pin_bit_mask=1&lt;&lt;GPIO_NUM_8; gpio.intr_type=GPIO_INTR_POSEDGE; gpio.pull_up_en=1; gpio_config(&amp;gpio); gpioevent=xQueueCreate(10, sizeof(uint32_t)); xTaskCreate(gpio_task, \"gpio_task\", 2048, NULL, 10, NULL); gpio_install_isr_service(0); gpio_isr_handler_add(GPIO_NUM_8, gpio_intr, (void*) GPIO_NUM_8); while(1) { ... }}","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-UART的使用","slug":"ESP-IDF学习笔记-UART的使用","date":"2023-04-24T14:43:27.000Z","updated":"2023-05-29T15:34:55.279Z","comments":true,"path":"post/42443/","link":"","permalink":"https://lostacnet.top/post/42443/","excerpt":"ESP-IDF学习笔记-UART的使用ESP32中串口的使用与STM32中大有不同。在ESP32中使用串口，需要配置串口，设置引脚，安装驱动之后才能使用。接收和发送数据也不是直接向寄存器写数据，而是先存到FIFO中，交由ESP32自动发送。其中断的使用更是结合了FreeRTOS的特性进行的。","text":"ESP-IDF学习笔记-UART的使用ESP32中串口的使用与STM32中大有不同。在ESP32中使用串口，需要配置串口，设置引脚，安装驱动之后才能使用。接收和发送数据也不是直接向寄存器写数据，而是先存到FIFO中，交由ESP32自动发送。其中断的使用更是结合了FreeRTOS的特性进行的。 先摆上官方文档。 本文参考于这篇文章 一，串口的配置步骤一个串口的典型使用步骤如下: 使用uart_param_config()设置UART参数 使用art_set_pin()分配UART引脚 使用uart_driver_install()安装UART驱动 使用uart_read_bytes()/uart_write_bytes()收发数据 (可选)新建task读取事件队列处理中断事件 (可选)删除驱动释放资源 其中，1、2、3步可以调换顺序。 二，配置的具体步骤同STM32HAL库的句柄一样，ESP32中使用一个uart_port_t类型的UART_NUM_x变量识别不同的UART控制器，在调用函数时需指明。 其中UART_NUM_MAX表示该芯片最大的uart控制器数，上面的x最大为UART_NUM_MAX-1。 ESP32中默认使用UART_NUM_0作为log库的输出。 UART参数的配置UART参数的配置主要用两种方式，一种是使用uart_param_config+结构体一次性配置；另一种是使用分离函数进行配置。、 单步配置（结构体）使用的函数原型： 1esp_err_t uart_param_config(uart_port_t uart_num, const uart_config_t *uart_config) 参数： uart_num使用的UART编号 uart_config配置的结构体 返回： ESP_OK Success ESP_FALL Parameter error uart_config_t结构体成员： 成员 类型 作用 可用参数 baud_rate int 波特率 宏定义UART_BITRATE_MAX为支持的最大波特率 data_bits uart_word_length_t 数据位长度 UART_DATA_X_BITS(X=5~8 )或UART_DATA_BITS_MAX parity uart_parity_t 校验位 UART_PARITY_X(X=DISABLE,EVEN,ODD) stop_bits uart_stop_bits_t 停止位 UART_STOP_BITS_X(X=1,1_5,2,MAX) flow_ctrl uart_hw_flowcontrol_t 硬件流控制 UART_HW_FLOWCTRL_X(X=DISABLE,RTS,CTS,CTS_RTS,MAX) rx_flow_ctrl_thresh uint8_t 硬件流控制阈值 — source_clk uart_sclk_t 时钟源选择 UART_SCLK_X(X=APB,RTC,XTAL,DEFAULT(APB)) 如果不使用硬件流控制，可以使用 uart_set_rts() 和 uart_set_dtr()软件流控制。 使用例： 123456789101112#include \"driver/uart.h\"#define EX_UART_NUM UART_NUM_0uart_config_t uart_config = { .baud_rate = 115200, .data_bits = UART_DATA_8_BITS, .parity = UART_PARITY_DISABLE, .stop_bits = UART_STOP_BITS_1, .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, .source_clk = UART_SCLK_DEFAULT, };uart_param_config(EX_UART_NUM, &amp;uart_config); 多步配置多步配置的函数表如下： 欲配置的参数 函数 波特率(Baud rate) uart_set_baudrate() 传输数据位长(Number of transmitted bits) uart_set_word_length() selected out of uart_word_length_t 奇偶校验(parity control) uart_set_parity() selected out of uart_parity_t 停止位数(Number of stop bits) uart_set_stop_bits() selected out of uart_stop_bits_t 硬件流控方式(Hardware flow control mode) uart_set_hw_flow_ctrl() selected out of uart_hw_flowcontrol_t 通信方式(Communication mode) uart_set_mode() selected out of uart_mode_t 同时，上面的每个函数都有一个_get_对应对象来检查当前设置的值。例如，要检查当前波特率值，调用uart_get_baudrate()。 分配引脚使用的函数原型 1esp_err_t uart_set_pin(uart_port_t uart_num, int tx_io_num, int rx_io_num, int rts_io_num, int cts_io_num) 参数： uart_num使用的串口编号 tx_io_numTX引脚 rx_io_numRX引脚 rts_io_numRTS引脚 cts_io_numCTS引脚 返回： ESP_OK Success ESP_FALL Parameter error 对于后四个参数，可以使用宏UART_PIN_NO_CHANGE保留已经配置的引脚或者默认引脚。 如果设置的GPIO有该功能的IOMUX（复用），则信号会直接接到该引脚而不通过GPIO矩阵，这样能够支持更高的速率。例如。ESP32S3中IO43是默认的U0TXD，IO44是默认的U0RXD；IO17–U1TXD，IO18–U1RXD。 ESP32提供了一些宏用来定义这些能直连的引脚，参考官方文档，或者见本章高级用法篇。 内部信号能够被输出到多个GPIO，但只有一个GPIO能输入。 经实际测试，ESP32S3的UART好像不能换引脚。 使用例: 123#include \"driver/uart.h\"uart_set_pin(UART_NUM_0,UART_PIN_NO_CHANGE,UART_PIN_NO_CHANGE,UART_PIN_NO_CHANGE,UART_PIN_NO_CHANGE); 安装驱动使用的函数原型： 1esp_err_t uart_driver_install(uart_port_t uart_num, int rx_buffer_size, int tx_buffer_size, int queue_size, QueueHandle_t *uart_queue, int intr_alloc_flags); 参数： uart_num使用的串口编号 rx_buffer_size接收缓冲区大小 tx_buffer_size发送缓冲区大小 queue_size事件队列大小 uart_queue事件队列句柄，如果成功，这里会有一个新的事件队列。如果设为NULL将不使用 intr_alloc_flags用于分配中断的标志。传入一个或多个ESP_INTR_FLAG_*(详见esp_intr_alloc.h)，不能使用ESP_INTR_FLAG_IRAM(在meunconfig中设置) 返回： ESP_OK Success ESP_FALL Parameter error 安装UART驱动程序，同时，UART ISR处理器将被附加到运行该函数的同一个CPU核心上。Rx_buffer_size应该大于UART_FIFO_LEN。Tx_buffer_size应该是**0或者大于UART_FIFO_LEN**。 UART_FIFO_LEN是一个宏定义，定义硬件FIFO的大小 如果发送缓存区为0，则使用uart_write_bytes()时会阻塞发送。 例子： 1uart_driver_install(UART_NUM_0,1024,512,0,NULL,0); 收发数据发数据使用的函数原型： 1int uart_write_bytes(uart_port_t uart_num, const void *src, size_t size); 参数： uart_num使用的串口编号 src数据地址 size数据长度 返回： (-1) Parameter error OTHERS (&gt;=0) The number of bytes pushed to the TX FIFO 如果缓冲区为0，该函数会阻塞直到所有数据被发送或者所有数据被加入FIFO。 缓冲区中的数据会被UART ISR逐步转移到FIFO。（有点像32的Transmit_IT）。 函数uart_write_bytes_with_break()与其功能类似，但会在结束时添加串行中断信号。“串行中断信号”意味着 Tx 线保持低电平的时间长于一个数据帧。 uart_tx_chars()也能将数据写入Tx FIFO，但不会等待可用空间，而是立即放入硬件FIFO。 uart_wait_tx_done()用于监听发送缓冲区，在缓冲区为空时返回。 123// Wait for packet to be sentconst uart_port_t uart_num = UART_NUM_2;ESP_ERROR_CHECK(uart_wait_tx_done(uart_num, 100)); // wait timeout is 100 RTOS ticks (TickType_t) 接数据使用的函数原型： 1int uart_read_bytes(uart_port_t uart_num, void *buf, uint32_t length, TickType_t ticks_to_wait) ticks_to_wait是超时时间，值是RTOS的ticks。 使用该函数前应使用uart_get_buffered_data_len()获得缓冲区数据的长度。比如： 123456// Read data from UART.const uart_port_t uart_num = UART_NUM_2;uint8_t data[128];int length = 0;ESP_ERROR_CHECK(uart_get_buffered_data_len(uart_num, (size_t*)&amp;length));length = uart_read_bytes(uart_num, data, length, 100); 清除缓冲区： 1esp_err_t uart_flush(uart_port_t uart_num); 清除RX缓冲区的内容。 1esp_err_t uart_flush_input(uart_port_t uart_num); 清除输入缓存区内容（如果想等待发送完成，请使用uart_wait_tx_done）。 使用中断这里提到的中断与一般的中断不同，这里应该叫UART事件。中断触发后读取的中断源被当做事件添加到队列中，使用FreeRTOS的一个线程进行读取，处理，得到像中断的效果。 使用事件处理需要在安装驱动时开启事件队列。 1234#include \"driver/uart.h\"static QueueHandle_t uart0_queue;uart_driver_install(UART_NUM_0,1024,512,20,&amp;uart0_queue,0);//队列长度为20 UART 默认的事件处理 没有使用esp_event.h中的事件循环(EventLoop)。而是使用队列传输事件对象（一个uart_event_t类型的结构体）这个结构体包含了事件类型和UART_DATA事件携带的数据。 123456789/** * @brief Event structure used in UART event queue */typedef struct { uart_event_type_t type; /*!&lt; UART 事件类型 */ size_t size; /*!&lt; UART 数据长度(仅UART_DATA 事件)*/ bool timeout_flag; /*!&lt; UART 超时标志(仅UART_DATA 事件)*/ /*!&lt; If the event is caused by FIFO-full interrupt, then there will be no event with the timeout flag before the next byte coming.*/} uart_event_t; 其中，uart_event_type_t包含以下事件： 1234567891011121314151617/** * @brief UART event types used in the ring buffer */typedef enum { UART_DATA, /*!&lt; UART data event UART数据事件*/ UART_BREAK, /*!&lt; UART break event UART中断事件*/ UART_BUFFER_FULL, /*!&lt; UART RX buffer full event UART RX缓冲区满事件*/ UART_FIFO_OVF, /*!&lt; UART FIFO overflow event UART FIFO溢出事件*/ UART_FRAME_ERR, /*!&lt; UART RX frame error event UART RX帧错误事件*/ UART_PARITY_ERR, /*!&lt; UART RX parity event UART奇偶检查错误*/ UART_DATA_BREAK, /*!&lt; UART TX data and break event UART TX数据和中断事件*/ UART_PATTERN_DET, /*!&lt; UART pattern detected UART 输入样式检测事件*/#if SOC_UART_SUPPORT_WAKEUP_INT UART_WAKEUP, /*!&lt; UART wakeup event */#endif UART_EVENT_MAX, /*!&lt; UART event max index*/} uart_event_type_t; 其中，最后一个事件UART_PATTERN_DET是使用uart_enable_pattern_det_baud_intr()启用pattern detect后的触发事件，用于解析特定格式的数据如AT+CGMI。 安装完驱动后，当有事件发生时，会自动向队列中填充信息，一般使用一个任务来进行及时处理。 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"driver/uart.h\"static QueueHandle_t uart0_queue;...static void uart_event_task(void *pv){ uart_event_t event; uint8_t d; while(1) { if(xQueueReceive(uart0_queue, (void * )&amp;event, (TickType_t)portMAX_DELAY)) { ESP_LOGI(TAG,\"A event in\"); switch (event.type) { case UART_DATA: uart_read_bytes(UART_NUM_0,&amp;d,1,(TickType_t)portMAX_DELAY); uart_write_bytes(UART_NUM_0, &amp;d, 1); break; case UART_BREAK: break; case ...: break; ... default: //ESP_LOGI(TAG, \"uart event type: %d\", event.type); break; } } }}...void app_main(void){ ... uart_driver_install(UART_NUM_0,1024,512,20,&amp;uart0_queue,0); ... xTaskCreate(uart_event_task, \"uart_event_task\", 2048, NULL, 12, NULL);} 删除驱动1esp_err_t uart_driver_delete(uart_port_t uart_num); 使用该函数释放资源。 三，高级用法其他模式UART 控制器支持多种通信模式，使用函数 uart_set_mode()可以选择模式。选择特定模式后，UART 驱动程序将处理已连接 UART 设备的相应行为。 1esp_err_t uart_set_mode(uart_port_t uart_num, uart_mode_t mode); 参数： mode使用的模式 该函数必须在uart_driver_install()之后使用。 支持的参数如下： 参数 模式 UART_MODE_UART 普通UART UART_MODE_RS485_HALF_DUPLEX half duplex RS485 UART mode control by RTS pin UART_MODE_IRDA 类似于红外协议的模式 UART_MODE_RS485_COLLISION_DETECT RS485 collision detection UART mode (used for test purposes) UART_MODE_RS485_APP_CTRL application control RS485 UART mode (used for test purposes) 具体使用参考官方文档 pattern_detect在检测到重复接收/发送同一字符的“模式”时触发中断。例如，模式检测可用于检测命令字符串末尾是否存在特定数量的相同字符（“模式”）。 配置并启用此中断：调用 uart_enable_pattern_det_baud_intr() 禁用中断：调用 uart_disable_pattern_det_intr() 用法参见peripherals/uart/uart_events 自定义UART中断如果不想使用默认的 UART 中断（如上文的 UART 事件 Queue 等高级API）或者自己另有别的绝妙之用，可以注册自己的UART中断。 使用 uart_isr_register() 注册中断 使用 uart_isr_free() 释放注册的中断 写的中断 ISR 程序需要尽可能简短，不要忘了在处理中断前后调用uart_clear_intr_status()清除中断标志。 一些宏12345678910111213141516171819202122232425UART_GPIO43_DIRECT_CHANNELUART_NUM_0_TXD_DIRECT_GPIO_NUMUART_GPIO44_DIRECT_CHANNELUART_NUM_0_RXD_DIRECT_GPIO_NUMUART_GPIO16_DIRECT_CHANNELUART_NUM_0_CTS_DIRECT_GPIO_NUMUART_GPIO15_DIRECT_CHANNELUART_NUM_0_RTS_DIRECT_GPIO_NUMUART_TXD_GPIO43_DIRECT_CHANNELUART_RXD_GPIO44_DIRECT_CHANNELUART_CTS_GPIO16_DIRECT_CHANNELUART_RTS_GPIO15_DIRECT_CHANNELUART_GPIO17_DIRECT_CHANNELUART_NUM_1_TXD_DIRECT_GPIO_NUMUART_GPIO18_DIRECT_CHANNELUART_NUM_1_RXD_DIRECT_GPIO_NUMUART_GPIO20_DIRECT_CHANNELUART_NUM_1_CTS_DIRECT_GPIO_NUMUART_GPIO19_DIRECT_CHANNELUART_NUM_1_RTS_DIRECT_GPIO_NUMUART_TXD_GPIO17_DIRECT_CHANNELUART_RXD_GPIO18_DIRECT_CHANNELUART_CTS_GPIO20_DIRECT_CHANNELUART_RTS_GPIO19_DIRECT_CHANNEL","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-工程结构","slug":"ESP-IDF学习笔记-工程结构","date":"2023-04-23T08:46:54.000Z","updated":"2023-05-29T15:37:47.754Z","comments":true,"path":"post/42346/","link":"","permalink":"https://lostacnet.top/post/42346/","excerpt":"ESP-IDF学习笔记-工程结构学习ESP-IDF的使用，首先得要学习一个IDF工程的结构。ESP-IDF的工程是以Cmake组织的，并使用了Ninja作为构建工具，这里只简单给出如何使用这套系统。","text":"ESP-IDF学习笔记-工程结构学习ESP-IDF的使用，首先得要学习一个IDF工程的结构。ESP-IDF的工程是以Cmake组织的，并使用了Ninja作为构建工具，这里只简单给出如何使用这套系统。 官方文档 参考于 一，目录结构一个IDF工程一般有以下结构的目录： 123456789101112131415- myProject/ - CMakeLists.txt - sdkconfig - components/ - component1/ - CMakeLists.txt - Kconfig - src1.c - component2/ - CMakeLists.txt - Kconfig - src1.c - include/ - component2.h - main/ - CMakeLists.txt - src1.c - src2.c - build/ 顶层目录的CMakeList.txt：这是整个项目的CMake文件，其中引入了/tools/cmake/project.cmake用来构建其他部分。同时设置了工程名。 sdkconfig：项目配置文件，使用idf.py menuconfig配置在IDE中对应设置按钮出现的菜单。在菜单中的配置以宏定义的方式出现在源码中。 main：特殊的目录，包含项目本身的源码，被认为是mian组件。 build：编译结果 components：（可选）组件，即各种库。 项目CMakeLists该文件配置整个项目，通常十分小。最小情况如下: 123cmake_minimum_required(VERSION 3.16)include($ENV{IDF_PATH}/tools/cmake/project.cmake)project(myProject) cmake_minimum_required(VERSION 3.16) 必须放在 CMakeLists.txt 文件的第一行，它会告诉 CMake 构建该项目所需要的最小版本号。ESP-IDF 支持 CMake 3.16 或更高的版本。 include($ENV{IDF_PATH}/tools/cmake/project.cmake) 会导入 CMake 的其余功能来完成配置项目、检索组件等任务。 project(myProject) 会创建项目本身，并指定项目名称。该名称会作为最终输出的二进制文件的名字，即 myProject.elf 和 myProject.bin。每个 CMakeLists 文件只能定义一个项目。 同时该文件可以配置一些全局变量用来修改默认值自定义构建系统： COMPONENT_DIRS：组件的搜索目录，默认为 IDF_PATH/components、 PROJECT_DIR/components、和 EXTRA_COMPONENT_DIRS。如果您不想在这些位置搜索组件，请覆盖此变量。 EXTRA_COMPONENT_DIRS：用于搜索组件的其它可选目录列表。路径可以是相对于项目目录的相对路径，也可以是绝对路径。 COMPONENTS：要构建进项目中的组件名称列表，默认为 COMPONENT_DIRS 目录下检索到的所有组件。使用此变量可以“精简”项目以缩短构建时间。请注意，如果一个组件通过 COMPONENT_REQUIRES 指定了它依赖的另一个组件，则会自动将其添加到 COMPONENTS 中，所以 COMPONENTS 列表可能会非常短。 使用 cmake 中的 set 命令 来设置这些变量，如 set(VARIABLE \"VALUE\")。请注意，set() 命令需放在include(...)之前，cmake_minimum(...) 之后。 组件CMakeList.txt组件是 COMPONENT_DIRS 列表中的任何包含CMakeList.txt目录。IDF按以下顺序搜索组件，如果有多个同名组件，以最后一个为准。 搜索 ESP-IDF 内部组件（$ENV{IDF_PATH}/components） 搜索 EXTRA_COMPONENT_DIRS 中的组件 搜索项目组件（$ENV{PROJECT_DIR}/components） 组件最小CMakeList如下： 1234idf_component_register( SRCS \"foo.c\" \"cplus.cpp\" INCLUDE_DIRS \"include\") SRCS：源文件列表 INCLUDE_DIRS：组件的include目录，会被添加到头文件搜索目录中 除此之外，还有一些非必须的变量： REQUIRES：申明组件的共用依赖，一般就是头文件中include的其他组件 PRIV_REQUIRES：申明组件的私有依赖，一般是源文件中include的其他组件 …. 其中main也是一个组件，但其默认依赖所有组件。 二，配置菜单IDF中将组件的配置以宏定义的形式移出代码，放进idf的meunconfig中进行配置。在项目的任意位置，都可以使用#include \"sdkconfig.h“进行访问。 配置文件种类 文件名 位置 作用 Kconfig 组件(手动创建) 在menuconfig中的菜单中创建Component Configuration子菜单 Kconfig.projbuild 组件(手动创建) 在menuconfig中创建顶层菜单 sdkconfig 工程(自动生成) 保持配置 sdkconfig.h 工程编译文件(自动生成) 配置的访问接口 sdkconfig.default 工程(手动创建) 配置的默认值 sdkconfig.old 工程(自动生成) 备份 sdkconfig.ci 用于单元测试 sdkconfig.rename 用于重命名弃用的配置名，方便旧配置文件快速用于新配置，兼容 sdkconfig.default可为不同设备添加默认配置,如:sdkconfig.default.esp32s3 创建菜单官方文档 创建菜单在Kconfig或者Kconfig.projbuild中按照特定语法进行创建。 具体语法可以参考这篇文章 这里直接给出该文章的中的例子： 123456789101112131415161718192021222324252627282930313233343536menu \"My menu\" # bool 是勾选框 config MY_TEST_BOOL bool \"bool_test\" help This is a bool test. # int 是输入整数 config MY_TEST_INT int \"int_test\" default 12345 help This is an int test. # hex 是输入16进制数 config MY_TEST_HEX hex \"hex_test\" default 0x7FFF help This is a hex test. # tristate 在 ESP-IDF构建系统中会被当做 bool 处理 config MY_TEST_TRISTATE tristate \"tristate_test\" help This is a tristate test. # string 表示一个字符串 config MY_TEST_STRING string \"string_test\" help This is a string test.endmenu 生成的宏定义是： 1234#define CONFIG_MY_TEST_BOOL 1#define CONFIG_MY_TEST_INT 12345#define CONFIG_MY_TEST_HEX 0x7FFF#define CONFIG_MY_TEST_STRING \"ESP32 YYDS\" 宏定义的结构是:CONFIG_+配置名 创建选项菜单: 12345678910111213141516171819202122232425menu \"My Menu\" choice MY_TEST_CHOICE prompt \"My Test Choice\" default MY_CHOICE_OPTION1 help This is a help. config MY_CHOICE_OPTION1 bool \"option1\" help help for option1 config MY_CHOICE_OPTION2 bool \"option2\" help help for option2 config MY_CHOICE_OPTION3 bool \"option3\" help help for option3 endchoiceendmenu 生成的宏定义： 1#define CONFIG_MY_CHOICE_OPTION_1","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-错误处理","slug":"ESP-IDF学习笔记-错误处理","date":"2023-04-20T17:18:45.000Z","updated":"2024-02-09T14:14:37.341Z","comments":true,"path":"post/42118/","link":"","permalink":"https://lostacnet.top/post/42118/","excerpt":"ESP-IDF学习笔记-错误处理同STM32HAL库的各种错误状态码一样，ESP-IDF中也有不同的错误码以及相应的错误处理方法，这给出基本的使用。","text":"ESP-IDF学习笔记-错误处理同STM32HAL库的各种错误状态码一样，ESP-IDF中也有不同的错误码以及相应的错误处理方法，这给出基本的使用。 首先放上官方文档 一，错误的分类ESP32中主要有两类错误： 可恢复错误 可用错误状态码表示，使用 throw 关键字抛出的 C++ 异常。 不可恢复（严重）错误 断言失败：（使用 assert 宏或者其它类似方法，可参考 Assertions）或者直接调用 abort() 函数造成的错误 CPU 异常：访问受保护的内存区域、非法指令等 系统级检查：看门狗超时、缓存访问错误、堆栈溢出、堆栈粉碎、堆栈损坏等 二，错误码与错误消息在ESP-IDF中，错误码的类型是esp_err_t，本质是带符号整型。其中表示没有错误的定义是：ESP_OK具体定义为0。 对于一个具体的错误，错误码常常以ESP_ERR_XXX形式呈现，常见的错误码在esp_err.h中已经定义好了，各个组件也可以自定义。 得到整型的错误码可以使用esp_err_to_name()或者esp_err_to_name_r()函数(esp_err.h)将其转换为字符串(返回值是const char *)，这两个函数的区别主要在于当没有匹配的错误时，是否用 标准 POSIX 错误代码 进行解释。 三，常用宏 ESP_ERROR_CHECK 该宏定义在esp_err.h中。功能与assert相似，但是会检测错误值并打印错误信息，最后调用abort()。 通常错误信息如下: 1234567ESP_ERROR_CHECK failed: esp_err_t 0x107 (ESP_ERR_TIMEOUT) at 0x400d1fdffile: \"/Users/user/esp/example/main/main.c\" line 20func: app_mainexpression: sdmmc_card_init(host, &amp;card)Backtrace: 0x40086e7c:0x3ffb4ff0 0x40087328:0x3ffb5010 0x400d1fdf:0x3ffb5030 0x400d0816:0x3ffb5050 ESP_ERROR_CHECK_WITHOUT_ABORT 该宏定义在esp_err.h中。功能与ESP_ERROR_CHECK一样，但不会调用abort()。 以下宏定义在esp_check.h ESP_RETURN_ON_ERROR 宏 ESP_RETURN_ON_ERROR 用于错误码检查, 如果错误码不等于 ESP_OK, 该宏会打印错误信息，并使原函数立刻返回。 ESP_GOTO_ON_ERROR 宏 ESP_GOTO_ON_ERROR 用于错误码检查, 如果错误码不等于 ESP_OK, 该宏会打印错误信息，将局部变量 ret 赋值为该错误码, 并使原函数跳转至给定的 goto_tag. ESP_RETURN_ON_FALSE 宏 ESP_RETURN_ON_FALSE 用于条件检查, 如果给定条件不等于 true, 该宏会打印错误信息，并使原函数立刻返回，返回值为给定的 err_code. ESP_GOTO_ON_FALSE 宏 ESP_GOTO_ON_FALSE 用于条件检查, 如果给定条件不等于 true, 该宏会打印错误信息，将局部变量 ret 赋值为给定的 err_code, 并使原函数跳转至给定的 goto_tag. ESP_RETURN_xx 和 ESP_GOTO_xx 宏不可以在中断服务程序里被调用。 使用例: 1234567891011121314151617static const char* TAG = \"Test\";esp_err_t test_func(void){ esp_err_t ret = ESP_OK; ESP_ERROR_CHECK(x); // err message printed if `x` is not `ESP_OK`, and then `abort()`. ESP_ERROR_CHECK_WITHOUT_ABORT(x); // err message printed if `x` is not `ESP_OK`, without `abort()`. ESP_RETURN_ON_ERROR(x, TAG, \"fail reason 1\"); // err message printed if `x` is not `ESP_OK`, and then function returns with code `x`. ESP_GOTO_ON_ERROR(x, err, TAG, \"fail reason 2\"); // err message printed if `x` is not `ESP_OK`, `ret` is set to `x`, and then jumps to `err`. ESP_RETURN_ON_FALSE(a, err_code, TAG, \"fail reason 3\"); // err message printed if `a` is not `true`, and then function returns with code `err_code`. ESP_GOTO_ON_FALSE(a, err_code, err, TAG, \"fail reason 4\"); // err message printed if `a` is not `true`, `ret` is set to `err_code`, and then jumps to `err`.err: // clean up return ret;} 如果 Kconfig 中的 CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT 选项被打开, CHECK 宏将不会打印错误信息，其他功能不变。 四，错误处理根据错误码恢复用变量储存错误码，在代码中判断错误码类型，根据类型不同尝试恢复。或者使用上面用到的CHECK宏。 转化为不可恢复错误使用ESP_ERROR_CHECK处理返回值。 1ESP_ERROR_CHECK(spi_bus_initialize(host, bus_config, dma_chan)); 五，严重错误以下情况为不可恢复的严重错误，程序会中断重启。 CPU 异常：非法指令，加载/存储时的内存对齐错误，加载/存储时的访问权限错误，双重异常。 系统级检查错误： 中断看门狗 超时 任务看门狗 超时（只有开启 CONFIG_ESP_TASK_WDT_PANIC 后才会触发严重错误） 高速缓存访问错误 内存保护故障 掉电检测事件 堆栈溢出 堆栈粉碎保护检查 堆完整性检查 未定义行为清理器 (UBSAN) 检查 使用 assert、configASSERT 等类似的宏断言失败。 官方文档给出了参考解决，这里先待补，等以后接触后继续。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"ESP-IDF学习笔记-调试等级打印","slug":"ESP-IDF学习笔记-调试等级打印","date":"2023-04-20T14:56:23.000Z","updated":"2023-05-29T15:37:15.930Z","comments":true,"path":"post/42056/","link":"","permalink":"https://lostacnet.top/post/42056/","excerpt":"ESP-IDF学习笔记-调试等级打印ESP32IDF中提供了一个LOG库，根据不同调试等级打印信息，这里记录一下简单用法。","text":"ESP-IDF学习笔记-调试等级打印ESP32IDF中提供了一个LOG库，根据不同调试等级打印信息，这里记录一下简单用法。 官方的LOG库文档 官方给的库用法很多还有一些高级用法，但是我们只需要使用简单的就行了。 一，调试级别ESP32LOG库定义的如下调试级别(按等级高低从低到高排列)： ESP_LOGE - error (lowest) ESP_LOGW - warning ESP_LOGI - info ESP_LOGD - debug ESP_LOGV - verbose (highest) 对应的在IDF中的调试级别设置如图: 对应的设置选项为： CONFIG_LOG_DEFAULT_LEVEL:默认调试级别 CONFIG_LOG_MAXIMUM_LEVEL:最高调试级别 高于默认调试级别的调试信息不会打印。 CONFIG_LOG_MAXIMUM_LEVEL用来设置esp_log_level_set() 可以设置的最高级别的调试等级(代码中动态调整调试等级)。 剩下一个设置项用来设置调试时间戳的来源，可以设置为来自于FreeRTos的时基，从系统重启后到现在的ms；或者为实际时间，来自RTC外设（可通过SNTP在重启置0后校准）。 二，API函数常用函数如下： 123456789101112131415//打印调试信息ESP_LOGE();//error (lowest)ESP_LOGW();//warningESP_LOGI();//infoESP_LOGD();//debugESP_LOGV();//verbose (highest)//设置调试等级void esp_log_level_set(const char *tag, esp_log_level_t level);//设置TAG的调试等级esp_log_level_t esp_log_level_get(const char *tag);//获得TAG的调试等级 使用方法： 定义TAG 123static const char* TAG = \"MyModule\";//others#define TAG \"MyModule\" 调用打印函数 1ESP_LOGW(TAG, \"Baud rate error %.1f%%. Requested: %d baud, actual: %d baud\", error * 100, baud_req, baud_real); 通过在esp_log.h前定义LOG_LOCAL_LEVEL来重新设置默认调试等级: 12#define LOG_LOCAL_LEVEL ESP_LOG_VERBOSE#include \"esp_log.h\" 对于组件(component)可以在CMakeLists中设置来重设: 1target_compile_definitions(${COMPONENT_LIB} PUBLIC \"-DLOG_LOCAL_LEVEL=ESP_LOG_VERBOSE\") 可以通过``在运行时设置各个TAG的调试等级： 123esp_log_level_set(\"*\", ESP_LOG_ERROR); // set all components to ERROR levelesp_log_level_set(\"wifi\", ESP_LOG_WARN); // enable WARN logs from WiFi stackesp_log_level_set(\"dhcpc\", ESP_LOG_INFO); // enable INFO logs from DHCP client 三，高级用法输出端口默认情况下，日志输出到串口，使用类vsprintf函数。 通过调用以下函数，可以将输出定向到JATG： 1esp_log_set_vprintf(esp_apptrace_vprintf); 如果想重新设置回UART： 1esp_log_set_vprintf(vprintf); 其他输出API1ESP_EARLY_LOGx() 在系统早期启动过程使用：在堆分配前和系统调用前使用 1ESP_DRAM_LOGx() 在中断被关闭或者Flash缓存无法访问时使用，由于对系统性能考虑，应尽可能少使用。","categories":[{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"}]},{"title":"对带通采样定理的理解","slug":"对带通采样定理的理解","date":"2023-04-01T08:29:57.000Z","updated":"2023-04-01T10:15:34.895Z","comments":true,"path":"post/4129/","link":"","permalink":"https://lostacnet.top/post/4129/","excerpt":"对带通采样定理的理解奈奎斯特采样定理要求采样频率必须大于信号频率的2倍，不然会发生频谱混叠。但是对于高频信号，ADC难以达到所需要的采样率。实际上，我们进行频谱分析时，只需要让我们需要信号的频率不发生频谱混叠就行了，由此就出现了带通采样定理。","text":"对带通采样定理的理解奈奎斯特采样定理要求采样频率必须大于信号频率的2倍，不然会发生频谱混叠。但是对于高频信号，ADC难以达到所需要的采样率。实际上，我们进行频谱分析时，只需要让我们需要信号的频率不发生频谱混叠就行了，由此就出现了带通采样定理。 本文参考于带通采样定理及其公式推导 一，奈奎斯特采样定理和带通采样定理奈奎斯特采样定理奈奎斯特采样定理又称低通采样定理。其“低通”的含义是从0频率到信号中角频率最大的分量都能复原，不发生频谱混叠。这样就要求以0为中心2*w宽度的频段都必须没有重叠： 这就是所谓低通。 但这样会导致两个中心频率相距至少要2*w以上，即采样频率为原信号的两倍，对采样率要求极为苛刻。 更多信息可见我的另外一篇博客:对Nyquist-Shannon采样定理的直观理解 带通采样定理很多时候，我们的关注的信号频率主要集中于高频段，对低频信号不关心。如图，我们只关心高频很窄的一段信号： 这就是所谓带通。 二，带通采样定理理解什么是带通后，我们对其进行分析。 对于奈奎斯特采样定理，我们要求采样频率在我们关心的频率范围内（0-最大频率分量）不发生频谱叠加。因此对于带通采样，我们同样只要求在我们需要的频率内不发生频谱叠加。 随着采样率的增加，采样信号频谱周期延拓的周期越来越大，在这个过程中，我们只需要取带通的频谱不重叠的采样频率就行了。 （偷一下氧离子大佬的图） 红色的是原信号，绿色和蓝色是采样导致的周期延拓出来的信号。 可以看到，我们只需要保证绿色和蓝色的频谱不和红色的频谱重合，就不会发生频谱重叠，我们依然可以得到想要的信号。 将上面的要求用数学公式表达出来：那么就可以得出采样频率的要求是：显然，存在条件是：方框代表向下整，为整数可见，当m=0，就是奈奎斯特采样定理。 三，一个例子假设一个信号的频率在45-55MHz的范围，那么对采样率的要求是 那么可以得到： 最小采样率被降低到了原来的二分之一左右。","categories":[{"name":"信号处理","slug":"信号处理","permalink":"https://lostacnet.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"带通采样","slug":"带通采样","permalink":"https://lostacnet.top/tags/%E5%B8%A6%E9%80%9A%E9%87%87%E6%A0%B7/"}]},{"title":"对Nyquist-Shannon采样定理的直观理解","slug":"对Nyquist-Shannon采样定理的直观理解","date":"2023-04-01T02:54:53.000Z","updated":"2023-04-01T05:16:09.367Z","comments":true,"path":"post/4154/","link":"","permalink":"https://lostacnet.top/post/4154/","excerpt":"对Nyquist-Shannon采样定理的直观理解奈奎斯特(香农)采样定理是信号采样中需要遵守的重要定理，即采样频率至少为信号频率的两倍，才能还原原信号。这里给出对其原理的直观理解。","text":"对Nyquist-Shannon采样定理的直观理解奈奎斯特(香农)采样定理是信号采样中需要遵守的重要定理，即采样频率至少为信号频率的两倍，才能还原原信号。这里给出对其原理的直观理解。 一，时域与频域的联系在讨论具体的采样定理前，首先需要一点基础。 在信号与系统中我们学到，对一个冲激信号，其在频域上是1。而对于1，频域上是一个冲激。如果将1视为周期无限小的冲激信号，但冲激信号的周期从无限小到无限大时，频域上的最开始周期无限大的周期信号也逐渐变成周期无限小的周期信号，最终变成1。 那么从这个过程我们可以得到直观的结论： 时域连续，频域离散，反之亦然。 采样后的信号频谱是原始信号频谱的周期延拓，延拓周期就是采样角频率。 对于第二个结论，这里有着科学的证明：采样定理推导(The Nyquist–Shannon sampling theorem)（本文章的图也来自于这里） 二，采样定理知道采样信号的频谱是原信号的周期延拓后，我们就可以直接理解采样定理了。 如果一个信号的频谱为下图这样： 图中的w是该信号中频率最大的信号分量，这个区间内的信号就原信号的全部频谱。 那么对该信号进行采样后，频谱就会变成该信号的周期延拓: Wo就是采样的角频率，在上图情况中，采样频率小于信号频率的两倍，导致频谱间相互叠加，原信号无法复原。 当采样频率大于信号频率的两倍时，频谱就不会叠加了。这时可以得到原来的信号。","categories":[{"name":"信号处理","slug":"信号处理","permalink":"https://lostacnet.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"奈奎斯特(香农)采样定理","slug":"奈奎斯特-香农-采样定理","permalink":"https://lostacnet.top/tags/%E5%A5%88%E5%A5%8E%E6%96%AF%E7%89%B9-%E9%A6%99%E5%86%9C-%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86/"}]},{"title":"频谱泄露与窗函数","slug":"频谱泄露与窗函数","date":"2023-03-29T15:52:30.000Z","updated":"2023-03-30T06:14:08.832Z","comments":true,"path":"post/32952/","link":"","permalink":"https://lostacnet.top/post/32952/","excerpt":"频谱泄露与窗函数在FFT(傅里叶变换)分析信号时，常常会提到频谱泄露现象，即某频率谱线的幅值分布到其他频段。这样会严重影响信号频率和幅度的判断，为了减轻这种现象，使用窗函数进行截取，即加窗。","text":"频谱泄露与窗函数在FFT(傅里叶变换)分析信号时，常常会提到频谱泄露现象，即某频率谱线的幅值分布到其他频段。这样会严重影响信号频率和幅度的判断，为了减轻这种现象，使用窗函数进行截取，即加窗。 一，频谱泄露现象对原信号做非周期截断后进行FFT，得到的频率谱线会出现旁瓣，即出现原信号频率之外的的频谱，同时原信号幅度降低，可视为原信号的能量泄露到附近频点上。 非周期截断： 做FFT后有频谱泄露： 二，周期截断与非周期截断信号截断由于实际信号处理时，我们不可能将整个原始信号进行FFT，只能截取信号的一部分进行处理，这个过程就叫信号截断。 根据截取信号的长度与周期的关系，可以分为周期截断和非周期截断。 周期截断如果截取信号的长度为原信号周期的整数倍，则截断后的信号依然为周期信号，可以重构为原始信号，进行FFT后的频谱频率成分为原信号频率，100%幅度。 假设原始信号的频率为f Hz，则周期为1/f s，截取信号的时间长度为T=k/f。则频率分辨率为1/T=f/k。那么原信号频率成分为f=k*1/T，即有一条谱线正好是原信号频率成分。 非周期截断如果截取信号的长度不是原信号周期的整数倍，则截断后的信号不是周期信号，重构出来的信号不连续，出现跳跃。 对这种信号进行FFT后，频谱会分散，原信号频率成分的幅值不再是100%。反而原信号周围谱线出现幅值，即泄露到了周围频谱。 非周期截断中，没有一条谱线与原信号完全相同。 三，FFT变换根据傅里叶变换的推导，我们可以知道周期信号可以用傅里叶级数表示，即使用频谱中的一些离散点表示。而对非周期信号，只能用连续的频谱去无限逼近，因此非周期截断会出现泄露。 四，窗函数引入窗函数前，先来直观理解一下什么是窗。我们对信号进行截断，就好像在信号上面套了一个窗户，我们只能看见窗户里面的信号，用这里面的信号去分析原信号。这就是加窗的直观理解。 为什么要使用窗函数窗函数就是给窗内信号的每个点都加上一个权值，使窗内信号的起始和截止幅度都为0，让窗里面的信号变成周期信号，从而减少频谱泄露(不能消除)。 常见窗函数各种窗函数频谱特征的主要差别在于：主瓣宽度（也称为有效噪声带宽，ENBW）、幅值失真度、最高旁瓣高度和旁瓣衰减速率等参数。不同的窗函数具有不同的频谱特征。 主瓣宽度主要影响信号能量分布和频率分辨能力。频率的实际分辨能力为有效噪声带宽乘以频率分辨率，因此，主瓣越宽，有效噪声带宽越宽，在频率分辨率相同的情况下，频率的分辨能力越差。 旁瓣高低及其衰减率影响能量泄漏程度（频谱拖尾效应）。旁瓣越高，说明能量泄漏越严重，衰减越慢，频谱拖尾越严重。 矩形窗如果直接对信号截断，则窗内的信号权重都为1，这种窗称为矩形窗。 这种窗的优点是主瓣比较集中，缺点是旁瓣较高，而且可能伴有负旁瓣，频谱泄漏 现象会较为严重. 特点就是可以保证测量时的频率较为精确，但是不能保证幅值测量的精确性. 三角窗三角窗使用渐进的权重，让边界处的信号为0，这种窗其主瓣宽度比矩形窗宽约一倍，旁瓣 相比于矩形窗非常小，测幅度会准一些但测频率就差。 汉宁窗汉宁窗会增加主瓣宽度，导致频率分辨率下降。 汉明窗汉明窗和汉宁窗基本一致，不一致的只有一个参数。 凯泽窗 其中 N 为序列的长度，I0 的零阶的第一类修正贝塞尔函数，α 是任意非负实数，用于调整凯 泽窗的外形，由使用者根据实际情况给定。 平顶窗 常见窗函数参数 根据此表可以估计窗函数性能，帮助选择。 窗函数选择加窗函数时，应使窗函数频谱的主瓣宽度应尽量窄，以获得高的频率分辨能力；旁瓣衰减应尽量大，以减少频谱拖尾，但通常都不能同时满足这两个要求。因此需要根据实际需求选择合适窗函数。 这里给出一个参考： 如果截断的信号仍为周期信号，则不存在泄漏，无须加窗，相当于加矩形窗。 如果信号是随机信号或者未知信号，或者有多个频率分量，测试关注的是频率点而非能量大小，建议选择汉宁窗。 对于校准目的，则要求幅值精确，平顶窗是个不错的选择。 如果同时要求幅值精度和频率精度，可选择凯塞窗。 如果检测两个频率相近、幅值不同的信号，建议用布莱克曼窗。 锤击法试验力信号加力窗，响应可加指数窗。","categories":[{"name":"信号处理","slug":"信号处理","permalink":"https://lostacnet.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"https://lostacnet.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"加窗","slug":"加窗","permalink":"https://lostacnet.top/tags/%E5%8A%A0%E7%AA%97/"}]},{"title":"对傅里叶变换的一些理解","slug":"对傅里叶变换的一些理解","date":"2023-03-29T15:02:20.000Z","updated":"2023-03-29T15:43:59.205Z","comments":true,"path":"post/32902/","link":"","permalink":"https://lostacnet.top/post/32902/","excerpt":"对傅里叶变换的一些理解傅里叶变换将时域信号变成频域信号，能对信号进行频域上的分析，是分析信号的重要手段。这里我记录一下我对傅里叶变换的过程理解。","text":"对傅里叶变换的一些理解傅里叶变换将时域信号变成频域信号，能对信号进行频域上的分析，是分析信号的重要手段。这里我记录一下我对傅里叶变换的过程理解。 一，基本知识这里不加证明的给出几条基本知识： 任何周期信号都能够用傅里叶级数表示，即写成 形式。 是傅里叶级数系数，也称频率谱线，表示一个频率所占信号成分的的多少，其表达式为。 二，非周期函数的傅里叶变换周期函数的傅里叶变换就是将其写成傅里叶级数的形式，便可得到频谱。而对于不能写成傅里叶级数形式的非周期函数，可以将其视为的特殊情况，无限逼近。 对周期函数有：当时，可以得到：无限大，周期函数变非周期函数 无限小，变成微分 无限小，可以代表任何值，变成连续变量 变成连续的函数 那么定义一个X(jw)：则X(jw)是一个连续的频谱，值与**意义相同**。 现在再次看到周期函数的傅里叶变换，可以看到傅里叶级数是X(jw)的一系列离散点，而非周期函数是整个连续的频谱。 三，逆傅里叶变换周期函数的逆傅里叶变换就是傅里叶级数的形式：非周期函数的逆傅里叶变换则是将离散变连续:","categories":[{"name":"信号处理","slug":"信号处理","permalink":"https://lostacnet.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"https://lostacnet.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"}]},{"title":"MSP432E4学习笔记:工程创建","slug":"MSP432E4学习笔记-工程创建","date":"2023-03-25T08:50:15.000Z","updated":"2023-05-29T15:40:48.253Z","comments":true,"path":"post/32550/","link":"","permalink":"https://lostacnet.top/post/32550/","excerpt":"MSP432E4学习笔记:工程创建由于Ti是电赛的大金主，在比赛中使用Ti的片子会带来优势。正好手头有一块MSP432E401Y(官板真是好看)，所以打算趁着周六强制考勤时间去入门一下。","text":"MSP432E4学习笔记:工程创建由于Ti是电赛的大金主，在比赛中使用Ti的片子会带来优势。正好手头有一块MSP432E401Y(官板真是好看)，所以打算趁着周六强制考勤时间去入门一下。 一，下载必要软件包Ti为MSP430E4提供了SDK。但是Ti官网的命名让人十分迷惑，关于MSP432可以在Ti官网找到两个包：MSP432WARE,SIMPLELINK-MSP432E4-SDK.经过实测，其中SIMPLELINK-MSP432E4-SDK是MSP432E4的SDK，另外一个是MSP432P的SDK(SBTi)。 下载后直接安装，安装完成后会自动打开版本手册和快速开始指导，其中快速指导中写了如何创建新的工程，包括使用CCS，IAR，Keil。我们这里使用Keil进行开发。 Download and Install Keil uVision 5.23 Install the TexasInstruments::MSP432E4xx_DFP pack Install the ARM::CMSIS pack 可以看到，我们还需要下载MSP432E4的keil PACK。 打开keil，进入Pack Installer。 在Devices中找到Ti的MSP432E4。 点击后，在右侧可以看见pack包，可以选择直接在软件中安装(很慢)，也可以选择自己到网页上下载。 这里为了快速下载，我们点击Device中芯片型号后面的蓝色链接打开keil官网，如下图，点击Download按钮直接下载Pack，下载完成后点击安装。 完成上述步骤后开发环境就配置好了，打开SDK安装目录下的点灯例程:examples\\nortos\\MSP_EXP432E401Y\\driverlib\\blinky,打开工程，编译。 将MSPE401Y开发板连接上电脑，这时电脑应该会自动配置驱动，配置完成后点击下载程序，就可以看见灯闪了。 二，创建新的工程（一）通过空工程创建在Quick_Start中，Ti告诉我们不要使用Keil自带的创建工程新建新的工程，要求基于其中的例程进行创建，也就是直接使用Ti给你创建好的工程进行开发。 Do not use the New Project Creation Wizard Start with one of the example projects or empty project template shipped inside the SDK. Each software component in the SDK comes with its own set of examples. If your project depends on multiple TI provided software libraries, start from the empty template then add the necessary components into your projects. Import one of the empty project template shown below to your IDE and start your application from there. All the necessary include paths and SDK specific defines if any are already part of the Empty Project Template 因此，直接打开:examples\\nortos\\MSP_EXP432E401Y\\driverlib\\empty空工程进行就可以进行开发了。 （二）使用Keil创建工程由于之前刚刚学会了如何脱离Cube创建STM32的工程，现在想自己实践一下亲自创建，所以打算手动创建一下Keil工程(浑身反骨)。 我们先打开编译过的blinky工程，首先看一下它的目录结构： 其中Blinky.c是类似于STM32中**main.c文件**，由用户创建。 打开system_msp432e401y,c观察，发现是和时钟频率有关的函数，很像STM32中的文件。 其他四个文件夹分别对应四种不同的开发环境，这里我们打开keil文件夹： 红框中的文件时打开keil编译后产生的，不用管。 .uvoptx结尾的文件是keil的工程，创建工程时建立。 .sct工程是Ti提供的链接文件，具体用途可以百度，但是我们发现Objects中也有一个sct文件，这是keil编译时自动生成的，上图目录中的sct文件其实没用（但是为了保证工程的正确性，最好还是使用Ti提供的sct文件）。 startup_msp432e401y_uvision.s就不用说了吧，经典的启动文件。 那么工程文件结构就看完了，是不是发现少了什么？对，各种奇怪的头文件不见了，然后还没有库函数文件。这些东西在哪呢？ 我们先打开工程文件，看一下keil的配置： 工程目录中可以看到之前在目录中看见的文件，这里多出来一个.a文件，经过查找，发现在simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4\\driverlib\\lib\\keil\\m4f中。 再查看头文件，发现在simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4 以及simplelink_msp432e4_sdk_4_20_00_12\\source\\third_party\\CMSIS\\Include 可以找到 那么到这里就可以知道了，主要的库文件都在E:\\TI\\simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4下面，接下来就可以开始创建工程了。 1，创建工程打开keil，点击新建工程，选择芯片为：MSP432E401Y。 新建完成后，我们将SDK安装目录\\source\\ti\\devices\\msp432e4打开，准备复制文件。 2，复制启动文件首先点开startup_system_files文件夹，将system_msp432e401y.c和keil文件夹中的startup_msp432e401y_uvision.s复制到工程目录下（我复制到了目录中的startup文件夹下） 3，复制连接文件点开linker_files\\keil文件夹，将MSP432E401Y.sct文件复制到工程目录。 4，复制头文件打开simplelink_msp432e4_sdk_4_20_00_12\\source文件夹，可以看到如下文件夹: ti：包含了Ti的各种文件，包括寄存器地址，基本驱动函数库 third_party:第三方的各种文件，包括ARM核的相关操作函数，fatfs文件系统,DSP等库 这里我们需要添加这两个文件夹的东西。 首先是ARM内核和编译器的文件: 打开simplelink_msp432e4_sdk_4_20_00_12\\source\\third_party\\CMSIS\\Include，根据我们使用的芯片(M4内核),以及编译器(gcc)选择添加头文件： cmsis_armcc.h cmsis_compiler.h cmsis_version.h core_cm4.h mpu_armv7.h 然后是Ti的库和启动函数文件： 打开simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4\\inc 将inc文件夹复制到工程目录。 其实不必全部复制，msp.h和msp432.h文件其实都是根据芯片选型定向到msp432e4xx.h。但是为了程序兼容性，还是一起复制。 5，复制driverlib文件点开driverlib文件夹，里面东西很多，都是基本的驱动库。 inc定义了基本的寄存器基地址，MASK等等 xxx.h/xxx.c则是基本驱动库 lib包含了已经编译好的上述基本驱动库 这里可以选择通过源码添加(直接添加源文件)，也可以添加已经编译好的文件(这样在调试时就不好看寄存器操作了)，为了方便就直接添加lib。 首先将这个文件夹的头文件复制到工程目录(不包括inc中的文件)，然后复制lib中相应的.a文件到工程目录。 6，设置keil点开keil的工程设置，选择C/C++选项，添加Include路径: 工程中的inc文件 driverlib中的inc文件 然后选择Link选项，添加sct文件。 之后选择Debug选项，将调试器改为CMSIS-DAP: 然后添加工程文件: 然后修改文件中头文件的路径，让引用指向本地工程文件夹中的文件。 .a文件需要设置为库文件： 7，编译，下载将点灯工程的代码复制到我们新建的工程中，编译下载，可以看见成功运行。 三，后记相比于CubeMX创建工程，这个创建是真的麻烦，比STM32不用Cube创建都要麻烦。所以还是听官方的话吧，乖乖直接复制空工程开发。 但是这样麻烦还是有回报的：Ti的库文件基本都在本地工程中，可以随意修改而不怕影响到其他工程。不然全部工程共用一个库，肯定会有一堆问题。 其实Ti提供的东西还挺多的，SDK包含了DSP，文件系统，GUI等一堆东西，还有例程，但是这些东西藏的好深，没什么说明。","categories":[{"name":"MSP学习笔记","slug":"MSP学习笔记","permalink":"https://lostacnet.top/categories/MSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MSP432E4","slug":"MSP432E4","permalink":"https://lostacnet.top/tags/MSP432E4/"}]},{"title":"Typora与hexo的优雅结合:公式和图片","slug":"Typora与hexo的优雅结合-公式和图片","date":"2023-02-21T07:12:17.000Z","updated":"2023-02-21T09:16:27.263Z","comments":true,"path":"post/22112/","link":"","permalink":"https://lostacnet.top/post/22112/","excerpt":"Typora与hexo的优雅结合:公式和图片Typora是一款十分好用的Markdown编写软件，用它写文章可以大大提升工作效率。但是当我想将它用于博客编写时出现了一些问题：1，图片无法正常显示。2，latex公式无法显示。在这里我给出我的解决方法。","text":"Typora与hexo的优雅结合:公式和图片Typora是一款十分好用的Markdown编写软件，用它写文章可以大大提升工作效率。但是当我想将它用于博客编写时出现了一些问题：1，图片无法正常显示。2，latex公式无法显示。在这里我给出我的解决方法。 一，解决公式的显示由于学习方向的特殊性，有时我需要插入一些简单的公式。但是hexo自带的渲染器不支持渲染公式，因此需要引入渲染引擎。 网上常见的方法是使用hexo-math插件支持KaTex和MathJax引擎进行渲染，但是它的用法是这样的： 123{% mathjax %}\\frac{1}{x^2-1}{% endmathjax %} 非常的不优雅:D 因此需要配合其他插件使用(变的麻烦起来了)。对于我这种公式轻度使用者来说麻烦。 但是在hexo-math插件的github界面的最下面推荐了另一款轻量的hexo-filter-mathjax hexo-filter-mathjax: A MathJax plugin developed by @stevenjoezhang, who is also a Hexo developer. It enables you to write LaTeX in-line within your post without using a tag {% %}. hexo-math uses tag plugin approach due to minor incompatibility between LaTeX and marked, the default markdown renderer of Hexo (via hexo-renderer-marked). 可以直接用$来引入公式，和Typora的用法一样，十分的Nice。 根据插件的说明，我们需要卸载一些东西一避免冲突： 删除所有的hexo math plugins–npm uninstall 停止主题的公式渲染–一般在主题设置里面 删除关于公式渲染的插件 Tips:我在使用npm uninstall时发现一直删不掉，最后是先把package.json的无关插件依赖删掉，然后删除node_modules文件夹，然后直接重新npm 使用以下命令安装: 12npm install hexo-filter-mathjax --save //使用--save是将这个插件添加到package.json的依赖列表 然后使用hexo clean清除之前渲染的界面。 打开_config.yml，在文件末尾添加设置选项: 1234567891011mathjax: tags: none # or 'ams' or 'all' single_dollars: true # enable single dollar signs as in-line math delimiters cjk_width: 0.9 # relative CJK char width normal_width: 0.6 # relative normal (monospace) width append_css: true # add CSS to pages rendered by MathJax every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter packages: # extra packages to load extension_options: {} # you can put your extension options here # see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail 之后在文章的Front-matter中添加mathjax: true即可开启当前文章的公式渲染。（如果开启了配置中的every_page即可在每一页默认开启） 使用演示： 123$$THD={\\sqrt{x}}$$ 当然，出现复杂的公式就会出现问题： 123456789101112131415$$A = \\begin{bmatrix}a_{11} &amp; a_{12} &amp; ... &amp; a_{1n}\\\\a_{21} &amp; a_{22} &amp; ... &amp; a_{2n}\\\\a_{31} &amp; a_{22} &amp; ... &amp; a_{3n}\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\a_{n1} &amp; a_{n2} &amp; ... &amp; a_{nn}\\\\\\end{bmatrix} , b = \\begin{bmatrix}b_{1} \\\\b_{2} \\\\b_{3} \\\\\\vdots \\\\b_{n} \\\\\\end{bmatrix}$$ 但我一般用不到，就不管了。 二，解决图片的显示在文章中使用Markdown语法插入图片要面对Markdown语法转换问题，以及图片储存问题，还要考虑如何与Typora优雅的兼容。 1，使用本地储存图片第一种方法将图片储存在本地，在推送时一起上传到托管服务器。 这种方式有很多的插件，包括更换Markdown渲染器，以及图片插入插件来支持markdown的图片插入语法。但是根据hexo的官方文档，在最新版本的默认渲染器hexo-renderer-marked中，已经支持了这种插入方式。 启用方式： 打开_config.yml修改post_asset_folder:true，打开此项后会在使用hexo new命令时，在文章目录下新建同名的文件夹用来储存图片。 在_config.yml中添加： 123marked: prependRoot: true postAsset: true 启用后在文章中使用！[](image.jpg)将会自动解析到上述文件夹中的图片。 （但是这样会导致在本地浏览md文件时无法显示图片） 上述设置之后，打开Typora软件，在文件-&gt;偏好设置-&gt;图片中如下设置: 这样，在Typora中插入图片时，就会自动将图片复制到上面说的同名文件夹了。 然后，当我们写完文章时，注意进行全局替换：将图片路径中的文件夹路径删掉，只保留图片文件名称，这样hexo才能正常渲染。 这时推送后，图片文件会随着网页一起推送到托管网站。 但是这样又不优雅了，本地浏览看不见图片，推送到网站占用有限的空间，如果遇到github这种网站，图片半天加载不出。这时，就要使用图床。 2，使用图床如果使用图床保存图片的话，那么上面的hexo就不用设置。同时，Typora也提供了非常方便的上传设置，可以使用picgo或者自定义脚本进行上传。 首先，我们需要一个稳定的图床：这里我选择了路过图床。但是路过图床关闭了上传图片的API同时picgo也没有支持它的插件，因此需要自己去抓包写一个上传的脚本。 好在，有人已经写出来了(基于python)：up2b。 使用方法（首先确认已经安装python）： 安装up2b包: 1pip isntall up2b 使用以下命令设置路过图床 1up2b -c 1 设置账号 1up2b -l username password 此时就可以使用up2b命令上传图片了。 打开typora，进行如下设置： 点击验证看是否正常运行。 此时，向typora插入图片，会自动上传到图床，并且将图片连接换成网络链接。 这样，就可以在网页上和本地同时看到图片了。 up2b还提供了压缩图片和添加水印的功能，可以到它的主页查看用法。如果无法使用请到github上提issue。 这下看起来好像就万无一失了，但是图床的使用有一个大问题：不稳定。可能哪天你的图片就全部不见了，因此需要图片先存到本地再上传到图床。 3，本地储存+图床这里就不需要设置hexo了，保持默认就行。我们对Typora进行如下设置： 这样在插入图片时，会自动复制到本地文件夹中，当写好文章需要推送时，只需要点击格式-&gt;图像-&gt;上传全部本地图像，这样Typora就会自动上传所有本地图像到图床并且替换图片地址。保证了本地备份和使用图床。 优雅，太优雅了。","categories":[{"name":"blog","slug":"blog","permalink":"https://lostacnet.top/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lostacnet.top/tags/hexo/"},{"name":"Typora","slug":"Typora","permalink":"https://lostacnet.top/tags/Typora/"}]},{"title":"第一篇博客","slug":"第一篇博客","date":"2023-02-18T17:11:55.000Z","updated":"2023-02-20T11:33:58.916Z","comments":true,"path":"post/21911/","link":"","permalink":"https://lostacnet.top/post/21911/","excerpt":"LO_StacNet的第一篇博客这里是LO_StacNet的第一篇博客，LO的学习之路将从这里开始.","text":"LO_StacNet的第一篇博客这里是LO_StacNet的第一篇博客，LO的学习之路将从这里开始. The Next In psot","categories":[{"name":"life","slug":"life","permalink":"https://lostacnet.top/categories/life/"}],"tags":[{"name":"begin","slug":"begin","permalink":"https://lostacnet.top/tags/begin/"}]}],"categories":[{"name":"技巧","slug":"技巧","permalink":"https://lostacnet.top/categories/%E6%8A%80%E5%B7%A7/"},{"name":"CMake学习笔记","slug":"CMake学习笔记","permalink":"https://lostacnet.top/categories/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"树莓派Pico学习笔记","slug":"树莓派Pico学习笔记","permalink":"https://lostacnet.top/categories/%E6%A0%91%E8%8E%93%E6%B4%BEPico%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"ESP32学习笔记","slug":"ESP32学习笔记","permalink":"https://lostacnet.top/categories/ESP32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"51单片机学习笔记","slug":"51单片机学习笔记","permalink":"https://lostacnet.top/categories/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"c语言学习笔记","slug":"c语言学习笔记","permalink":"https://lostacnet.top/categories/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"课程设计","slug":"课程设计","permalink":"https://lostacnet.top/categories/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"FreeRTOS学习笔记","slug":"FreeRTOS学习笔记","permalink":"https://lostacnet.top/categories/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"LVGL学习笔记","slug":"LVGL学习笔记","permalink":"https://lostacnet.top/categories/LVGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"信号处理","slug":"信号处理","permalink":"https://lostacnet.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"MSP学习笔记","slug":"MSP学习笔记","permalink":"https://lostacnet.top/categories/MSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"blog","slug":"blog","permalink":"https://lostacnet.top/categories/blog/"},{"name":"life","slug":"life","permalink":"https://lostacnet.top/categories/life/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://lostacnet.top/tags/%E7%BD%91%E7%BB%9C/"},{"name":"CMake","slug":"CMake","permalink":"https://lostacnet.top/tags/CMake/"},{"name":"c","slug":"c","permalink":"https://lostacnet.top/tags/c/"},{"name":"Clion","slug":"Clion","permalink":"https://lostacnet.top/tags/Clion/"},{"name":"rp2040","slug":"rp2040","permalink":"https://lostacnet.top/tags/rp2040/"},{"name":"OpenOCD","slug":"OpenOCD","permalink":"https://lostacnet.top/tags/OpenOCD/"},{"name":"vscode","slug":"vscode","permalink":"https://lostacnet.top/tags/vscode/"},{"name":"Arduino","slug":"Arduino","permalink":"https://lostacnet.top/tags/Arduino/"},{"name":"PlatformIO","slug":"PlatformIO","permalink":"https://lostacnet.top/tags/PlatformIO/"},{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"Cmake","slug":"Cmake","permalink":"https://lostacnet.top/tags/Cmake/"},{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/tags/ESP32/"},{"name":"FLASH","slug":"FLASH","permalink":"https://lostacnet.top/tags/FLASH/"},{"name":"Chrome","slug":"Chrome","permalink":"https://lostacnet.top/tags/Chrome/"},{"name":"浏览器插件","slug":"浏览器插件","permalink":"https://lostacnet.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"},{"name":"STC89C52","slug":"STC89C52","permalink":"https://lostacnet.top/tags/STC89C52/"},{"name":"堆栈","slug":"堆栈","permalink":"https://lostacnet.top/tags/%E5%A0%86%E6%A0%88/"},{"name":"寻址空间","slug":"寻址空间","permalink":"https://lostacnet.top/tags/%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4/"},{"name":"中断","slug":"中断","permalink":"https://lostacnet.top/tags/%E4%B8%AD%E6%96%AD/"},{"name":"matlab","slug":"matlab","permalink":"https://lostacnet.top/tags/matlab/"},{"name":"图像处理","slug":"图像处理","permalink":"https://lostacnet.top/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"lvgl","slug":"lvgl","permalink":"https://lostacnet.top/tags/lvgl/"},{"name":"SDL","slug":"SDL","permalink":"https://lostacnet.top/tags/SDL/"},{"name":"MQTT","slug":"MQTT","permalink":"https://lostacnet.top/tags/MQTT/"},{"name":"带通采样","slug":"带通采样","permalink":"https://lostacnet.top/tags/%E5%B8%A6%E9%80%9A%E9%87%87%E6%A0%B7/"},{"name":"奈奎斯特(香农)采样定理","slug":"奈奎斯特-香农-采样定理","permalink":"https://lostacnet.top/tags/%E5%A5%88%E5%A5%8E%E6%96%AF%E7%89%B9-%E9%A6%99%E5%86%9C-%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86/"},{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"https://lostacnet.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"加窗","slug":"加窗","permalink":"https://lostacnet.top/tags/%E5%8A%A0%E7%AA%97/"},{"name":"MSP432E4","slug":"MSP432E4","permalink":"https://lostacnet.top/tags/MSP432E4/"},{"name":"hexo","slug":"hexo","permalink":"https://lostacnet.top/tags/hexo/"},{"name":"Typora","slug":"Typora","permalink":"https://lostacnet.top/tags/Typora/"},{"name":"begin","slug":"begin","permalink":"https://lostacnet.top/tags/begin/"}]}