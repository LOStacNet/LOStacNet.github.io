{"meta":{"title":"LO_StacNet的火柴盒","subtitle":"","description":"LO_StacNet的个人博客","author":"LO_StacNet","url":"https://lostacnet.top","root":"/"},"pages":[{"title":"About","date":"2023-02-19T07:34:05.646Z","updated":"2023-02-19T07:34:05.646Z","comments":false,"path":"about/index.html","permalink":"https://lostacnet.top/about/","excerpt":"","text":"Hello World!这是学习代码最开始的一句，也可以是学习的代码的最终。"},{"title":"Categories","date":"2023-02-18T16:20:28.686Z","updated":"2023-02-18T16:20:28.686Z","comments":false,"path":"categories/index.html","permalink":"https://lostacnet.top/categories/","excerpt":"","text":""},{"title":"Links","date":"2023-02-19T07:32:46.372Z","updated":"2023-02-19T07:32:46.372Z","comments":true,"path":"links/index.html","permalink":"https://lostacnet.top/links/","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-18T16:21:37.660Z","updated":"2023-02-18T16:21:37.660Z","comments":false,"path":"repository/index.html","permalink":"https://lostacnet.top/repository/","excerpt":"","text":""},{"title":"Tags","date":"2023-02-18T16:22:13.563Z","updated":"2023-02-18T16:22:13.563Z","comments":false,"path":"tags/index.html","permalink":"https://lostacnet.top/tags/","excerpt":"","text":""}],"posts":[{"title":"ESP-IDF学习笔记-UART的使用","slug":"ESP-IDF学习笔记-UART的使用","date":"2023-04-24T14:43:27.000Z","updated":"2023-04-24T17:36:59.431Z","comments":true,"path":"post/42443/","link":"","permalink":"https://lostacnet.top/post/42443/","excerpt":"ESP-IDF学习笔记-UART的使用ESP32中串口的使用与STM32中大有不同。在ESP32中使用串口，需要配置串口，设置引脚，安装驱动之后才能使用。接收和发送数据也不是直接向寄存器写数据，而是先存到FIFO中，交由ESP32自动发送。其中断的使用更是结合了FreeRTOS的特性进行的。","text":"ESP-IDF学习笔记-UART的使用ESP32中串口的使用与STM32中大有不同。在ESP32中使用串口，需要配置串口，设置引脚，安装驱动之后才能使用。接收和发送数据也不是直接向寄存器写数据，而是先存到FIFO中，交由ESP32自动发送。其中断的使用更是结合了FreeRTOS的特性进行的。 先摆上官方文档。 本文参考于这篇文章 一，串口的配置步骤一个串口的典型使用步骤如下: 使用uart_param_config()设置UART参数 使用art_set_pin()分配UART引脚 使用uart_driver_install()安装UART驱动 使用uart_read_bytes()/uart_write_bytes()收发数据 (可选)新建task读取事件队列处理中断事件 (可选)删除驱动释放资源 其中，1、2、3步可以调换顺序。 二，配置的具体步骤同STM32HAL库的句柄一样，ESP32中使用一个uart_port_t类型的UART_NUM_x变量识别不同的UART控制器，在调用函数时需指明。 其中UART_NUM_MAX表示该芯片最大的uart控制器数，上面的x最大为UART_NUM_MAX-1。 ESP32中默认使用UART_NUM_0作为log库的输出。 UART参数的配置UART参数的配置主要用两种方式，一种是使用uart_param_config+结构体一次性配置；另一种是使用分离函数进行配置。、 单步配置（结构体）使用的函数原型： 1esp_err_t uart_param_config(uart_port_t uart_num, const uart_config_t *uart_config) 参数： uart_num使用的UART编号 uart_config配置的结构体 返回： ESP_OK Success ESP_FALL Parameter error uart_config_t结构体成员： 成员 类型 作用 可用参数 baud_rate int 波特率 宏定义UART_BITRATE_MAX为支持的最大波特率 data_bits uart_word_length_t 数据位长度 UART_DATA_X_BITS(X=5~8 )或UART_DATA_BITS_MAX parity uart_parity_t 校验位 UART_PARITY_X(X=DISABLE,EVEN,ODD) stop_bits uart_stop_bits_t 停止位 UART_STOP_BITS_X(X=1,1_5,2,MAX) flow_ctrl uart_hw_flowcontrol_t 硬件流控制 UART_HW_FLOWCTRL_X(X=DISABLE,RTS,CTS,CTS_RTS,MAX) rx_flow_ctrl_thresh uint8_t 硬件流控制阈值 — source_clk uart_sclk_t 时钟源选择 UART_SCLK_X(X=APB,RTC,XTAL,DEFAULT(APB)) 如果不使用硬件流控制，可以使用 uart_set_rts() 和 uart_set_dtr()软件流控制。 使用例： 123456789101112#include \"driver/uart.h\"#define EX_UART_NUM UART_NUM_0uart_config_t uart_config = { .baud_rate = 115200, .data_bits = UART_DATA_8_BITS, .parity = UART_PARITY_DISABLE, .stop_bits = UART_STOP_BITS_1, .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, .source_clk = UART_SCLK_DEFAULT, };uart_param_config(EX_UART_NUM, &amp;uart_config); 多步配置多步配置的函数表如下： 欲配置的参数 函数 波特率(Baud rate) uart_set_baudrate() 传输数据位长(Number of transmitted bits) uart_set_word_length() selected out of uart_word_length_t 奇偶校验(parity control) uart_set_parity() selected out of uart_parity_t 停止位数(Number of stop bits) uart_set_stop_bits() selected out of uart_stop_bits_t 硬件流控方式(Hardware flow control mode) uart_set_hw_flow_ctrl() selected out of uart_hw_flowcontrol_t 通信方式(Communication mode) uart_set_mode() selected out of uart_mode_t 同时，上面的每个函数都有一个_get_对应对象来检查当前设置的值。例如，要检查当前波特率值，调用uart_get_baudrate()。 分配引脚使用的函数原型 1esp_err_t uart_set_pin(uart_port_t uart_num, int tx_io_num, int rx_io_num, int rts_io_num, int cts_io_num) 参数： uart_num使用的串口编号 tx_io_numTX引脚 rx_io_numRX引脚 rts_io_numRTS引脚 cts_io_numCTS引脚 返回： ESP_OK Success ESP_FALL Parameter error 对于后四个参数，可以使用宏UART_PIN_NO_CHANGE保留已经配置的引脚或者默认引脚。 如果设置的GPIO有该功能的IOMUX（复用），则信号会直接接到该引脚而不通过GPIO矩阵，这样能够支持更高的速率。例如。ESP32S3中IO43是默认的U0TXD，IO44是默认的U0RXD；IO17–U1TXD，IO18–U1RXD。 ESP32提供了一些宏用来定义这些能直连的引脚，参考官方文档，或者见本章高级用法篇。 内部信号能够被输出到多个GPIO，但只有一个GPIO能输入。 经实际测试，ESP32S3的UART好像不能换引脚。 使用例: 123#include \"driver/uart.h\"uart_set_pin(UART_NUM_0,UART_PIN_NO_CHANGE,UART_PIN_NO_CHANGE,UART_PIN_NO_CHANGE,UART_PIN_NO_CHANGE); 安装驱动使用的函数原型： 1esp_err_t uart_driver_install(uart_port_t uart_num, int rx_buffer_size, int tx_buffer_size, int queue_size, QueueHandle_t *uart_queue, int intr_alloc_flags); 参数： uart_num使用的串口编号 rx_buffer_size接收缓冲区大小 tx_buffer_size发送缓冲区大小 queue_size事件队列大小 uart_queue事件队列句柄，如果成功，这里会有一个新的事件队列。如果设为NULL将不使用 intr_alloc_flags用于分配中断的标志。传入一个或多个ESP_INTR_FLAG_*(详见esp_intr_alloc.h)，不能使用ESP_INTR_FLAG_IRAM(在meunconfig中设置) 返回： ESP_OK Success ESP_FALL Parameter error 安装UART驱动程序，同时，UART ISR处理器将被附加到运行该函数的同一个CPU核心上。Rx_buffer_size应该大于UART_FIFO_LEN。Tx_buffer_size应该是**0或者大于UART_FIFO_LEN**。 UART_FIFO_LEN是一个宏定义，定义硬件FIFO的大小 如果发送缓存区为0，则使用uart_write_bytes()时会阻塞发送。 例子： 1uart_driver_install(UART_NUM_0,1024,512,0,NULL,0); 收发数据发数据使用的函数原型： 1int uart_write_bytes(uart_port_t uart_num, const void *src, size_t size); 参数： uart_num使用的串口编号 src数据地址 size数据长度 返回： (-1) Parameter error OTHERS (&gt;=0) The number of bytes pushed to the TX FIFO 如果缓冲区为0，该函数会阻塞直到所有数据被发送或者所有数据被加入FIFO。 缓冲区中的数据会被UART ISR逐步转移到FIFO。（有点像32的Transmit_IT）。 函数uart_write_bytes_with_break()与其功能类似，但会在结束时添加串行中断信号。“串行中断信号”意味着 Tx 线保持低电平的时间长于一个数据帧。 uart_tx_chars()也能将数据写入Tx FIFO，但不会等待可用空间，而是立即放入硬件FIFO。 uart_wait_tx_done()用于监听发送缓冲区，在缓冲区为空时返回。 123// Wait for packet to be sentconst uart_port_t uart_num = UART_NUM_2;ESP_ERROR_CHECK(uart_wait_tx_done(uart_num, 100)); // wait timeout is 100 RTOS ticks (TickType_t) 接数据使用的函数原型： 1int uart_read_bytes(uart_port_t uart_num, void *buf, uint32_t length, TickType_t ticks_to_wait) ticks_to_wait是超时时间，值是RTOS的ticks。 使用该函数前应使用uart_get_buffered_data_len()获得缓冲区数据的长度。比如： 123456// Read data from UART.const uart_port_t uart_num = UART_NUM_2;uint8_t data[128];int length = 0;ESP_ERROR_CHECK(uart_get_buffered_data_len(uart_num, (size_t*)&amp;length));length = uart_read_bytes(uart_num, data, length, 100); 清除缓冲区： 1esp_err_t uart_flush(uart_port_t uart_num); 清除RX缓冲区的内容。 1esp_err_t uart_flush_input(uart_port_t uart_num); 清除输入缓存区内容（如果想等待发送完成，请使用uart_wait_tx_done）。 使用中断这里提到的中断与一般的中断不同，这里应该叫UART事件。中断触发后读取的中断源被当做事件添加到队列中，使用FreeRTOS的一个线程进行读取，处理，得到像中断的效果。 使用事件处理需要在安装驱动时开启事件队列。 1234#include \"driver/uart.h\"static QueueHandle_t uart0_queue;uart_driver_install(UART_NUM_0,1024,512,20,&amp;uart0_queue,0);//队列长度为20 UART 默认的事件处理 没有使用esp_event.h中的事件循环(EventLoop)。而是使用队列传输事件对象（一个uart_event_t类型的结构体）这个结构体包含了事件类型和UART_DATA事件携带的数据。 123456789/** * @brief Event structure used in UART event queue */typedef struct { uart_event_type_t type; /*!&lt; UART 事件类型 */ size_t size; /*!&lt; UART 数据长度(仅UART_DATA 事件)*/ bool timeout_flag; /*!&lt; UART 超时标志(仅UART_DATA 事件)*/ /*!&lt; If the event is caused by FIFO-full interrupt, then there will be no event with the timeout flag before the next byte coming.*/} uart_event_t; 其中，uart_event_type_t包含以下事件： 1234567891011121314151617/** * @brief UART event types used in the ring buffer */typedef enum { UART_DATA, /*!&lt; UART data event UART数据事件*/ UART_BREAK, /*!&lt; UART break event UART中断事件*/ UART_BUFFER_FULL, /*!&lt; UART RX buffer full event UART RX缓冲区满事件*/ UART_FIFO_OVF, /*!&lt; UART FIFO overflow event UART FIFO溢出事件*/ UART_FRAME_ERR, /*!&lt; UART RX frame error event UART RX帧错误事件*/ UART_PARITY_ERR, /*!&lt; UART RX parity event UART奇偶检查错误*/ UART_DATA_BREAK, /*!&lt; UART TX data and break event UART TX数据和中断事件*/ UART_PATTERN_DET, /*!&lt; UART pattern detected UART 输入样式检测事件*/#if SOC_UART_SUPPORT_WAKEUP_INT UART_WAKEUP, /*!&lt; UART wakeup event */#endif UART_EVENT_MAX, /*!&lt; UART event max index*/} uart_event_type_t; 其中，最后一个事件UART_PATTERN_DET是使用uart_enable_pattern_det_baud_intr()启用pattern detect后的触发事件，用于解析特定格式的数据如AT+CGMI。 安装完驱动后，当有事件发生时，会自动向队列中填充信息，一般使用一个任务来进行及时处理。 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"driver/uart.h\"static QueueHandle_t uart0_queue;...static void uart_event_task(void *pv){ uart_event_t event; uint8_t d; while(1) { if(xQueueReceive(uart0_queue, (void * )&amp;event, (TickType_t)portMAX_DELAY)) { ESP_LOGI(TAG,\"A event in\"); switch (event.type) { case UART_DATA: uart_read_bytes(UART_NUM_0,&amp;d,1,(TickType_t)portMAX_DELAY); uart_write_bytes(UART_NUM_0, &amp;d, 1); break; case UART_BREAK: break; case ...: break; ... default: //ESP_LOGI(TAG, \"uart event type: %d\", event.type); break; } } }}...void app_main(void){ ... uart_driver_install(UART_NUM_0,1024,512,20,&amp;uart0_queue,0); ... xTaskCreate(uart_event_task, \"uart_event_task\", 2048, NULL, 12, NULL);} 删除驱动1esp_err_t uart_driver_delete(uart_port_t uart_num); 使用该函数释放资源。 三，高级用法其他模式UART 控制器支持多种通信模式，使用函数 uart_set_mode()可以选择模式。选择特定模式后，UART 驱动程序将处理已连接 UART 设备的相应行为。 1esp_err_t uart_set_mode(uart_port_t uart_num, uart_mode_t mode); 参数： mode使用的模式 该函数必须在uart_driver_install()之后使用。 支持的参数如下： 参数 模式 UART_MODE_UART 普通UART UART_MODE_RS485_HALF_DUPLEX half duplex RS485 UART mode control by RTS pin UART_MODE_IRDA 类似于红外协议的模式 UART_MODE_RS485_COLLISION_DETECT RS485 collision detection UART mode (used for test purposes) UART_MODE_RS485_APP_CTRL application control RS485 UART mode (used for test purposes) 具体使用参考官方文档 pattern_detect在检测到重复接收/发送同一字符的“模式”时触发中断。例如，模式检测可用于检测命令字符串末尾是否存在特定数量的相同字符（“模式”）。 配置并启用此中断：调用 uart_enable_pattern_det_baud_intr() 禁用中断：调用 uart_disable_pattern_det_intr() 用法参见peripherals/uart/uart_events 自定义UART中断如果不想使用默认的 UART 中断（如上文的 UART 事件 Queue 等高级API）或者自己另有别的绝妙之用，可以注册自己的UART中断。 使用 uart_isr_register() 注册中断 使用 uart_isr_free() 释放注册的中断 写的中断 ISR 程序需要尽可能简短，不要忘了在处理中断前后调用uart_clear_intr_status()清除中断标志。 一些宏12345678910111213141516171819202122232425UART_GPIO43_DIRECT_CHANNELUART_NUM_0_TXD_DIRECT_GPIO_NUMUART_GPIO44_DIRECT_CHANNELUART_NUM_0_RXD_DIRECT_GPIO_NUMUART_GPIO16_DIRECT_CHANNELUART_NUM_0_CTS_DIRECT_GPIO_NUMUART_GPIO15_DIRECT_CHANNELUART_NUM_0_RTS_DIRECT_GPIO_NUMUART_TXD_GPIO43_DIRECT_CHANNELUART_RXD_GPIO44_DIRECT_CHANNELUART_CTS_GPIO16_DIRECT_CHANNELUART_RTS_GPIO15_DIRECT_CHANNELUART_GPIO17_DIRECT_CHANNELUART_NUM_1_TXD_DIRECT_GPIO_NUMUART_GPIO18_DIRECT_CHANNELUART_NUM_1_RXD_DIRECT_GPIO_NUMUART_GPIO20_DIRECT_CHANNELUART_NUM_1_CTS_DIRECT_GPIO_NUMUART_GPIO19_DIRECT_CHANNELUART_NUM_1_RTS_DIRECT_GPIO_NUMUART_TXD_GPIO17_DIRECT_CHANNELUART_RXD_GPIO18_DIRECT_CHANNELUART_CTS_GPIO20_DIRECT_CHANNELUART_RTS_GPIO19_DIRECT_CHANNEL","categories":[{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/categories/ESP32/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"}]},{"title":"ESP-IDF学习笔记-工程结构","slug":"ESP-IDF学习笔记-工程结构","date":"2023-04-23T08:46:54.000Z","updated":"2023-04-23T10:56:46.338Z","comments":true,"path":"post/42346/","link":"","permalink":"https://lostacnet.top/post/42346/","excerpt":"ESP-IDF学习笔记-工程结构学习ESP-IDF的使用，首先得要学习一个IDF工程的结构。ESP-IDF的工程是以Cmake组织的，并使用了Ninja作为构建工具，这里只简单给出如何使用这套系统。","text":"ESP-IDF学习笔记-工程结构学习ESP-IDF的使用，首先得要学习一个IDF工程的结构。ESP-IDF的工程是以Cmake组织的，并使用了Ninja作为构建工具，这里只简单给出如何使用这套系统。 官方文档 参考于 一，目录结构一个IDF工程一般有以下结构的目录： 123456789101112131415- myProject/ - CMakeLists.txt - sdkconfig - components/ - component1/ - CMakeLists.txt - Kconfig - src1.c - component2/ - CMakeLists.txt - Kconfig - src1.c - include/ - component2.h - main/ - CMakeLists.txt - src1.c - src2.c - build/ 顶层目录的CMakeList.txt：这是整个项目的CMake文件，其中引入了/tools/cmake/project.cmake用来构建其他部分。同时设置了工程名。 sdkconfig：项目配置文件，使用idf.py menuconfig配置在IDE中对应设置按钮出现的菜单。在菜单中的配置以宏定义的方式出现在源码中。 main：特殊的目录，包含项目本身的源码，被认为是mian组件。 build：编译结果 components：（可选）组件，即各种库。 项目CMakeLists该文件配置整个项目，通常十分小。最小情况如下: 123cmake_minimum_required(VERSION 3.16)include($ENV{IDF_PATH}/tools/cmake/project.cmake)project(myProject) cmake_minimum_required(VERSION 3.16) 必须放在 CMakeLists.txt 文件的第一行，它会告诉 CMake 构建该项目所需要的最小版本号。ESP-IDF 支持 CMake 3.16 或更高的版本。 include($ENV{IDF_PATH}/tools/cmake/project.cmake) 会导入 CMake 的其余功能来完成配置项目、检索组件等任务。 project(myProject) 会创建项目本身，并指定项目名称。该名称会作为最终输出的二进制文件的名字，即 myProject.elf 和 myProject.bin。每个 CMakeLists 文件只能定义一个项目。 同时该文件可以配置一些全局变量用来修改默认值自定义构建系统： COMPONENT_DIRS：组件的搜索目录，默认为 IDF_PATH/components、 PROJECT_DIR/components、和 EXTRA_COMPONENT_DIRS。如果您不想在这些位置搜索组件，请覆盖此变量。 EXTRA_COMPONENT_DIRS：用于搜索组件的其它可选目录列表。路径可以是相对于项目目录的相对路径，也可以是绝对路径。 COMPONENTS：要构建进项目中的组件名称列表，默认为 COMPONENT_DIRS 目录下检索到的所有组件。使用此变量可以“精简”项目以缩短构建时间。请注意，如果一个组件通过 COMPONENT_REQUIRES 指定了它依赖的另一个组件，则会自动将其添加到 COMPONENTS 中，所以 COMPONENTS 列表可能会非常短。 使用 cmake 中的 set 命令 来设置这些变量，如 set(VARIABLE \"VALUE\")。请注意，set() 命令需放在include(...)之前，cmake_minimum(...) 之后。 组件CMakeList.txt组件是 COMPONENT_DIRS 列表中的任何包含CMakeList.txt目录。IDF按以下顺序搜索组件，如果有多个同名组件，以最后一个为准。 搜索 ESP-IDF 内部组件（$ENV{IDF_PATH}/components） 搜索 EXTRA_COMPONENT_DIRS 中的组件 搜索项目组件（$ENV{PROJECT_DIR}/components） 组件最小CMakeList如下： 1234idf_component_register( SRCS \"foo.c\" \"cplus.cpp\" INCLUDE_DIRS \"include\") SRCS：源文件列表 INCLUDE_DIRS：组件的include目录，会被添加到头文件搜索目录中 除此之外，还有一些非必须的变量： REQUIRES：申明组件的共用依赖，一般就是头文件中include的其他组件 PRIV_REQUIRES：申明组件的私有依赖，一般是源文件中include的其他组件 …. 其中main也是一个组件，但其默认依赖所有组件。 二，配置菜单IDF中将组件的配置以宏定义的形式移出代码，放进idf的meunconfig中进行配置。在项目的任意位置，都可以使用#include \"sdkconfig.h“进行访问。 配置文件种类 文件名 位置 作用 Kconfig 组件(手动创建) 在menuconfig中的菜单中创建Component Configuration子菜单 Kconfig.projbuild 组件(手动创建) 在menuconfig中创建顶层菜单 sdkconfig 工程(自动生成) 保持配置 sdkconfig.h 工程编译文件(自动生成) 配置的访问接口 sdkconfig.default 工程(手动创建) 配置的默认值 sdkconfig.old 工程(自动生成) 备份 sdkconfig.ci 用于单元测试 sdkconfig.rename 用于重命名弃用的配置名，方便旧配置文件快速用于新配置，兼容 sdkconfig.default可为不同设备添加默认配置,如:sdkconfig.default.esp32s3 创建菜单官方文档 创建菜单在Kconfig或者Kconfig.projbuild中按照特定语法进行创建。 具体语法可以参考这篇文章 这里直接给出该文章的中的例子： 123456789101112131415161718192021222324252627282930313233343536menu \"My menu\" # bool 是勾选框 config MY_TEST_BOOL bool \"bool_test\" help This is a bool test. # int 是输入整数 config MY_TEST_INT int \"int_test\" default 12345 help This is an int test. # hex 是输入16进制数 config MY_TEST_HEX hex \"hex_test\" default 0x7FFF help This is a hex test. # tristate 在 ESP-IDF构建系统中会被当做 bool 处理 config MY_TEST_TRISTATE tristate \"tristate_test\" help This is a tristate test. # string 表示一个字符串 config MY_TEST_STRING string \"string_test\" help This is a string test.endmenu 生成的宏定义是： 1234#define CONFIG_MY_TEST_BOOL 1#define CONFIG_MY_TEST_INT 12345#define CONFIG_MY_TEST_HEX 0x7FFF#define CONFIG_MY_TEST_STRING \"ESP32 YYDS\" 宏定义的结构是:CONFIG_+配置名 创建选项菜单: 12345678910111213141516171819202122232425menu \"My Menu\" choice MY_TEST_CHOICE prompt \"My Test Choice\" default MY_CHOICE_OPTION1 help This is a help. config MY_CHOICE_OPTION1 bool \"option1\" help help for option1 config MY_CHOICE_OPTION2 bool \"option2\" help help for option2 config MY_CHOICE_OPTION3 bool \"option3\" help help for option3 endchoiceendmenu 生成的宏定义： 1#define CONFIG_MY_CHOICE_OPTION_1","categories":[{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/categories/ESP32/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"}]},{"title":"ESP-IDF学习笔记-错误处理","slug":"ESP-IDF学习笔记-错误处理","date":"2023-04-20T17:18:45.000Z","updated":"2023-04-23T10:58:11.447Z","comments":true,"path":"post/42118/","link":"","permalink":"https://lostacnet.top/post/42118/","excerpt":"ESP-IDF学习笔记-错误处理同STM32HAL库的各种错误状态码一样，ESP-IDF中也有不同的错误码以及相应的错误处理方法，这给出基本的使用。","text":"ESP-IDF学习笔记-错误处理同STM32HAL库的各种错误状态码一样，ESP-IDF中也有不同的错误码以及相应的错误处理方法，这给出基本的使用。 首先放上官方文档 一，错误的分类ESP32中主要有两类错误： 可恢复错误 可用错误状态码表示，使用 throw 关键字抛出的 C++ 异常。 不可恢复（严重）错误 断言失败：（使用 assert 宏或者其它类似方法，可参考 Assertions）或者直接调用 abort() 函数造成的错误 CPU 异常：访问受保护的内存区域、非法指令等 系统级检查：看门狗超时、缓存访问错误、堆栈溢出、堆栈粉碎、堆栈损坏等 二，错误码与错误消息在ESP-IDF中，错误码的类型是esp_err_t，本质是带符号整型。其中表示没有错误的定义是：ESP_OK具体定义为0。 对于一个具体的错误，错误码常常以ESP_ERR_XXX形式呈现，常见的错误码在esp_err.h中已经定义好了，各个组件也可以自定义。 得到整型的错误码可以使用esp_err_to_name()或者esp_err_to_name_r()函数(esp_err.h)将其转换为字符串(返回值是const char *)，这两个函数的区别主要在于当没有匹配的错误时，是否用 标准 POSIX 错误代码 进行解释。 三，常用宏 ESP_ERROR_CHECK 该宏定义在esp_err.h中。功能与assert相似，但是会检测错误值并打印错误信息，最后调用abort()。 通常错误信息如下: 1234567ESP_ERROR_CHECK failed: esp_err_t 0x107 (ESP_ERR_TIMEOUT) at 0x400d1fdffile: \"/Users/user/esp/example/main/main.c\" line 20func: app_mainexpression: sdmmc_card_init(host, &amp;card)Backtrace: 0x40086e7c:0x3ffb4ff0 0x40087328:0x3ffb5010 0x400d1fdf:0x3ffb5030 0x400d0816:0x3ffb5050 ESP_ERROR_CHECK_WITHOUT_ABORT 该宏定义在esp_err.h中。功能与ESP_ERROR_CHECK一样，但不会调用abort()。 以下宏定义在esp_check.h ESP_RETURN_ON_ERROR 宏 ESP_RETURN_ON_ERROR 用于错误码检查, 如果错误码不等于 ESP_OK, 该宏会打印错误信息，并使原函数立刻返回。 ESP_GOTO_ON_ERROR 宏 ESP_GOTO_ON_ERROR 用于错误码检查, 如果错误码不等于 ESP_OK, 该宏会打印错误信息，将局部变量 ret 赋值为该错误码, 并使原函数跳转至给定的 goto_tag. ESP_RETURN_ON_FALSE 宏 ESP_RETURN_ON_FALSE 用于条件检查, 如果给定条件不等于 true, 该宏会打印错误信息，并使原函数立刻返回，返回值为给定的 err_code. ESP_GOTO_ON_FALSE 宏 ESP_GOTO_ON_FALSE 用于条件检查, 如果给定条件不等于 true, 该宏会打印错误信息，将局部变量 ret 赋值为给定的 err_code, 并使原函数跳转至给定的 goto_tag. ESP_RETURN_xx 和 ESP_GOTO_xx 宏不可以在中断服务程序里被调用。 使用例: 1234567891011121314151617static const char* TAG = \"Test\";esp_err_t test_func(void){ esp_err_t ret = ESP_OK; ESP_ERROR_CHECK(x); // err message printed if `x` is not `ESP_OK`, and then `abort()`. ESP_ERROR_CHECK_WITHOUT_ABORT(x); // err message printed if `x` is not `ESP_OK`, without `abort()`. ESP_RETURN_ON_ERROR(x, TAG, \"fail reason 1\"); // err message printed if `x` is not `ESP_OK`, and then function returns with code `x`. ESP_GOTO_ON_ERROR(x, err, TAG, \"fail reason 2\"); // err message printed if `x` is not `ESP_OK`, `ret` is set to `x`, and then jumps to `err`. ESP_RETURN_ON_FALSE(a, err_code, TAG, \"fail reason 3\"); // err message printed if `a` is not `true`, and then function returns with code `err_code`. ESP_GOTO_ON_FALSE(a, err_code, err, TAG, \"fail reason 4\"); // err message printed if `a` is not `true`, `ret` is set to `err_code`, and then jumps to `err`.err: // clean up return ret;} 如果 Kconfig 中的 CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT 选项被打开, CHECK 宏将不会打印错误信息，其他功能不变。 四，错误处理根据错误码恢复用变量储存错误码，在代码中判断错误码类型，根据类型不同尝试恢复。或者使用上面用到的CHECK宏。 转化为不可恢复错误使用ESP_ERROR_CHECK处理返回值。 1ESP_ERROR_CHECK(spi_bus_initialize(host, bus_config, dma_chan)); 五，严重错误以下情况为不可恢复的严重错误，程序会中断重启。 CPU 异常：非法指令，加载/存储时的内存对齐错误，加载/存储时的访问权限错误，双重异常。 系统级检查错误： 中断看门狗 超时 任务看门狗 超时（只有开启 CONFIG_ESP_TASK_WDT_PANIC 后才会触发严重错误） 高速缓存访问错误 内存保护故障 掉电检测事件 堆栈溢出 堆栈粉碎保护检查 堆完整性检查 未定义行为清理器 (UBSAN) 检查 使用 assert、configASSERT 等类似的宏断言失败。 官方文档给出了参考解决，这里先待补，等以后接触后继续。","categories":[{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/categories/ESP32/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"}]},{"title":"ESP-IDF学习笔记-调试等级打印","slug":"ESP-IDF学习笔记-调试等级打印","date":"2023-04-20T14:56:23.000Z","updated":"2023-04-23T10:57:59.218Z","comments":true,"path":"post/42056/","link":"","permalink":"https://lostacnet.top/post/42056/","excerpt":"ESP-IDF学习笔记-调试等级打印ESP32IDF中提供了一个LOG库，根据不同调试等级打印信息，这里记录一下简单用法。","text":"ESP-IDF学习笔记-调试等级打印ESP32IDF中提供了一个LOG库，根据不同调试等级打印信息，这里记录一下简单用法。 官方的LOG库文档 官方给的库用法很多还有一些高级用法，但是我们只需要使用简单的就行了。 一，调试级别ESP32LOG库定义的如下调试级别(按等级高低从低到高排列)： ESP_LOGE - error (lowest) ESP_LOGW - warning ESP_LOGI - info ESP_LOGD - debug ESP_LOGV - verbose (highest) 对应的在IDF中的调试级别设置如图: 对应的设置选项为： CONFIG_LOG_DEFAULT_LEVEL:默认调试级别 CONFIG_LOG_MAXIMUM_LEVEL:最高调试级别 高于默认调试级别的调试信息不会打印。 CONFIG_LOG_MAXIMUM_LEVEL用来设置esp_log_level_set() 可以设置的最高级别的调试等级(代码中动态调整调试等级)。 剩下一个设置项用来设置调试时间戳的来源，可以设置为来自于FreeRTos的时基，从系统重启后到现在的ms；或者为实际时间，来自RTC外设（可通过SNTP在重启置0后校准）。 二，API函数常用函数如下： 123456789101112131415//打印调试信息ESP_LOGE();//error (lowest)ESP_LOGW();//warningESP_LOGI();//infoESP_LOGD();//debugESP_LOGV();//verbose (highest)//设置调试等级void esp_log_level_set(const char *tag, esp_log_level_t level);//设置TAG的调试等级esp_log_level_t esp_log_level_get(const char *tag);//获得TAG的调试等级 使用方法： 定义TAG 123static const char* TAG = \"MyModule\";//others#define TAG \"MyModule\" 调用打印函数 1ESP_LOGW(TAG, \"Baud rate error %.1f%%. Requested: %d baud, actual: %d baud\", error * 100, baud_req, baud_real); 通过在esp_log.h前定义LOG_LOCAL_LEVEL来重新设置默认调试等级: 12#define LOG_LOCAL_LEVEL ESP_LOG_VERBOSE#include \"esp_log.h\" 对于组件(component)可以在CMakeLists中设置来重设: 1target_compile_definitions(${COMPONENT_LIB} PUBLIC \"-DLOG_LOCAL_LEVEL=ESP_LOG_VERBOSE\") 可以通过``在运行时设置各个TAG的调试等级： 123esp_log_level_set(\"*\", ESP_LOG_ERROR); // set all components to ERROR levelesp_log_level_set(\"wifi\", ESP_LOG_WARN); // enable WARN logs from WiFi stackesp_log_level_set(\"dhcpc\", ESP_LOG_INFO); // enable INFO logs from DHCP client 三，高级用法输出端口默认情况下，日志输出到串口，使用类vsprintf函数。 通过调用以下函数，可以将输出定向到JATG： 1esp_log_set_vprintf(esp_apptrace_vprintf); 如果想重新设置回UART： 1esp_log_set_vprintf(vprintf); 其他输出API1ESP_EARLY_LOGx() 在系统早期启动过程使用：在堆分配前和系统调用前使用 1ESP_DRAM_LOGx() 在中断被关闭或者Flash缓存无法访问时使用，由于对系统性能考虑，应尽可能少使用。","categories":[{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/categories/ESP32/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"}]},{"title":"对带通采样定理的理解","slug":"对带通采样定理的理解","date":"2023-04-01T08:29:57.000Z","updated":"2023-04-01T10:15:34.895Z","comments":true,"path":"post/4129/","link":"","permalink":"https://lostacnet.top/post/4129/","excerpt":"对带通采样定理的理解奈奎斯特采样定理要求采样频率必须大于信号频率的2倍，不然会发生频谱混叠。但是对于高频信号，ADC难以达到所需要的采样率。实际上，我们进行频谱分析时，只需要让我们需要信号的频率不发生频谱混叠就行了，由此就出现了带通采样定理。","text":"对带通采样定理的理解奈奎斯特采样定理要求采样频率必须大于信号频率的2倍，不然会发生频谱混叠。但是对于高频信号，ADC难以达到所需要的采样率。实际上，我们进行频谱分析时，只需要让我们需要信号的频率不发生频谱混叠就行了，由此就出现了带通采样定理。 本文参考于带通采样定理及其公式推导 一，奈奎斯特采样定理和带通采样定理奈奎斯特采样定理奈奎斯特采样定理又称低通采样定理。其“低通”的含义是从0频率到信号中角频率最大的分量都能复原，不发生频谱混叠。这样就要求以0为中心2*w宽度的频段都必须没有重叠： 这就是所谓低通。 但这样会导致两个中心频率相距至少要2*w以上，即采样频率为原信号的两倍，对采样率要求极为苛刻。 更多信息可见我的另外一篇博客:对Nyquist-Shannon采样定理的直观理解 带通采样定理很多时候，我们的关注的信号频率主要集中于高频段，对低频信号不关心。如图，我们只关心高频很窄的一段信号： 这就是所谓带通。 二，带通采样定理理解什么是带通后，我们对其进行分析。 对于奈奎斯特采样定理，我们要求采样频率在我们关心的频率范围内（0-最大频率分量）不发生频谱叠加。因此对于带通采样，我们同样只要求在我们需要的频率内不发生频谱叠加。 随着采样率的增加，采样信号频谱周期延拓的周期越来越大，在这个过程中，我们只需要取带通的频谱不重叠的采样频率就行了。 （偷一下氧离子大佬的图） 红色的是原信号，绿色和蓝色是采样导致的周期延拓出来的信号。 可以看到，我们只需要保证绿色和蓝色的频谱不和红色的频谱重合，就不会发生频谱重叠，我们依然可以得到想要的信号。 将上面的要求用数学公式表达出来：那么就可以得出采样频率的要求是：显然，存在条件是：方框代表向下整，为整数可见，当m=0，就是奈奎斯特采样定理。 三，一个例子假设一个信号的频率在45-55MHz的范围，那么对采样率的要求是 那么可以得到： 最小采样率被降低到了原来的二分之一左右。","categories":[{"name":"信号处理","slug":"信号处理","permalink":"https://lostacnet.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"带通采样","slug":"带通采样","permalink":"https://lostacnet.top/tags/%E5%B8%A6%E9%80%9A%E9%87%87%E6%A0%B7/"}]},{"title":"对Nyquist-Shannon采样定理的直观理解","slug":"对Nyquist-Shannon采样定理的直观理解","date":"2023-04-01T02:54:53.000Z","updated":"2023-04-01T05:16:09.367Z","comments":true,"path":"post/4154/","link":"","permalink":"https://lostacnet.top/post/4154/","excerpt":"对Nyquist-Shannon采样定理的直观理解奈奎斯特(香农)采样定理是信号采样中需要遵守的重要定理，即采样频率至少为信号频率的两倍，才能还原原信号。这里给出对其原理的直观理解。","text":"对Nyquist-Shannon采样定理的直观理解奈奎斯特(香农)采样定理是信号采样中需要遵守的重要定理，即采样频率至少为信号频率的两倍，才能还原原信号。这里给出对其原理的直观理解。 一，时域与频域的联系在讨论具体的采样定理前，首先需要一点基础。 在信号与系统中我们学到，对一个冲激信号，其在频域上是1。而对于1，频域上是一个冲激。如果将1视为周期无限小的冲激信号，但冲激信号的周期从无限小到无限大时，频域上的最开始周期无限大的周期信号也逐渐变成周期无限小的周期信号，最终变成1。 那么从这个过程我们可以得到直观的结论： 时域连续，频域离散，反之亦然。 采样后的信号频谱是原始信号频谱的周期延拓，延拓周期就是采样角频率。 对于第二个结论，这里有着科学的证明：采样定理推导(The Nyquist–Shannon sampling theorem)（本文章的图也来自于这里） 二，采样定理知道采样信号的频谱是原信号的周期延拓后，我们就可以直接理解采样定理了。 如果一个信号的频谱为下图这样： 图中的w是该信号中频率最大的信号分量，这个区间内的信号就原信号的全部频谱。 那么对该信号进行采样后，频谱就会变成该信号的周期延拓: Wo就是采样的角频率，在上图情况中，采样频率小于信号频率的两倍，导致频谱间相互叠加，原信号无法复原。 当采样频率大于信号频率的两倍时，频谱就不会叠加了。这时可以得到原来的信号。","categories":[{"name":"信号处理","slug":"信号处理","permalink":"https://lostacnet.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"奈奎斯特(香农)采样定理","slug":"奈奎斯特-香农-采样定理","permalink":"https://lostacnet.top/tags/%E5%A5%88%E5%A5%8E%E6%96%AF%E7%89%B9-%E9%A6%99%E5%86%9C-%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86/"}]},{"title":"频谱泄露与窗函数","slug":"频谱泄露与窗函数","date":"2023-03-29T15:52:30.000Z","updated":"2023-03-30T06:14:08.832Z","comments":true,"path":"post/32952/","link":"","permalink":"https://lostacnet.top/post/32952/","excerpt":"频谱泄露与窗函数在FFT(傅里叶变换)分析信号时，常常会提到频谱泄露现象，即某频率谱线的幅值分布到其他频段。这样会严重影响信号频率和幅度的判断，为了减轻这种现象，使用窗函数进行截取，即加窗。","text":"频谱泄露与窗函数在FFT(傅里叶变换)分析信号时，常常会提到频谱泄露现象，即某频率谱线的幅值分布到其他频段。这样会严重影响信号频率和幅度的判断，为了减轻这种现象，使用窗函数进行截取，即加窗。 一，频谱泄露现象对原信号做非周期截断后进行FFT，得到的频率谱线会出现旁瓣，即出现原信号频率之外的的频谱，同时原信号幅度降低，可视为原信号的能量泄露到附近频点上。 非周期截断： 做FFT后有频谱泄露： 二，周期截断与非周期截断信号截断由于实际信号处理时，我们不可能将整个原始信号进行FFT，只能截取信号的一部分进行处理，这个过程就叫信号截断。 根据截取信号的长度与周期的关系，可以分为周期截断和非周期截断。 周期截断如果截取信号的长度为原信号周期的整数倍，则截断后的信号依然为周期信号，可以重构为原始信号，进行FFT后的频谱频率成分为原信号频率，100%幅度。 假设原始信号的频率为f Hz，则周期为1/f s，截取信号的时间长度为T=k/f。则频率分辨率为1/T=f/k。那么原信号频率成分为f=k*1/T，即有一条谱线正好是原信号频率成分。 非周期截断如果截取信号的长度不是原信号周期的整数倍，则截断后的信号不是周期信号，重构出来的信号不连续，出现跳跃。 对这种信号进行FFT后，频谱会分散，原信号频率成分的幅值不再是100%。反而原信号周围谱线出现幅值，即泄露到了周围频谱。 非周期截断中，没有一条谱线与原信号完全相同。 三，FFT变换根据傅里叶变换的推导，我们可以知道周期信号可以用傅里叶级数表示，即使用频谱中的一些离散点表示。而对非周期信号，只能用连续的频谱去无限逼近，因此非周期截断会出现泄露。 四，窗函数引入窗函数前，先来直观理解一下什么是窗。我们对信号进行截断，就好像在信号上面套了一个窗户，我们只能看见窗户里面的信号，用这里面的信号去分析原信号。这就是加窗的直观理解。 为什么要使用窗函数窗函数就是给窗内信号的每个点都加上一个权值，使窗内信号的起始和截止幅度都为0，让窗里面的信号变成周期信号，从而减少频谱泄露(不能消除)。 常见窗函数各种窗函数频谱特征的主要差别在于：主瓣宽度（也称为有效噪声带宽，ENBW）、幅值失真度、最高旁瓣高度和旁瓣衰减速率等参数。不同的窗函数具有不同的频谱特征。 主瓣宽度主要影响信号能量分布和频率分辨能力。频率的实际分辨能力为有效噪声带宽乘以频率分辨率，因此，主瓣越宽，有效噪声带宽越宽，在频率分辨率相同的情况下，频率的分辨能力越差。 旁瓣高低及其衰减率影响能量泄漏程度（频谱拖尾效应）。旁瓣越高，说明能量泄漏越严重，衰减越慢，频谱拖尾越严重。 矩形窗如果直接对信号截断，则窗内的信号权重都为1，这种窗称为矩形窗。 这种窗的优点是主瓣比较集中，缺点是旁瓣较高，而且可能伴有负旁瓣，频谱泄漏 现象会较为严重. 特点就是可以保证测量时的频率较为精确，但是不能保证幅值测量的精确性. 三角窗三角窗使用渐进的权重，让边界处的信号为0，这种窗其主瓣宽度比矩形窗宽约一倍，旁瓣 相比于矩形窗非常小，测幅度会准一些但测频率就差。 汉宁窗汉宁窗会增加主瓣宽度，导致频率分辨率下降。 汉明窗汉明窗和汉宁窗基本一致，不一致的只有一个参数。 凯泽窗 其中 N 为序列的长度，I0 的零阶的第一类修正贝塞尔函数，α 是任意非负实数，用于调整凯 泽窗的外形，由使用者根据实际情况给定。 平顶窗 常见窗函数参数 根据此表可以估计窗函数性能，帮助选择。 窗函数选择加窗函数时，应使窗函数频谱的主瓣宽度应尽量窄，以获得高的频率分辨能力；旁瓣衰减应尽量大，以减少频谱拖尾，但通常都不能同时满足这两个要求。因此需要根据实际需求选择合适窗函数。 这里给出一个参考： 如果截断的信号仍为周期信号，则不存在泄漏，无须加窗，相当于加矩形窗。 如果信号是随机信号或者未知信号，或者有多个频率分量，测试关注的是频率点而非能量大小，建议选择汉宁窗。 对于校准目的，则要求幅值精确，平顶窗是个不错的选择。 如果同时要求幅值精度和频率精度，可选择凯塞窗。 如果检测两个频率相近、幅值不同的信号，建议用布莱克曼窗。 锤击法试验力信号加力窗，响应可加指数窗。","categories":[{"name":"信号处理","slug":"信号处理","permalink":"https://lostacnet.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"https://lostacnet.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"加窗","slug":"加窗","permalink":"https://lostacnet.top/tags/%E5%8A%A0%E7%AA%97/"}]},{"title":"对傅里叶变换的一些理解","slug":"对傅里叶变换的一些理解","date":"2023-03-29T15:02:20.000Z","updated":"2023-03-29T15:43:59.205Z","comments":true,"path":"post/32902/","link":"","permalink":"https://lostacnet.top/post/32902/","excerpt":"对傅里叶变换的一些理解傅里叶变换将时域信号变成频域信号，能对信号进行频域上的分析，是分析信号的重要手段。这里我记录一下我对傅里叶变换的过程理解。","text":"对傅里叶变换的一些理解傅里叶变换将时域信号变成频域信号，能对信号进行频域上的分析，是分析信号的重要手段。这里我记录一下我对傅里叶变换的过程理解。 一，基本知识这里不加证明的给出几条基本知识： 任何周期信号都能够用傅里叶级数表示，即写成 形式。 是傅里叶级数系数，也称频率谱线，表示一个频率所占信号成分的的多少，其表达式为。 二，非周期函数的傅里叶变换周期函数的傅里叶变换就是将其写成傅里叶级数的形式，便可得到频谱。而对于不能写成傅里叶级数形式的非周期函数，可以将其视为的特殊情况，无限逼近。 对周期函数有：当时，可以得到：无限大，周期函数变非周期函数 无限小，变成微分 无限小，可以代表任何值，变成连续变量 变成连续的函数 那么定义一个X(jw)：则X(jw)是一个连续的频谱，值与**意义相同**。 现在再次看到周期函数的傅里叶变换，可以看到傅里叶级数是X(jw)的一系列离散点，而非周期函数是整个连续的频谱。 三，逆傅里叶变换周期函数的逆傅里叶变换就是傅里叶级数的形式：非周期函数的逆傅里叶变换则是将离散变连续:","categories":[{"name":"信号处理","slug":"信号处理","permalink":"https://lostacnet.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"https://lostacnet.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"}]},{"title":"MSP432E4学习笔记:工程创建","slug":"MSP432E4学习笔记-工程创建","date":"2023-03-25T08:50:15.000Z","updated":"2023-03-25T14:45:32.758Z","comments":true,"path":"post/32550/","link":"","permalink":"https://lostacnet.top/post/32550/","excerpt":"MSP432E4学习笔记:工程创建由于Ti是电赛的大金主，在比赛中使用Ti的片子会带来优势。正好手头有一块MSP432E401Y(官板真是好看)，所以打算趁着周六强制考勤时间去入门一下。","text":"MSP432E4学习笔记:工程创建由于Ti是电赛的大金主，在比赛中使用Ti的片子会带来优势。正好手头有一块MSP432E401Y(官板真是好看)，所以打算趁着周六强制考勤时间去入门一下。 一，下载必要软件包Ti为MSP430E4提供了SDK。但是Ti官网的命名让人十分迷惑，关于MSP432可以在Ti官网找到两个包：MSP432WARE,SIMPLELINK-MSP432E4-SDK.经过实测，其中SIMPLELINK-MSP432E4-SDK是MSP432E4的SDK，另外一个是MSP432P的SDK(SBTi)。 下载后直接安装，安装完成后会自动打开版本手册和快速开始指导，其中快速指导中写了如何创建新的工程，包括使用CCS，IAR，Keil。我们这里使用Keil进行开发。 Download and Install Keil uVision 5.23 Install the TexasInstruments::MSP432E4xx_DFP pack Install the ARM::CMSIS pack 可以看到，我们还需要下载MSP432E4的keil PACK。 打开keil，进入Pack Installer。 在Devices中找到Ti的MSP432E4。 点击后，在右侧可以看见pack包，可以选择直接在软件中安装(很慢)，也可以选择自己到网页上下载。 这里为了快速下载，我们点击Device中芯片型号后面的蓝色链接打开keil官网，如下图，点击Download按钮直接下载Pack，下载完成后点击安装。 完成上述步骤后开发环境就配置好了，打开SDK安装目录下的点灯例程:examples\\nortos\\MSP_EXP432E401Y\\driverlib\\blinky,打开工程，编译。 将MSPE401Y开发板连接上电脑，这时电脑应该会自动配置驱动，配置完成后点击下载程序，就可以看见灯闪了。 二，创建新的工程（一）通过空工程创建在Quick_Start中，Ti告诉我们不要使用Keil自带的创建工程新建新的工程，要求基于其中的例程进行创建，也就是直接使用Ti给你创建好的工程进行开发。 Do not use the New Project Creation Wizard Start with one of the example projects or empty project template shipped inside the SDK. Each software component in the SDK comes with its own set of examples. If your project depends on multiple TI provided software libraries, start from the empty template then add the necessary components into your projects. Import one of the empty project template shown below to your IDE and start your application from there. All the necessary include paths and SDK specific defines if any are already part of the Empty Project Template 因此，直接打开:examples\\nortos\\MSP_EXP432E401Y\\driverlib\\empty空工程进行就可以进行开发了。 （二）使用Keil创建工程由于之前刚刚学会了如何脱离Cube创建STM32的工程，现在想自己实践一下亲自创建，所以打算手动创建一下Keil工程(浑身反骨)。 我们先打开编译过的blinky工程，首先看一下它的目录结构： 其中Blinky.c是类似于STM32中**main.c文件**，由用户创建。 打开system_msp432e401y,c观察，发现是和时钟频率有关的函数，很像STM32中的文件。 其他四个文件夹分别对应四种不同的开发环境，这里我们打开keil文件夹： 红框中的文件时打开keil编译后产生的，不用管。 .uvoptx结尾的文件是keil的工程，创建工程时建立。 .sct工程是Ti提供的链接文件，具体用途可以百度，但是我们发现Objects中也有一个sct文件，这是keil编译时自动生成的，上图目录中的sct文件其实没用（但是为了保证工程的正确性，最好还是使用Ti提供的sct文件）。 startup_msp432e401y_uvision.s就不用说了吧，经典的启动文件。 那么工程文件结构就看完了，是不是发现少了什么？对，各种奇怪的头文件不见了，然后还没有库函数文件。这些东西在哪呢？ 我们先打开工程文件，看一下keil的配置： 工程目录中可以看到之前在目录中看见的文件，这里多出来一个.a文件，经过查找，发现在simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4\\driverlib\\lib\\keil\\m4f中。 再查看头文件，发现在simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4 以及simplelink_msp432e4_sdk_4_20_00_12\\source\\third_party\\CMSIS\\Include 可以找到 那么到这里就可以知道了，主要的库文件都在E:\\TI\\simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4下面，接下来就可以开始创建工程了。 1，创建工程打开keil，点击新建工程，选择芯片为：MSP432E401Y。 新建完成后，我们将SDK安装目录\\source\\ti\\devices\\msp432e4打开，准备复制文件。 2，复制启动文件首先点开startup_system_files文件夹，将system_msp432e401y.c和keil文件夹中的startup_msp432e401y_uvision.s复制到工程目录下（我复制到了目录中的startup文件夹下） 3，复制连接文件点开linker_files\\keil文件夹，将MSP432E401Y.sct文件复制到工程目录。 4，复制头文件打开simplelink_msp432e4_sdk_4_20_00_12\\source文件夹，可以看到如下文件夹: ti：包含了Ti的各种文件，包括寄存器地址，基本驱动函数库 third_party:第三方的各种文件，包括ARM核的相关操作函数，fatfs文件系统,DSP等库 这里我们需要添加这两个文件夹的东西。 首先是ARM内核和编译器的文件: 打开simplelink_msp432e4_sdk_4_20_00_12\\source\\third_party\\CMSIS\\Include，根据我们使用的芯片(M4内核),以及编译器(gcc)选择添加头文件： cmsis_armcc.h cmsis_compiler.h cmsis_version.h core_cm4.h mpu_armv7.h 然后是Ti的库和启动函数文件： 打开simplelink_msp432e4_sdk_4_20_00_12\\source\\ti\\devices\\msp432e4\\inc 将inc文件夹复制到工程目录。 其实不必全部复制，msp.h和msp432.h文件其实都是根据芯片选型定向到msp432e4xx.h。但是为了程序兼容性，还是一起复制。 5，复制driverlib文件点开driverlib文件夹，里面东西很多，都是基本的驱动库。 inc定义了基本的寄存器基地址，MASK等等 xxx.h/xxx.c则是基本驱动库 lib包含了已经编译好的上述基本驱动库 这里可以选择通过源码添加(直接添加源文件)，也可以添加已经编译好的文件(这样在调试时就不好看寄存器操作了)，为了方便就直接添加lib。 首先将这个文件夹的头文件复制到工程目录(不包括inc中的文件)，然后复制lib中相应的.a文件到工程目录。 6，设置keil点开keil的工程设置，选择C/C++选项，添加Include路径: 工程中的inc文件 driverlib中的inc文件 然后选择Link选项，添加sct文件。 之后选择Debug选项，将调试器改为CMSIS-DAP: 然后添加工程文件: 然后修改文件中头文件的路径，让引用指向本地工程文件夹中的文件。 .a文件需要设置为库文件： 7，编译，下载将点灯工程的代码复制到我们新建的工程中，编译下载，可以看见成功运行。 三，后记相比于CubeMX创建工程，这个创建是真的麻烦，比STM32不用Cube创建都要麻烦。所以还是听官方的话吧，乖乖直接复制空工程开发。 但是这样麻烦还是有回报的：Ti的库文件基本都在本地工程中，可以随意修改而不怕影响到其他工程。不然全部工程共用一个库，肯定会有一堆问题。 其实Ti提供的东西还挺多的，SDK包含了DSP，文件系统，GUI等一堆东西，还有例程，但是这些东西藏的好深，没什么说明。","categories":[{"name":"Ti","slug":"Ti","permalink":"https://lostacnet.top/categories/Ti/"}],"tags":[{"name":"MSP432E4","slug":"MSP432E4","permalink":"https://lostacnet.top/tags/MSP432E4/"}]},{"title":"Typora与hexo的优雅结合:公式和图片","slug":"Typora与hexo的优雅结合-公式和图片","date":"2023-02-21T07:12:17.000Z","updated":"2023-02-21T09:16:27.263Z","comments":true,"path":"post/22112/","link":"","permalink":"https://lostacnet.top/post/22112/","excerpt":"Typora与hexo的优雅结合:公式和图片Typora是一款十分好用的Markdown编写软件，用它写文章可以大大提升工作效率。但是当我想将它用于博客编写时出现了一些问题：1，图片无法正常显示。2，latex公式无法显示。在这里我给出我的解决方法。","text":"Typora与hexo的优雅结合:公式和图片Typora是一款十分好用的Markdown编写软件，用它写文章可以大大提升工作效率。但是当我想将它用于博客编写时出现了一些问题：1，图片无法正常显示。2，latex公式无法显示。在这里我给出我的解决方法。 一，解决公式的显示由于学习方向的特殊性，有时我需要插入一些简单的公式。但是hexo自带的渲染器不支持渲染公式，因此需要引入渲染引擎。 网上常见的方法是使用hexo-math插件支持KaTex和MathJax引擎进行渲染，但是它的用法是这样的： 123{% mathjax %}\\frac{1}{x^2-1}{% endmathjax %} 非常的不优雅:D 因此需要配合其他插件使用(变的麻烦起来了)。对于我这种公式轻度使用者来说麻烦。 但是在hexo-math插件的github界面的最下面推荐了另一款轻量的hexo-filter-mathjax hexo-filter-mathjax: A MathJax plugin developed by @stevenjoezhang, who is also a Hexo developer. It enables you to write LaTeX in-line within your post without using a tag {% %}. hexo-math uses tag plugin approach due to minor incompatibility between LaTeX and marked, the default markdown renderer of Hexo (via hexo-renderer-marked). 可以直接用$来引入公式，和Typora的用法一样，十分的Nice。 根据插件的说明，我们需要卸载一些东西一避免冲突： 删除所有的hexo math plugins–npm uninstall 停止主题的公式渲染–一般在主题设置里面 删除关于公式渲染的插件 Tips:我在使用npm uninstall时发现一直删不掉，最后是先把package.json的无关插件依赖删掉，然后删除node_modules文件夹，然后直接重新npm 使用以下命令安装: 12npm install hexo-filter-mathjax --save //使用--save是将这个插件添加到package.json的依赖列表 然后使用hexo clean清除之前渲染的界面。 打开_config.yml，在文件末尾添加设置选项: 1234567891011mathjax: tags: none # or 'ams' or 'all' single_dollars: true # enable single dollar signs as in-line math delimiters cjk_width: 0.9 # relative CJK char width normal_width: 0.6 # relative normal (monospace) width append_css: true # add CSS to pages rendered by MathJax every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter packages: # extra packages to load extension_options: {} # you can put your extension options here # see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail 之后在文章的Front-matter中添加mathjax: true即可开启当前文章的公式渲染。（如果开启了配置中的every_page即可在每一页默认开启） 使用演示： 123$$THD={\\sqrt{x}}$$ 当然，出现复杂的公式就会出现问题： 123456789101112131415$$A = \\begin{bmatrix}a_{11} &amp; a_{12} &amp; ... &amp; a_{1n}\\\\a_{21} &amp; a_{22} &amp; ... &amp; a_{2n}\\\\a_{31} &amp; a_{22} &amp; ... &amp; a_{3n}\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\a_{n1} &amp; a_{n2} &amp; ... &amp; a_{nn}\\\\\\end{bmatrix} , b = \\begin{bmatrix}b_{1} \\\\b_{2} \\\\b_{3} \\\\\\vdots \\\\b_{n} \\\\\\end{bmatrix}$$ 但我一般用不到，就不管了。 二，解决图片的显示在文章中使用Markdown语法插入图片要面对Markdown语法转换问题，以及图片储存问题，还要考虑如何与Typora优雅的兼容。 1，使用本地储存图片第一种方法将图片储存在本地，在推送时一起上传到托管服务器。 这种方式有很多的插件，包括更换Markdown渲染器，以及图片插入插件来支持markdown的图片插入语法。但是根据hexo的官方文档，在最新版本的默认渲染器hexo-renderer-marked中，已经支持了这种插入方式。 启用方式： 打开_config.yml修改post_asset_folder:true，打开此项后会在使用hexo new命令时，在文章目录下新建同名的文件夹用来储存图片。 在_config.yml中添加： 123marked: prependRoot: true postAsset: true 启用后在文章中使用！[](image.jpg)将会自动解析到上述文件夹中的图片。 （但是这样会导致在本地浏览md文件时无法显示图片） 上述设置之后，打开Typora软件，在文件-&gt;偏好设置-&gt;图片中如下设置: 这样，在Typora中插入图片时，就会自动将图片复制到上面说的同名文件夹了。 然后，当我们写完文章时，注意进行全局替换：将图片路径中的文件夹路径删掉，只保留图片文件名称，这样hexo才能正常渲染。 这时推送后，图片文件会随着网页一起推送到托管网站。 但是这样又不优雅了，本地浏览看不见图片，推送到网站占用有限的空间，如果遇到github这种网站，图片半天加载不出。这时，就要使用图床。 2，使用图床如果使用图床保存图片的话，那么上面的hexo就不用设置。同时，Typora也提供了非常方便的上传设置，可以使用picgo或者自定义脚本进行上传。 首先，我们需要一个稳定的图床：这里我选择了路过图床。但是路过图床关闭了上传图片的API同时picgo也没有支持它的插件，因此需要自己去抓包写一个上传的脚本。 好在，有人已经写出来了(基于python)：up2b。 使用方法（首先确认已经安装python）： 安装up2b包: 1pip isntall up2b 使用以下命令设置路过图床 1up2b -c 1 设置账号 1up2b -l username password 此时就可以使用up2b命令上传图片了。 打开typora，进行如下设置： 点击验证看是否正常运行。 此时，向typora插入图片，会自动上传到图床，并且将图片连接换成网络链接。 这样，就可以在网页上和本地同时看到图片了。 up2b还提供了压缩图片和添加水印的功能，可以到它的主页查看用法。如果无法使用请到github上提issue。 这下看起来好像就万无一失了，但是图床的使用有一个大问题：不稳定。可能哪天你的图片就全部不见了，因此需要图片先存到本地再上传到图床。 3，本地储存+图床这里就不需要设置hexo了，保持默认就行。我们对Typora进行如下设置： 这样在插入图片时，会自动复制到本地文件夹中，当写好文章需要推送时，只需要点击格式-&gt;图像-&gt;上传全部本地图像，这样Typora就会自动上传所有本地图像到图床并且替换图片地址。保证了本地备份和使用图床。 优雅，太优雅了。","categories":[{"name":"blog","slug":"blog","permalink":"https://lostacnet.top/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lostacnet.top/tags/hexo/"},{"name":"Typora","slug":"Typora","permalink":"https://lostacnet.top/tags/Typora/"}]},{"title":"第一篇博客","slug":"第一篇博客","date":"2023-02-18T17:11:55.000Z","updated":"2023-02-20T11:33:58.916Z","comments":true,"path":"post/21911/","link":"","permalink":"https://lostacnet.top/post/21911/","excerpt":"LO_StacNet的第一篇博客这里是LO_StacNet的第一篇博客，LO的学习之路将从这里开始.","text":"LO_StacNet的第一篇博客这里是LO_StacNet的第一篇博客，LO的学习之路将从这里开始. The Next In psot","categories":[{"name":"life","slug":"life","permalink":"https://lostacnet.top/categories/life/"}],"tags":[{"name":"begin","slug":"begin","permalink":"https://lostacnet.top/tags/begin/"}]}],"categories":[{"name":"ESP32","slug":"ESP32","permalink":"https://lostacnet.top/categories/ESP32/"},{"name":"信号处理","slug":"信号处理","permalink":"https://lostacnet.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"Ti","slug":"Ti","permalink":"https://lostacnet.top/categories/Ti/"},{"name":"blog","slug":"blog","permalink":"https://lostacnet.top/categories/blog/"},{"name":"life","slug":"life","permalink":"https://lostacnet.top/categories/life/"}],"tags":[{"name":"ESP-IDF","slug":"ESP-IDF","permalink":"https://lostacnet.top/tags/ESP-IDF/"},{"name":"带通采样","slug":"带通采样","permalink":"https://lostacnet.top/tags/%E5%B8%A6%E9%80%9A%E9%87%87%E6%A0%B7/"},{"name":"奈奎斯特(香农)采样定理","slug":"奈奎斯特-香农-采样定理","permalink":"https://lostacnet.top/tags/%E5%A5%88%E5%A5%8E%E6%96%AF%E7%89%B9-%E9%A6%99%E5%86%9C-%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86/"},{"name":"傅里叶变换","slug":"傅里叶变换","permalink":"https://lostacnet.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"加窗","slug":"加窗","permalink":"https://lostacnet.top/tags/%E5%8A%A0%E7%AA%97/"},{"name":"MSP432E4","slug":"MSP432E4","permalink":"https://lostacnet.top/tags/MSP432E4/"},{"name":"hexo","slug":"hexo","permalink":"https://lostacnet.top/tags/hexo/"},{"name":"Typora","slug":"Typora","permalink":"https://lostacnet.top/tags/Typora/"},{"name":"begin","slug":"begin","permalink":"https://lostacnet.top/tags/begin/"}]}